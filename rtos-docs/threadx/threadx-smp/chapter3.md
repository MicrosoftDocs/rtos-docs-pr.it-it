---
title: Capitolo 3-componenti funzionali di Azure RTO ThreadX SMP
description: Questo capitolo contiene una descrizione del kernel SMP di HighPerformance Azure RTO ThreadX dal punto di vista funzionale.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6a72acb111aa986f4621e8747568ce3ce3e5e080
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104823363"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx-smp"></a><span data-ttu-id="a4012-103">Capitolo 3-componenti funzionali di Azure RTO ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="a4012-103">Chapter 3 - Functional Components of Azure RTOS ThreadX SMP</span></span>

<span data-ttu-id="a4012-104">Questo capitolo contiene una descrizione del kernel SMP di HighPerformance Azure RTO ThreadX dal punto di vista funzionale.</span><span class="sxs-lookup"><span data-stu-id="a4012-104">This chapter contains a description of the highperformance Azure RTOS ThreadX SMP kernel from a functional perspective.</span></span> <span data-ttu-id="a4012-105">Ogni componente funzionale viene presentato in modo facile da comprendere.</span><span class="sxs-lookup"><span data-stu-id="a4012-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="a4012-106">Panoramica dell'esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-106">Execution Overview</span></span>

<span data-ttu-id="a4012-107">Sono disponibili quattro tipi di esecuzione del programma all'interno di un'applicazione SMP di ThreadX: inizializzazione, esecuzione dei thread, routine del servizio di interrupt (ISRs) e timer dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-107">There are four types of program execution within a ThreadX SMP application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="a4012-108">La figura 1 nella pagina 45 Mostra ogni tipo di esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="a4012-108">Figure 1 on page 45 shows each different type of program execution.</span></span> <span data-ttu-id="a4012-109">Le informazioni più dettagliate su ognuno di questi tipi sono disponibili nelle sezioni successive di questo capitolo.</span><span class="sxs-lookup"><span data-stu-id="a4012-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="a4012-110">Inizializzazione</span><span class="sxs-lookup"><span data-stu-id="a4012-110">Initialization</span></span>
<span data-ttu-id="a4012-111">Come suggerisce il nome, questo è il primo tipo di esecuzione del programma in un'applicazione ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-111">As the name implies, this is the first type of program execution in a ThreadX SMP application.</span></span> <span data-ttu-id="a4012-112">L'inizializzazione include l'esecuzione del programma tra la reimpostazione del processore e il punto di ingresso del *ciclo di pianificazione dei thread.*</span><span class="sxs-lookup"><span data-stu-id="a4012-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-113">L'inizializzazione viene eseguita da o avviata da Core 0, ovvero il core predefinito in esecuzione dopo la reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-113">Initialization is performed by or initiated by core 0, which is the default running core after reset.</span></span>

### <a name="thread-execution"></a><span data-ttu-id="a4012-114">Esecuzione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-114">Thread Execution</span></span>
<span data-ttu-id="a4012-115">Al termine dell'inizializzazione, ogni core che esegue ThreadX SMP entra nel ciclo di pianificazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-115">After initialization is complete, each core running ThreadX SMP enters its thread scheduling loop.</span></span> <span data-ttu-id="a4012-116">Il ciclo di pianificazione cerca un thread dell'applicazione pronto per l'esecuzione in tale Core.</span><span class="sxs-lookup"><span data-stu-id="a4012-116">The scheduling loop looks for an application thread ready for execution on that core.</span></span> <span data-ttu-id="a4012-117">Quando viene trovato un thread pronto, ThreadX SMP trasferisce il controllo a tale thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-117">When a ready thread is found, ThreadX SMP transfers control to it.</span></span> <span data-ttu-id="a4012-118">Una volta terminato il thread (o un altro thread con priorità più alta), l'esecuzione viene ritrasferita al ciclo di pianificazione dei thread per individuare il successivo thread pronto per la priorità più alta in ogni core.</span><span class="sxs-lookup"><span data-stu-id="a4012-118">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread on each core.</span></span>

<span data-ttu-id="a4012-119">Questo processo di esecuzione continua e pianificazione dei thread è il tipo più comune di esecuzione di programmi nelle applicazioni ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-119">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX SMP applications.</span></span>

![Esecuzione thread](media/image4.png)

<span data-ttu-id="a4012-121">**FIGURA 1. Tipi di esecuzione del programma**</span><span class="sxs-lookup"><span data-stu-id="a4012-121">**FIGURE 1. Types of Program Execution**</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="a4012-122">Routine del servizio di interrupt (ISR)</span><span class="sxs-lookup"><span data-stu-id="a4012-122">Interrupt Service Routines (ISR)</span></span>
<span data-ttu-id="a4012-123">Gli interrupt sono l'elemento fondamentale dei sistemi in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-123">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="a4012-124">Senza interruzioni, sarebbe molto difficile rispondere alle modifiche nel mondo esterno in modo tempestivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-124">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="a4012-125">Al rilevamento di un interrupt, il processore salva le informazioni chiave sull'esecuzione del programma corrente (in genere nello stack), quindi trasferisce il controllo a un'area del programma predefinita.</span><span class="sxs-lookup"><span data-stu-id="a4012-125">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="a4012-126">Questa area del programma predefinita è comunemente denominata routine del servizio di interrupt.</span><span class="sxs-lookup"><span data-stu-id="a4012-126">This predefined program area is commonly called an Interrupt Service Routine.</span></span>

<span data-ttu-id="a4012-127">Nella maggior parte dei casi, gli interrupt si verificano durante l'esecuzione del thread o nel ciclo di pianificazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-127">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="a4012-128">Tuttavia, gli interrupt possono verificarsi anche all'interno di un ISR in esecuzione o di un timer dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-128">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

<span data-ttu-id="a4012-129">Tutti i core sono autorizzati a elaborare gli interrupt.</span><span class="sxs-lookup"><span data-stu-id="a4012-129">All cores are allowed to process interrupts.</span></span> <span data-ttu-id="a4012-130">Il mapping degli interrupt ai core è sotto il controllo diretto dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-130">The mapping of interrupts to cores is under the direct control of the application.</span></span> <span data-ttu-id="a4012-131">Per impostazione predefinita, l'interrupt del timer SMP di ThreadX è assegnato a Core 0 per l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-131">The ThreadX SMP timer interrupt is by default assigned to core 0 for processing.</span></span> <span data-ttu-id="a4012-132">Vedere il codice in *tx_timer_interrupt. Per l'* implementazione di questa assegnazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-132">Please see the code in *tx_timer_interrupt.S* for implementation of this assignment.</span></span>

### <a name="application-timers"></a><span data-ttu-id="a4012-133">Timer applicazione</span><span class="sxs-lookup"><span data-stu-id="a4012-133">Application Timers</span></span>
<span data-ttu-id="a4012-134">I timer dell'applicazione sono simili a ISRs, con l'eccezione che l'implementazione dell'hardware (in genere viene usato un singolo interrupt hardware periodico) viene nascosta dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-134">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="a4012-135">Tali timer vengono usati dalle applicazioni per eseguire i servizi di timeout, Periodics e/o watchdog.</span><span class="sxs-lookup"><span data-stu-id="a4012-135">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="a4012-136">Analogamente a ISRs, i timer dell'applicazione interrompono più spesso l'esecuzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-136">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="a4012-137">A differenza di ISRs, tuttavia, i timer dell'applicazione non possono interrompersi tra loro.</span><span class="sxs-lookup"><span data-stu-id="a4012-137">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

> [!NOTE]
> <span data-ttu-id="a4012-138">Analogamente ai thread, i timer dell'applicazione possono essere esclusi dall'esecuzione in qualsiasi core.</span><span class="sxs-lookup"><span data-stu-id="a4012-138">That like threads, application timers can be excluded from execution on any core.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="a4012-139">Utilizzo memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-139">Memory Usage</span></span>

<span data-ttu-id="a4012-140">ThreadX SMP si trova insieme al programma applicativo.</span><span class="sxs-lookup"><span data-stu-id="a4012-140">ThreadX SMP resides along with the application program.</span></span> <span data-ttu-id="a4012-141">Di conseguenza, l'utilizzo della memoria statica (o della memoria fissa) di ThreadX SMP è determinato dagli strumenti di sviluppo; ad esempio, il compilatore, il linker e il localizzatore.</span><span class="sxs-lookup"><span data-stu-id="a4012-141">As a result, the static memory (or fixed memory) usage of ThreadX SMP is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="a4012-142">L'utilizzo della memoria dinamica (o della memoria di run-time) è sotto il controllo diretto dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-142">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

> [!NOTE]
> <span data-ttu-id="a4012-143">Tutta la memoria a cui si accede da ThreadX SMP deve essere memorizzata nella cache coerente e accessibile da tutti i core che eseguono ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-143">All the memory accessed by ThreadX SMP must be cache coherent and accessible from all cores executing ThreadX SMP.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="a4012-144">Utilizzo memoria statica</span><span class="sxs-lookup"><span data-stu-id="a4012-144">Static Memory Usage</span></span>
<span data-ttu-id="a4012-145">La maggior parte degli strumenti di sviluppo divide l'immagine del programma applicativa in cinque aree di base: *istruzione*, *costante*, *dati inizializzati*, *dati non inizializzati* e *stack di sistema*.</span><span class="sxs-lookup"><span data-stu-id="a4012-145">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="a4012-146">Nella figura 2 della pagina 47 viene illustrato un esempio di queste aree di memoria.</span><span class="sxs-lookup"><span data-stu-id="a4012-146">Figure 2 on page 47 shows an example of these memory areas.</span></span>

![Utilizzo memoria statica](media/image5.png)

<span data-ttu-id="a4012-148">**FIGURA 2. Esempio di area di memoria**</span><span class="sxs-lookup"><span data-stu-id="a4012-148">**FIGURE 2. Memory Area Example**</span></span>

<span data-ttu-id="a4012-149">È importante comprendere che questo è solo un esempio.</span><span class="sxs-lookup"><span data-stu-id="a4012-149">It is important to understand that this is only an example.</span></span> <span data-ttu-id="a4012-150">Il layout di memoria statica effettivo è specifico del processore, degli strumenti di sviluppo e dell'hardware sottostante.</span><span class="sxs-lookup"><span data-stu-id="a4012-150">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="a4012-151">L'area di istruzioni contiene tutte le istruzioni del processore del programma.</span><span class="sxs-lookup"><span data-stu-id="a4012-151">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="a4012-152">Questa area è in genere la più grande e spesso si trova in ROM.</span><span class="sxs-lookup"><span data-stu-id="a4012-152">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="a4012-153">L'area costante contiene varie costanti compilate, incluse le stringhe definite o a cui viene fatto riferimento all'interno del programma.</span><span class="sxs-lookup"><span data-stu-id="a4012-153">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="a4012-154">Inoltre, quest'area contiene la "copia iniziale" dell'area dati inizializzata.</span><span class="sxs-lookup"><span data-stu-id="a4012-154">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="a4012-155">Durante il processo di inizializzazione del compilatore, questa parte dell'area costante viene utilizzata per configurare l'area dati inizializzata in RAM.</span><span class="sxs-lookup"><span data-stu-id="a4012-155">During the compiler’s initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="a4012-156">L'area costante segue in genere l'area di istruzioni e spesso si trova nella ROM.</span><span class="sxs-lookup"><span data-stu-id="a4012-156">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="a4012-157">I dati inizializzati e le aree dati non inizializzate contengono tutte le variabili globali e statiche.</span><span class="sxs-lookup"><span data-stu-id="a4012-157">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="a4012-158">Queste aree sono sempre situate in RAM.</span><span class="sxs-lookup"><span data-stu-id="a4012-158">These areas are always located in RAM.</span></span>

<span data-ttu-id="a4012-159">Lo stack di sistema viene in genere configurato immediatamente dopo le aree dati inizializzate e non inizializzate.</span><span class="sxs-lookup"><span data-stu-id="a4012-159">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span> <span data-ttu-id="a4012-160">Lo stack di sistema viene usato dal compilatore durante l'inizializzazione, quindi da ThreadX SMP durante l'inizializzazione e, successivamente, nell'elaborazione ISR.</span><span class="sxs-lookup"><span data-stu-id="a4012-160">The system stack is used by the compiler during initialization, then by ThreadX SMP during initialization and, subsequently, in ISR processing.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="a4012-161">Utilizzo memoria dinamica</span><span class="sxs-lookup"><span data-stu-id="a4012-161">Dynamic Memory Usage</span></span>
<span data-ttu-id="a4012-162">Come indicato in precedenza, l'utilizzo della memoria dinamica è sotto il controllo diretto dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-162">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="a4012-163">I blocchi di controllo e le aree di memoria associati a stack, code e pool di memoria possono essere posizionati in qualsiasi punto dello spazio di memoria della destinazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-163">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="a4012-164">Si tratta di una funzionalità importante perché semplifica l'utilizzo di diversi tipi di memoria fisica.</span><span class="sxs-lookup"><span data-stu-id="a4012-164">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="a4012-165">Si supponga, ad esempio, che un ambiente hardware di destinazione disponga sia di memoria veloce che di memoria lenta.</span><span class="sxs-lookup"><span data-stu-id="a4012-165">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="a4012-166">Se l'applicazione richiede prestazioni aggiuntive per un thread con priorità alta, il blocco di controllo (TX_THREAD) e lo stack possono essere inseriti nell'area di memoria veloce, che può migliorare significativamente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a4012-166">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="a4012-167">Inizializzazione</span><span class="sxs-lookup"><span data-stu-id="a4012-167">Initialization</span></span> 
<span data-ttu-id="a4012-168">La comprensione del processo di inizializzazione è importante.</span><span class="sxs-lookup"><span data-stu-id="a4012-168">Understanding the initialization process is important.</span></span> <span data-ttu-id="a4012-169">L'ambiente hardware iniziale è configurato qui.</span><span class="sxs-lookup"><span data-stu-id="a4012-169">The initial hardware environment is set up here.</span></span> <span data-ttu-id="a4012-170">Inoltre, è il punto in cui l'applicazione riceve la personalità iniziale.</span><span class="sxs-lookup"><span data-stu-id="a4012-170">In addition, this is where the application is given its initial personality.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-171">ThreadX SMP tenta di utilizzare (laddove possibile) il processo di inizializzazione completo dello strumento di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-171">ThreadX SMP attempts to utilize (whenever possible) the complete development tool’s initialization process.</span></span> <span data-ttu-id="a4012-172">In questo modo sarà più semplice eseguire l'aggiornamento a nuove versioni degli strumenti di sviluppo in futuro.</span><span class="sxs-lookup"><span data-stu-id="a4012-172">This makes it easier to upgrade to new versions of the development tools in the future.</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="a4012-173">Vettore di ripristino del sistema</span><span class="sxs-lookup"><span data-stu-id="a4012-173">System Reset Vector</span></span> 
<span data-ttu-id="a4012-174">Tutti i microprocessori hanno una logica di reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-174">All microprocessors have reset logic.</span></span> <span data-ttu-id="a4012-175">Quando si verifica una reimpostazione, ovvero hardware o software, l'indirizzo del punto di ingresso dell'applicazione viene recuperato da una posizione di memoria specifica.</span><span class="sxs-lookup"><span data-stu-id="a4012-175">When a reset occurs (either hardware or software), the address of the application’s entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="a4012-176">Una volta recuperato il punto di ingresso, il processore trasferisce il controllo a tale posizione.</span><span class="sxs-lookup"><span data-stu-id="a4012-176">After the entry point is retrieved, the processor transfers control to that location.</span></span> 

<span data-ttu-id="a4012-177">Il punto di ingresso dell'applicazione è spesso scritto nel linguaggio degli assembly nativi e viene in genere fornito dagli strumenti di sviluppo (almeno in formato modello).</span><span class="sxs-lookup"><span data-stu-id="a4012-177">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="a4012-178">In alcuni casi, viene fornita una versione speciale del programma entry con ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-178">In some cases, a special version of the entry program is supplied with ThreadX SMP.</span></span> 

### <a name="development-tool-initialization"></a><span data-ttu-id="a4012-179">Inizializzazione dello strumento di sviluppo</span><span class="sxs-lookup"><span data-stu-id="a4012-179">Development Tool Initialization</span></span>
<span data-ttu-id="a4012-180">Al termine dell'inizializzazione di basso livello, il controllo viene trasferito all'inizializzazione di alto livello dello strumento di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-180">After the low-level initialization is complete, control transfers to the development tool’s high-level initialization.</span></span> <span data-ttu-id="a4012-181">Si tratta in genere della posizione in cui sono impostate le variabili C globali e statiche inizializzate.</span><span class="sxs-lookup"><span data-stu-id="a4012-181">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="a4012-182">Tenere presente che i valori iniziali vengono recuperati dall'area costante.</span><span class="sxs-lookup"><span data-stu-id="a4012-182">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="a4012-183">L'elaborazione dell'inizializzazione esatta è specifica dello strumento di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-183">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="a4012-184">Main (funzione)</span><span class="sxs-lookup"><span data-stu-id="a4012-184">main Function</span></span> 
<span data-ttu-id="a4012-185">Al termine dell'inizializzazione dello strumento di sviluppo, il controllo viene trasferito alla funzione *principale* fornita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="a4012-185">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="a4012-186">A questo punto, l'applicazione controlla cosa accade successivamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-186">At this point, the application controls what happens next.</span></span> <span data-ttu-id="a4012-187">Per la maggior parte delle applicazioni, la funzione Main chiama semplicemente *tx_kernel_enter*, che è la voce in threadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-187">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX SMP.</span></span> <span data-ttu-id="a4012-188">Tuttavia, le applicazioni possono eseguire l'elaborazione preliminare, in genere per l'inizializzazione dell'hardware, prima di accedere a ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-188">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX SMP.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-189">La chiamata a tx_kernel_enter non restituisce, quindi non inserire alcuna elaborazione dopo.</span><span class="sxs-lookup"><span data-stu-id="a4012-189">The call to tx_kernel_enter does not return, so do not place any processing after it!</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="a4012-190">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="a4012-190">tx_kernel_enter</span></span> 
<span data-ttu-id="a4012-191">La funzione entry coordina l'inizializzazione di varie strutture di dati ThreadX SMP interne, quindi chiama la funzione di definizione dell'applicazione *tx_application_define*.</span><span class="sxs-lookup"><span data-stu-id="a4012-191">The entry function coordinates initialization of various internal ThreadX SMP data structures and then calls the application’s definition function *tx_application_define*.</span></span>

<span data-ttu-id="a4012-192">Quando *tx_application_define* restituisce, il controllo viene trasferito al ciclo di pianificazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-192">When *tx_application_define* returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="a4012-193">Questa operazione contrassegna la fine dell'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-193">This marks the end of initialization!</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="a4012-194">Funzione definizione applicazione</span><span class="sxs-lookup"><span data-stu-id="a4012-194">Application Definition Function</span></span>
<span data-ttu-id="a4012-195">La funzione *tx_application_define* definisce tutti i thread dell'applicazione, le code, i semafori, i mutex, i flag di evento, i pool di memoria e i timer iniziali.</span><span class="sxs-lookup"><span data-stu-id="a4012-195">The *tx_application_define* function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="a4012-196">È anche possibile creare ed eliminare le risorse di sistema dai thread durante il normale funzionamento dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-196">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="a4012-197">Tuttavia, tutte le risorse dell'applicazione iniziale sono definite qui.</span><span class="sxs-lookup"><span data-stu-id="a4012-197">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="a4012-198">La funzione *tx_application_define* dispone di un solo parametro di input ed è sicuramente opportuno citare.</span><span class="sxs-lookup"><span data-stu-id="a4012-198">The *tx_application_define* function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="a4012-199">Il *primo* indirizzo di RAM disponibile è l'unico parametro di input per questa funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-199">The *first-available* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="a4012-200">Viene in genere utilizzato come punto di partenza per le allocazioni di memoria di runtime iniziali di stack di thread, code e pool di memoria.</span><span class="sxs-lookup"><span data-stu-id="a4012-200">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-201">Al termine dell'inizializzazione, solo un thread in esecuzione può creare ed eliminare le risorse di sistema, inclusi gli altri thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-201">After initialization is complete, only an executing thread can create and delete system resources—including other threads.</span></span> <span data-ttu-id="a4012-202">Per questo motivo, durante l'inizializzazione deve essere creato almeno un thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-202">Therefore, at least one thread must be created during initialization.</span></span>

### <a name="interrupts"></a><span data-ttu-id="a4012-203">Interrompe</span><span class="sxs-lookup"><span data-stu-id="a4012-203">Interrupts</span></span> 
<span data-ttu-id="a4012-204">Gli interrupt vengono lasciati disabilitati durante l'intero processo di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-204">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="a4012-205">Se l'applicazione è in grado di consentire interruzioni, potrebbe verificarsi un comportamento imprevedibile.</span><span class="sxs-lookup"><span data-stu-id="a4012-205">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="a4012-206">Nella figura 3 della pagina 52 viene illustrato l'intero processo di inizializzazione, dal ripristino del sistema tramite l'inizializzazione specifica dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-206">Figure 3 on page 52 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="a4012-207">Esecuzione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-207">Thread Execution</span></span>

<span data-ttu-id="a4012-208">La pianificazione e l'esecuzione dei thread dell'applicazione sono l'attività più importante di ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-208">Scheduling and executing application threads is the most important activity of ThreadX SMP.</span></span> <span data-ttu-id="a4012-209">Un thread viene in genere definito come segmento di programma parzialmente indipendente con uno scopo dedicato.</span><span class="sxs-lookup"><span data-stu-id="a4012-209">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="a4012-210">L'elaborazione combinata di tutti i thread crea un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-210">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="a4012-211">I thread vengono creati dinamicamente chiamando *tx_thread_create* durante l'inizializzazione o durante l'esecuzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-211">Threads are created dynamically by calling *tx_thread_create* during initialization or during thread execution.</span></span> <span data-ttu-id="a4012-212">I thread vengono creati in uno stato *pronto* o *sospeso* .</span><span class="sxs-lookup"><span data-stu-id="a4012-212">Threads are created in either a *ready* or *suspended* state.</span></span>

![Processo di inizializzazione SMP](media/image6.png)

<span data-ttu-id="a4012-214">**FIGURA 3. Processo di inizializzazione SMP**</span><span class="sxs-lookup"><span data-stu-id="a4012-214">**FIGURE 3. SMP Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="a4012-215">Stati di esecuzione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-215">Thread Execution States</span></span>  
<span data-ttu-id="a4012-216">Comprendere i diversi Stati di elaborazione dei thread è un ingrediente chiave per comprendere l'intero ambiente multithread.</span><span class="sxs-lookup"><span data-stu-id="a4012-216">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="a4012-217">In ThreadX SMP sono presenti cinque Stati di thread distinti: *pronto*, *sospeso*, in *esecuzione*, *terminato* e *completato*.</span><span class="sxs-lookup"><span data-stu-id="a4012-217">In ThreadX SMP, there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="a4012-218">Nella figura 4 viene illustrato il diagramma di transizione dello stato del thread per ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-218">Figure 4 shows the thread state transition diagram for ThreadX SMP.</span></span>

![Stati di esecuzione thread](media/image7.png)

<span data-ttu-id="a4012-220">**FIGURA 4. Transizione dello stato del thread**</span><span class="sxs-lookup"><span data-stu-id="a4012-220">**FIGURE 4. Thread State Transition**</span></span>

<span data-ttu-id="a4012-221">Un thread si trova in uno stato *pronto* quando è pronto per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-221">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="a4012-222">Un thread pronto non viene eseguito fino a quando non è il thread con priorità più elevata nello stato Ready.</span><span class="sxs-lookup"><span data-stu-id="a4012-222">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="a4012-223">Quando si verifica questa situazione, ThreadX SMP esegue il thread, che quindi modifica lo stato in in *esecuzione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-223">When this happens, ThreadX SMP executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="a4012-224">Se un thread con priorità più alta diventa pronto, il thread in esecuzione torna a uno stato *pronto* .</span><span class="sxs-lookup"><span data-stu-id="a4012-224">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="a4012-225">Viene quindi eseguito il thread ad alta priorità appena pronto, che modifica lo stato logico in *esecuzione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-225">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="a4012-226">Questa transizione tra gli stati *pronto* ed *esecuzione* si verifica ogni volta che si verifica l'interruzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-226">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="a4012-227">In un momento specifico, solo un thread è in *esecuzione* .</span><span class="sxs-lookup"><span data-stu-id="a4012-227">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="a4012-228">Questo perché un thread nello stato in *esecuzione* ha il controllo del processore sottostante.</span><span class="sxs-lookup"><span data-stu-id="a4012-228">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="a4012-229">I thread in stato *sospeso* non sono idonei per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-229">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="a4012-230">I motivi per essere *sospesi* includono la sospensione per il tempo, i messaggi della coda, i semafori, i mutex, i flag di evento, la memoria e la sospensione di thread di base.</span><span class="sxs-lookup"><span data-stu-id="a4012-230">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="a4012-231">Una volta rimossa la provocazione della sospensione, il thread viene nuovamente inserito in uno stato *pronto* .</span><span class="sxs-lookup"><span data-stu-id="a4012-231">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="a4012-232">Un thread in stato *completato* è un thread che ha completato l'elaborazione e restituito dalla relativa funzione entry.</span><span class="sxs-lookup"><span data-stu-id="a4012-232">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="a4012-233">La funzione entry viene specificata durante la creazione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-233">The entry function is specified during thread creation.</span></span> <span data-ttu-id="a4012-234">Un thread in stato *completato* non può essere eseguito nuovamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-234">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="a4012-235">Un thread è in uno stato *terminato* perché un altro thread o il thread stesso ha chiamato il servizio *tx_thread_terminate* .</span><span class="sxs-lookup"><span data-stu-id="a4012-235">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="a4012-236">Un thread in uno stato *terminato* non può essere eseguito nuovamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-236">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-237">Se si desidera riavviare un thread completato o terminato, l'applicazione deve innanzitutto eliminare il thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-237">If re-starting a completed or terminated thread is desired, the application must first delete the thread.</span></span> <span data-ttu-id="a4012-238">Può quindi essere ricreato e riavviato.</span><span class="sxs-lookup"><span data-stu-id="a4012-238">It can then be re-created and re-started.</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="a4012-239">Notifica voce/uscita thread</span><span class="sxs-lookup"><span data-stu-id="a4012-239">Thread Entry/Exit Notification</span></span>  
<span data-ttu-id="a4012-240">Per alcune applicazioni può risultare vantaggioso ricevere una notifica quando viene immesso un thread specifico per la prima volta, quando viene completato o terminato.</span><span class="sxs-lookup"><span data-stu-id="a4012-240">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="a4012-241">ThreadX SMP offre questa possibilità tramite il servizio *tx_thread_entry_exit_notify* .</span><span class="sxs-lookup"><span data-stu-id="a4012-241">ThreadX SMP provides this ability through the *tx_thread_entry_exit_notify* service.</span></span> <span data-ttu-id="a4012-242">Questo servizio registra una funzione di notifica dell'applicazione per un thread specifico, che viene chiamato da ThreadX SMP ogni volta che il thread viene avviato, viene completato o terminato.</span><span class="sxs-lookup"><span data-stu-id="a4012-242">This service registers an application notification function for a specific thread, which is called by ThreadX SMP whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="a4012-243">Dopo essere stato richiamato, la funzione di notifica dell'applicazione può eseguire l'elaborazione applicationspecific.</span><span class="sxs-lookup"><span data-stu-id="a4012-243">After being invoked, the application notification function can perform the applicationspecific processing.</span></span> <span data-ttu-id="a4012-244">Ciò comporta in genere l'informazione di un altro thread dell'evento tramite una primitiva di sincronizzazione SMP di ThreadX.</span><span class="sxs-lookup"><span data-stu-id="a4012-244">This typically involves informing another application thread of the event via a ThreadX SMP synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="a4012-245">Priorità dei thread</span><span class="sxs-lookup"><span data-stu-id="a4012-245">Thread Priorities</span></span>  
<span data-ttu-id="a4012-246">Come indicato in precedenza, un thread è un segmento di programma parzialmente indipendente con uno scopo dedicato.</span><span class="sxs-lookup"><span data-stu-id="a4012-246">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="a4012-247">Tuttavia, tutti i thread non vengono creati uguali.</span><span class="sxs-lookup"><span data-stu-id="a4012-247">However, all threads are not created equal!</span></span> <span data-ttu-id="a4012-248">Lo scopo dedicato di alcuni thread è molto più importante di altri.</span><span class="sxs-lookup"><span data-stu-id="a4012-248">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="a4012-249">Questo tipo eterogeneo di importanza dei thread è una caratteristica delle applicazioni incorporate in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-249">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="a4012-250">ThreadX SMP determina l'importanza di un thread quando il thread viene creato assegnando un valore numerico che rappresenta la *priorità*.</span><span class="sxs-lookup"><span data-stu-id="a4012-250">ThreadX SMP determines a thread’s importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="a4012-251">Il numero massimo di priorità SMP di ThreadX è configurabile da 32 a 1024 con incrementi di 32.</span><span class="sxs-lookup"><span data-stu-id="a4012-251">The maximum number of ThreadX SMP priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="a4012-252">Il numero massimo effettivo di priorità è determinato dalla costante *TX_MAX_PRIORITIES* durante la compilazione della libreria SMP di threadX.</span><span class="sxs-lookup"><span data-stu-id="a4012-252">The actual maximum number of priorities is determined by the *TX_MAX_PRIORITIES* constant during compilation of the ThreadX SMP library.</span></span> <span data-ttu-id="a4012-253">La presenza di un numero maggiore di priorità non comporta un aumento significativo del sovraccarico di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-253">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="a4012-254">Tuttavia, per ogni gruppo di 32 livelli di priorità, per gestirli sono necessari 128 byte aggiuntivi di RAM.</span><span class="sxs-lookup"><span data-stu-id="a4012-254">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="a4012-255">Ad esempio, 32 livelli di priorità richiedono 128 byte di RAM, 64 livelli di priorità richiedono 256 byte di RAM e i livelli di priorità 96 richiedono 384 byte di RAM.</span><span class="sxs-lookup"><span data-stu-id="a4012-255">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="a4012-256">Per impostazione predefinita, ThreadX SMP presenta 32 livelli di priorità, compresi tra la priorità 0 e la priorità 31.</span><span class="sxs-lookup"><span data-stu-id="a4012-256">By default, ThreadX SMP has 32 priority levels, ranging from priority 0 through priority 31.</span></span>

<span data-ttu-id="a4012-257">Valori numericamente inferiori implicano una priorità più elevata.</span><span class="sxs-lookup"><span data-stu-id="a4012-257">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="a4012-258">Di conseguenza, Priority 0 rappresenta la priorità più alta, mentre Priority (*TX_MAX_PRIORITIES*-1) rappresenta la priorità più bassa.</span><span class="sxs-lookup"><span data-stu-id="a4012-258">Hence, priority 0 represents the highest priority, while priority (*TX_MAX_PRIORITIES*-1) represents the lowest priority.</span></span>

<span data-ttu-id="a4012-259">Più thread possono avere la stessa priorità basandosi sulla pianificazione cooperativa o sul sezionamento dei tempi.</span><span class="sxs-lookup"><span data-stu-id="a4012-259">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="a4012-260">Inoltre, le priorità del thread possono essere modificate in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-260">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="a4012-261">Pianificazione di thread</span><span class="sxs-lookup"><span data-stu-id="a4012-261">Thread Scheduling</span></span> 
<span data-ttu-id="a4012-262">ThreadX SMP Pianifica i thread in base alla priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-262">ThreadX SMP schedules threads based on their priority.</span></span> <span data-ttu-id="a4012-263">Il thread pronto con la priorità più alta viene eseguito per primo.</span><span class="sxs-lookup"><span data-stu-id="a4012-263">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="a4012-264">Se sono pronti più thread con la stessa priorità, vengono eseguiti in modalità FIFO ( *First-in-First-out* ).</span><span class="sxs-lookup"><span data-stu-id="a4012-264">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

<span data-ttu-id="a4012-265">Per impostazione predefinita, ThreadX SMP Pianifica i "n" thread con priorità più elevata nei processori disponibili "n".</span><span class="sxs-lookup"><span data-stu-id="a4012-265">By default, ThreadX SMP schedules the “n” highest priority threads on the “n” available processors.</span></span> <span data-ttu-id="a4012-266">Se l'elaborazione simultanea è necessaria solo per thread pronti con la stessa priorità, la libreria SMP di ThreadX deve essere compilata con **TX_THREAD_SMP_EQUAL_PRIORITY** definito.</span><span class="sxs-lookup"><span data-stu-id="a4012-266">If concurrent processing is only required on ready threads of the same priority, the ThreadX SMP library must be built with **TX_THREAD_SMP_EQUAL_PRIORITY** defined.</span></span>

> [!NOTE]
> <span data-ttu-id="a4012-267">Che tutti i thread possono essere inizialmente impostati come predefiniti per l'esecuzione solo su Core 0, compilando la libreria SMP di ThreadX con **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** definito.</span><span class="sxs-lookup"><span data-stu-id="a4012-267">That all threads can be initially defaulted to only run on core 0, by building the ThreadX SMP library with **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** defined.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="a4012-268">Pianificazione Round Robin</span><span class="sxs-lookup"><span data-stu-id="a4012-268">Round-robin Scheduling</span></span>  
<span data-ttu-id="a4012-269">ThreadX SMP supporta la pianificazione *Round Robin* di più thread con la stessa priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-269">ThreadX SMP supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="a4012-270">Questa operazione viene eseguita tramite chiamate cooperative a *tx_thread_relinquish*.</span><span class="sxs-lookup"><span data-stu-id="a4012-270">This is accomplished through cooperative calls to *tx_thread_relinquish*.</span></span> <span data-ttu-id="a4012-271">Questo servizio fornisce a tutti gli altri thread pronti con la stessa priorità la possibilità di eseguire prima di eseguire di nuovo il chiamante del *tx_thread_relinquish* .</span><span class="sxs-lookup"><span data-stu-id="a4012-271">This service gives all other ready threads of the same priority a chance to execute before the *tx_thread_relinquish* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="a4012-272">Time-Slicing</span><span class="sxs-lookup"><span data-stu-id="a4012-272">Time-Slicing</span></span> 
<span data-ttu-id="a4012-273">Il *sezionamento del tempo* è un altro tipo di pianificazione Round Robin.</span><span class="sxs-lookup"><span data-stu-id="a4012-273">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="a4012-274">Una sezione di tempo specifica il numero massimo di cicli timer (interrupt timer) che un thread può eseguire senza rinunciare al processore.</span><span class="sxs-lookup"><span data-stu-id="a4012-274">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="a4012-275">In ThreadX SMP, il sezionamento del tempo è disponibile su base perthread.</span><span class="sxs-lookup"><span data-stu-id="a4012-275">In ThreadX SMP, time-slicing is available on a perthread basis.</span></span> <span data-ttu-id="a4012-276">La sezione relativa al tempo del thread viene assegnata durante la creazione e può essere modificata in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-276">The thread’s time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="a4012-277">Alla scadenza di un intervallo di tempo, tutti gli altri thread pronti con lo stesso livello di priorità hanno la possibilità di eseguire prima di eseguire di nuovo il thread con sezionamento del tempo.</span><span class="sxs-lookup"><span data-stu-id="a4012-277">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="a4012-278">Una sezione del tempo del thread aggiornata viene assegnata a un thread dopo la sospensione, cede, effettua una chiamata al servizio SMP di ThreadX che causa la precedenza o è TimeSliced.</span><span class="sxs-lookup"><span data-stu-id="a4012-278">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX SMP service call that causes preemption, or is itself timesliced.</span></span>

<span data-ttu-id="a4012-279">Quando un thread con sezionamento temporale viene interrotto, riprenderà prima di altri thread pronti con uguale priorità per il resto della relativa sezione di tempo.</span><span class="sxs-lookup"><span data-stu-id="a4012-279">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-280">L'uso del sezionamento del tempo comporta una lieve quantità di overhead del sistema.</span><span class="sxs-lookup"><span data-stu-id="a4012-280">Using time-slicing results in a slight amount of system overhead.</span></span> <span data-ttu-id="a4012-281">Poiché il sezionamento del tempo è utile solo nei casi in cui più thread condividono la stessa priorità, non è necessario assegnare un intervallo di tempo ai thread con una priorità univoca.</span><span class="sxs-lookup"><span data-stu-id="a4012-281">Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.</span></span>

### <a name="preemption"></a><span data-ttu-id="a4012-282">Precedenza</span><span class="sxs-lookup"><span data-stu-id="a4012-282">Preemption</span></span> 
<span data-ttu-id="a4012-283">La precedenza è il processo di interruzione temporanea di un thread in esecuzione a favore di un thread con priorità più alta.</span><span class="sxs-lookup"><span data-stu-id="a4012-283">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="a4012-284">Questo processo è invisibile al thread in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-284">This process is invisible to the executing thread.</span></span> <span data-ttu-id="a4012-285">Quando il thread con priorità più alta è terminato, il controllo viene trasferito di nuovo alla posizione esatta in cui è avvenuta la precedenza.</span><span class="sxs-lookup"><span data-stu-id="a4012-285">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span>

<span data-ttu-id="a4012-286">Si tratta di una funzionalità molto importante nei sistemi in tempo reale perché semplifica la risposta rapida a eventi importanti dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-286">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="a4012-287">Sebbene una funzionalità molto importante, la precedenza può anche costituire un'origine di diversi problemi, tra cui inedia, sovraccarico eccessivo e inversione con priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-287">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-threshold"></a><span data-ttu-id="a4012-288">™ Della soglia di precedenza</span><span class="sxs-lookup"><span data-stu-id="a4012-288">Preemption-Threshold™</span></span> 
<span data-ttu-id="a4012-289">Per semplificare alcuni dei problemi intrinseci di precedenza, ThreadX SMP fornisce una funzionalità univoca e avanzata denominata *precedenza-soglia*.</span><span class="sxs-lookup"><span data-stu-id="a4012-289">To ease some of the inherent problems of preemption, ThreadX SMP provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="a4012-290">Una soglia di precedenza consente a un thread di specificare un *limite* di priorità per la disabilitazione della precedenza.</span><span class="sxs-lookup"><span data-stu-id="a4012-290">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="a4012-291">I thread con priorità più elevata rispetto al limite massimo possono comunque essere interrotti, mentre quelli inferiori al limite massimo non sono consentiti per l'interruzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-291">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="a4012-292">Si supponga, ad esempio, che un thread con priorità 20 interagisca solo con un gruppo di thread con priorità compresa tra 15 e 20.</span><span class="sxs-lookup"><span data-stu-id="a4012-292">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="a4012-293">Durante le sezioni critiche, il thread della priorità 20 può impostare la soglia di precedenza su 15, impedendo in tal modo la precedenza da tutti i thread con cui interagisce.</span><span class="sxs-lookup"><span data-stu-id="a4012-293">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="a4012-294">Questo consente comunque ai thread molto importanti (priorità tra 0 e 14) di precedere questo thread durante la relativa elaborazione della sezione critica, che comporta un'elaborazione molto più reattiva.</span><span class="sxs-lookup"><span data-stu-id="a4012-294">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="a4012-295">Naturalmente, è ancora possibile per un thread disabilitare la precedenza impostando la relativa soglia di precedenza su 0.</span><span class="sxs-lookup"><span data-stu-id="a4012-295">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="a4012-296">Inoltre, la soglia di precedenza può essere modificata in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-296">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-297">Con la soglia di precedenza viene disabilitato il sezionamento del tempo per il thread specificato.</span><span class="sxs-lookup"><span data-stu-id="a4012-297">Using preemption-threshold disables time-slicing for the specified thread.</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="a4012-298">Ereditarietà priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-298">Priority Inheritance</span></span> 
<span data-ttu-id="a4012-299">ThreadX SMP supporta inoltre l'ereditarietà della priorità facoltativa nei servizi mutex descritti più avanti in questo capitolo.</span><span class="sxs-lookup"><span data-stu-id="a4012-299">ThreadX SMP also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="a4012-300">L'ereditarietà della priorità consente a un thread con priorità inferiore di assumere temporaneamente la priorità di un thread con priorità alta in attesa di un mutex di proprietà del thread con priorità inferiore.</span><span class="sxs-lookup"><span data-stu-id="a4012-300">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="a4012-301">Questa funzionalità consente all'applicazione di evitare l'inversione di priorità non deterministica eliminando la precedenza delle priorità del thread intermedio.</span><span class="sxs-lookup"><span data-stu-id="a4012-301">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="a4012-302">Naturalmente, è possibile usare la *soglia di precedenza* per ottenere un risultato simile.</span><span class="sxs-lookup"><span data-stu-id="a4012-302">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="a4012-303">Creazione di thread</span><span class="sxs-lookup"><span data-stu-id="a4012-303">Thread Creation</span></span> 
<span data-ttu-id="a4012-304">I thread dell'applicazione vengono creati durante l'inizializzazione o durante l'esecuzione di altri thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-304">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="a4012-305">Non esiste alcun limite al numero di thread che possono essere creati da un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-305">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="a4012-306">TX_THREAD blocchi di controllo thread</span><span class="sxs-lookup"><span data-stu-id="a4012-306">Thread Control Block TX_THREAD</span></span> 
<span data-ttu-id="a4012-307">Le caratteristiche di ogni thread sono contenute nel relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-307">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="a4012-308">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-308">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="a4012-309">Il blocco di controllo di un thread può trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendolo al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-309">A thread’s control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="a4012-310">Per individuare il blocco di controllo in altre aree, è necessario prestare maggiore attenzione, come per tutta la memoria allocata in modo dinamico.</span><span class="sxs-lookup"><span data-stu-id="a4012-310">Locating the control block in other areas requires a bit more care, just like all dynamically allocated memory.</span></span> <span data-ttu-id="a4012-311">Se un blocco di controllo viene allocato all'interno di una funzione C, la memoria associata è parte dello stack del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="a4012-311">If a control block is allocated within a C function, the memory associated with it is part of the calling thread’s stack.</span></span> <span data-ttu-id="a4012-312">In generale, evitare di usare l'archiviazione locale per i blocchi di controllo perché, dopo la restituzione della funzione, viene rilasciato tutto lo spazio dello stack della variabile locale, indipendentemente dal fatto che venga usato da un altro thread per un blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-312">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block!</span></span>

<span data-ttu-id="a4012-313">Nella maggior parte dei casi, l'applicazione è ignara del contenuto del blocco di controllo del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-313">In most cases, the application is oblivious to the contents of the thread’s control block.</span></span> <span data-ttu-id="a4012-314">Tuttavia, esistono alcune situazioni, soprattutto durante il debug, in cui è utile esaminare alcuni membri.</span><span class="sxs-lookup"><span data-stu-id="a4012-314">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="a4012-315">Di seguito sono riportati alcuni dei più utili membri del blocco di controllo:</span><span class="sxs-lookup"><span data-stu-id="a4012-315">The following are some of the more useful control block members:</span></span>

- <span data-ttu-id="a4012-316">**tx_thread_run_count** contiene un contatore del numero di volte in cui il thread è stato pianificato.</span><span class="sxs-lookup"><span data-stu-id="a4012-316">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="a4012-317">Un contatore crescente indica che è in corso la pianificazione e l'esecuzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-317">An increasing counter indicates the thread is being scheduled and executed.</span></span>

- <span data-ttu-id="a4012-318">**tx_thread_state** contiene lo stato del thread associato.</span><span class="sxs-lookup"><span data-stu-id="a4012-318">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="a4012-319">Di seguito sono elencati i possibili stati dei thread:</span><span class="sxs-lookup"><span data-stu-id="a4012-319">The following lists the possible thread states:</span></span>

    - <span data-ttu-id="a4012-320">TX_READY (0x00)</span><span class="sxs-lookup"><span data-stu-id="a4012-320">TX_READY(0x00)</span></span>
    - <span data-ttu-id="a4012-321">TX_COMPLETED (0x01)</span><span class="sxs-lookup"><span data-stu-id="a4012-321">TX_COMPLETED(0x01)</span></span>
    - <span data-ttu-id="a4012-322">TX_TERMINATED (0x02)</span><span class="sxs-lookup"><span data-stu-id="a4012-322">TX_TERMINATED(0x02)</span></span>
    - <span data-ttu-id="a4012-323">TX_SUSPENDED (0x03)</span><span class="sxs-lookup"><span data-stu-id="a4012-323">TX_SUSPENDED(0x03)</span></span>
    - <span data-ttu-id="a4012-324">TX_SLEEP (0x04)</span><span class="sxs-lookup"><span data-stu-id="a4012-324">TX_SLEEP(0x04)</span></span>
    - <span data-ttu-id="a4012-325">TX_QUEUE_SUSP (0x05)</span><span class="sxs-lookup"><span data-stu-id="a4012-325">TX_QUEUE_SUSP(0x05)</span></span>
    - <span data-ttu-id="a4012-326">TX_SEMAPHORE_SUSP (0x06)</span><span class="sxs-lookup"><span data-stu-id="a4012-326">TX_SEMAPHORE_SUSP(0x06)</span></span>
    - <span data-ttu-id="a4012-327">TX_EVENT_FLAG (0x07)</span><span class="sxs-lookup"><span data-stu-id="a4012-327">TX_EVENT_FLAG (0x07)</span></span>
    - <span data-ttu-id="a4012-328">TX_BLOCK_MEMORY (0x08)</span><span class="sxs-lookup"><span data-stu-id="a4012-328">TX_BLOCK_MEMORY(0x08)</span></span>
    - <span data-ttu-id="a4012-329">TX_BYTE_MEMORY (0x09)</span><span class="sxs-lookup"><span data-stu-id="a4012-329">TX_BYTE_MEMORY (0x09)</span></span>
    - <span data-ttu-id="a4012-330">TX_MUTEX_SUSP (0x0D)</span><span class="sxs-lookup"><span data-stu-id="a4012-330">TX_MUTEX_SUSP(0x0D)</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-331">Naturalmente, esistono molti altri campi interessanti nel blocco di controllo dei thread, tra cui il puntatore dello stack, il valore della sezione temporale, le priorità e così via. Gli utenti sono invitati a esaminare i membri del blocco di controllo, ma le modifiche sono rigorosamente proibite.</span><span class="sxs-lookup"><span data-stu-id="a4012-331">Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-332">Non esiste alcuna uguaglianza per lo stato "in esecuzione" indicato in precedenza in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="a4012-332">There is no equate for the “executing” state mentioned earlier in this section.</span></span> <span data-ttu-id="a4012-333">Non è necessario perché esiste solo un thread in esecuzione in un determinato momento.</span><span class="sxs-lookup"><span data-stu-id="a4012-333">It is not necessary because there is only one executing thread at a given time.</span></span> <span data-ttu-id="a4012-334">Anche lo stato di un thread in esecuzione è ***TX_READY***.</span><span class="sxs-lookup"><span data-stu-id="a4012-334">The state of an executing thread is also ***TX_READY***.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="a4012-335">Thread attualmente in esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-335">Currently Executing Thread</span></span> 
<span data-ttu-id="a4012-336">Come indicato in precedenza, è in esecuzione un solo thread in un determinato momento.</span><span class="sxs-lookup"><span data-stu-id="a4012-336">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="a4012-337">Esistono diversi modi per identificare il thread in esecuzione, a seconda del thread che sta effettuando la richiesta.</span><span class="sxs-lookup"><span data-stu-id="a4012-337">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>

<span data-ttu-id="a4012-338">Un segmento di programma può ottenere l'indirizzo del blocco di controllo del thread in esecuzione chiamando ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="a4012-338">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="a4012-339">Questa operazione è utile nelle parti condivise del codice dell'applicazione eseguite da più thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-339">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="a4012-340">Nelle sessioni di debug gli utenti possono esaminare la matrice del puntatore ThreadX SMP interna ***_tx_thread_current_ptr [core]***.</span><span class="sxs-lookup"><span data-stu-id="a4012-340">In debug sessions, users can examine the internal ThreadX SMP pointer array ***_tx_thread_current_ptr[core]***.</span></span> <span data-ttu-id="a4012-341">Contiene l'indirizzo del blocco di controllo del thread attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-341">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="a4012-342">Se questo puntatore è NULL, non è in esecuzione alcun thread dell'applicazione; ovvero, ThreadX SMP è in attesa nel ciclo di pianificazione affinché un thread diventi pronto.</span><span class="sxs-lookup"><span data-stu-id="a4012-342">If this pointer is NULL, no application thread is executing; i.e., ThreadX SMP is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="a4012-343">Area stack di thread</span><span class="sxs-lookup"><span data-stu-id="a4012-343">Thread Stack Area</span></span> 
<span data-ttu-id="a4012-344">Ogni thread deve avere un proprio stack per salvare il contesto dell'ultima esecuzione e l'utilizzo del compilatore.</span><span class="sxs-lookup"><span data-stu-id="a4012-344">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="a4012-345">La maggior parte dei compilatori C usa lo stack per eseguire chiamate di funzione e allocare temporaneamente le variabili locali.</span><span class="sxs-lookup"><span data-stu-id="a4012-345">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="a4012-346">La figura 5 nella pagina 61 Mostra lo stack di un thread tipico.</span><span class="sxs-lookup"><span data-stu-id="a4012-346">Figure 5 on page 61 shows a typical thread’s stack.</span></span>

![Area stack di thread](media/image8.png)

<span data-ttu-id="a4012-348">**FIGURA 5. Stack di thread tipico**</span><span class="sxs-lookup"><span data-stu-id="a4012-348">**FIGURE 5. Typical Thread Stack**</span></span>

<span data-ttu-id="a4012-349">Quando uno stack di thread si trova in memoria è all'interno dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-349">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="a4012-350">L'area dello stack viene specificata durante la creazione del thread e può trovarsi in qualsiasi punto dello spazio degli indirizzi della destinazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-350">The stack area is specified during thread creation and can be located anywhere in the target’s address space.</span></span> <span data-ttu-id="a4012-351">Si tratta di una funzionalità importante perché consente alle applicazioni di migliorare le prestazioni dei thread importanti inserendo lo stack in RAM ad alta velocità.</span><span class="sxs-lookup"><span data-stu-id="a4012-351">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="a4012-352">La dimensione di uno stack è una delle domande più frequenti sui thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-352">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="a4012-353">L'area dello stack di un thread deve essere sufficientemente grande da contenere la nidificazione della chiamata di funzione peggiore, l'allocazione delle variabili locali e il salvataggio dell'ultimo contesto di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-353">A thread’s stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="a4012-354">La dimensione minima dello stack, **TX_MINIMUM_STACK**, è definita da threadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-354">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX SMP.</span></span> <span data-ttu-id="a4012-355">Uno stack di queste dimensioni supporta il salvataggio del contesto di un thread e la quantità minima di chiamate di funzione e l'allocazione delle variabili locali.</span><span class="sxs-lookup"><span data-stu-id="a4012-355">A stack of this size supports saving a thread’s context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="a4012-356">Per la maggior parte dei thread, tuttavia, la dimensione minima dello stack è troppo piccola e l'utente deve verificare il requisito della dimensione worstcase esaminando la nidificazione delle chiamate di funzione e l'allocazione delle variabili locali.</span><span class="sxs-lookup"><span data-stu-id="a4012-356">For most threads, however, the minimum stack size is too small, and the user must ascertain the worstcase size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="a4012-357">Naturalmente, è sempre preferibile iniziare con un'area dello stack più ampia.</span><span class="sxs-lookup"><span data-stu-id="a4012-357">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="a4012-358">Quando l'applicazione viene sottoposta a debug, è possibile ottimizzare le dimensioni dello stack di thread se la memoria è limitata.</span><span class="sxs-lookup"><span data-stu-id="a4012-358">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="a4012-359">Un trucco preferito consiste nel preimpostare tutte le aree dello stack con un modello di dati facilmente identificabile, ad esempio (0xEFEF) prima della creazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-359">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="a4012-360">Dopo aver completato l'applicazione, è possibile esaminare le aree dello stack per verificare la quantità di stack effettivamente utilizzata individuando l'area dello stack in cui il modello di dati è ancora intatto.</span><span class="sxs-lookup"><span data-stu-id="a4012-360">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="a4012-361">Nella figura 6 viene illustrato un set di impostazioni dello stack da 0xEFEF dopo l'esecuzione completa del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-361">Figure 6 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-362">Per impostazione predefinita, ThreadX SMP Inizializza ogni byte di ogni stack di thread con un valore di 0xEF.</span><span class="sxs-lookup"><span data-stu-id="a4012-362">By default, ThreadX SMP initializes every byte of each thread stack with a value of 0xEF.</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="a4012-363">Problemi di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-363">Memory Pitfalls</span></span> 
<span data-ttu-id="a4012-364">I requisiti dello stack per i thread possono essere di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="a4012-364">The stack requirements for threads can be large.</span></span> <span data-ttu-id="a4012-365">Pertanto, è importante progettare l'applicazione in modo che disponga di un numero ragionevole di thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-365">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="a4012-366">Inoltre, è necessario prestare attenzione per evitare un utilizzo eccessivo dello stack nei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-366">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="a4012-367">Gli algoritmi ricorsivi e le strutture di dati locali di grandi dimensioni devono essere evitati.</span><span class="sxs-lookup"><span data-stu-id="a4012-367">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="a4012-368">Nella maggior parte dei casi, uno stack con overflow causa la danneggiamento della memoria adiacente da parte dell'esecuzione del thread, in genere</span><span class="sxs-lookup"><span data-stu-id="a4012-368">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually</span></span> 

![Problemi di memoria](media/image9.png)

<span data-ttu-id="a4012-370">**FIGURA 6. Imposta lo stack su 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="a4012-370">**FIGURE 6. Stack Preset to 0xEFEF**</span></span>

<span data-ttu-id="a4012-371">prima) area dello stack.</span><span class="sxs-lookup"><span data-stu-id="a4012-371">before) its stack area.</span></span> <span data-ttu-id="a4012-372">I risultati sono imprevedibili, ma la maggior parte delle volte comporta una modifica non naturale nel contatore del programma.</span><span class="sxs-lookup"><span data-stu-id="a4012-372">The results are unpredictable, but most often result in an un-natural change in the program counter.</span></span> <span data-ttu-id="a4012-373">Questa operazione viene spesso definita "passaggio alle erbacce".</span><span class="sxs-lookup"><span data-stu-id="a4012-373">This is often called “jumping into the weeds.”</span></span> <span data-ttu-id="a4012-374">Naturalmente, l'unico modo per evitare questo problema è garantire che tutti gli stack di thread siano sufficientemente grandi.</span><span class="sxs-lookup"><span data-stu-id="a4012-374">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="a4012-375">Controllo dello stack di run-time facoltativo</span><span class="sxs-lookup"><span data-stu-id="a4012-375">Optional Run-time Stack Checking</span></span>  
<span data-ttu-id="a4012-376">ThreadX SMP consente di controllare lo stack di ogni thread per eventuali danneggiamenti durante la fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-376">ThreadX SMP provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="a4012-377">Per impostazione predefinita, ThreadX SMP riempie ogni byte di stack di thread con un modello di dati 0xEF durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-377">By default, ThreadX SMP fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="a4012-378">Se l'applicazione compila la libreria SMP di ThreadX con \***TX_ENABLE_STACK_CHECKING** _ defined, threadX SMP analizzerà lo stack di ogni thread per danneggiarlo mentre viene sospeso o ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-378">If the application builds the ThreadX SMP library with \***TX_ENABLE_STACK_CHECKING** _ defined, ThreadX SMP will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="a4012-379">Se viene rilevato un danneggiamento dello stack, ThreadX SMP chiamerà la routine di gestione degli errori dello stack dell'applicazione come specificato dalla chiamata a _tx_thread_stack_error_notify \*.</span><span class="sxs-lookup"><span data-stu-id="a4012-379">If stack corruption is detected, ThreadX SMP will call the application's stack error handling routine as specified by the call to _tx_thread_stack_error_notify\*.</span></span> <span data-ttu-id="a4012-380">In caso contrario, se non è stato specificato alcun gestore di errori dello stack, ThreadX SMP chiamerà la routine *_tx_thread_stack_error_handler* interna.</span><span class="sxs-lookup"><span data-stu-id="a4012-380">Otherwise, if no stack error handler was specified, ThreadX SMP will call the internal *_tx_thread_stack_error_handler* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="a4012-381">Rientranza</span><span class="sxs-lookup"><span data-stu-id="a4012-381">Reentrancy</span></span> 
<span data-ttu-id="a4012-382">Una delle bellezze reali del multithreading è che la stessa funzione C può essere chiamata da più thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-382">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="a4012-383">Ciò garantisce grande potenza e contribuisce inoltre a ridurre lo spazio di codice.</span><span class="sxs-lookup"><span data-stu-id="a4012-383">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="a4012-384">Tuttavia, richiede che le funzioni C chiamate da più thread siano *rientranti*.</span><span class="sxs-lookup"><span data-stu-id="a4012-384">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="a4012-385">In sostanza, una funzione rientrante archivia l'indirizzo mittente del chiamante nello stack corrente e non si basa sulle variabili C globali o statiche impostate in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a4012-385">Basically, a reentrant function stores the caller’s return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="a4012-386">La maggior parte dei compilatori inserisce l'indirizzo mittente nello stack.</span><span class="sxs-lookup"><span data-stu-id="a4012-386">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="a4012-387">Di conseguenza, gli sviluppatori di applicazioni devono preoccuparsi solo dell'utilizzo di *Globals* e *static*.</span><span class="sxs-lookup"><span data-stu-id="a4012-387">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="a4012-388">Un esempio di funzione non rientrante è la funzione token di stringa "strtok" trovata nella libreria C standard.</span><span class="sxs-lookup"><span data-stu-id="a4012-388">An example of a non-reentrant function is the string token function “strtok” found in the standard C library.</span></span> <span data-ttu-id="a4012-389">Questa funzione memorizza il puntatore di stringa precedente nelle chiamate successive.</span><span class="sxs-lookup"><span data-stu-id="a4012-389">This function remembers the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="a4012-390">Questa operazione viene eseguita con un puntatore di stringa statico.</span><span class="sxs-lookup"><span data-stu-id="a4012-390">It does this with a static string pointer.</span></span> <span data-ttu-id="a4012-391">Se questa funzione viene chiamata da più thread, è molto probabile che restituisca un puntatore non valido.</span><span class="sxs-lookup"><span data-stu-id="a4012-391">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="a4012-392">Problemi relativi alla priorità del thread</span><span class="sxs-lookup"><span data-stu-id="a4012-392">Thread Priority Pitfalls</span></span> 
<span data-ttu-id="a4012-393">La selezione delle priorità dei thread è uno degli aspetti più importanti del multithreading.</span><span class="sxs-lookup"><span data-stu-id="a4012-393">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="a4012-394">Talvolta è molto difficile assegnare le priorità in base a una nozione percepita di importanza dei thread, anziché determinare cosa è esattamente necessario durante la fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-394">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="a4012-395">L'utilizzo improprio delle priorità dei thread può infame altri thread, creare inversione con priorità, ridurre la larghezza di banda di elaborazione e rendere difficile la comprensione del comportamento in fase di esecuzione dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-395">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application’s run-time behavior difficult to understand.</span></span>

<span data-ttu-id="a4012-396">Come indicato in precedenza, ThreadX SMP fornisce un algoritmo di pianificazione preemptive basato sulla priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-396">As mentioned before, ThreadX SMP provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="a4012-397">I thread con priorità inferiore non vengono eseguiti fino a quando non sono presenti thread con priorità più elevata pronti per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-397">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="a4012-398">Se un thread con priorità più alta è sempre pronto, i thread con priorità inferiore non vengono mai eseguiti.</span><span class="sxs-lookup"><span data-stu-id="a4012-398">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="a4012-399">Questa condizione è detta *inedia del thread*.</span><span class="sxs-lookup"><span data-stu-id="a4012-399">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="a4012-400">La maggior parte dei problemi di inedia dei thread viene rilevata all'inizio del debug e può essere risolta garantendo che i thread con priorità più alta non vengano</span><span class="sxs-lookup"><span data-stu-id="a4012-400">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don’t execute continuously.</span></span> <span data-ttu-id="a4012-401">In alternativa, è possibile aggiungere la logica all'applicazione che aumenta gradualmente la priorità dei thread affamati fino a quando non avranno la possibilità di eseguire.</span><span class="sxs-lookup"><span data-stu-id="a4012-401">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="a4012-402">Un altro trabocchetto associato alle priorità dei thread è l' *inversione della priorità*.</span><span class="sxs-lookup"><span data-stu-id="a4012-402">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="a4012-403">L'inversione della priorità avviene quando un thread con priorità più alta viene sospeso perché un thread con priorità inferiore ha una risorsa necessaria.</span><span class="sxs-lookup"><span data-stu-id="a4012-403">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="a4012-404">Naturalmente, in alcuni casi è necessario che due thread con priorità diversa condividano una risorsa comune.</span><span class="sxs-lookup"><span data-stu-id="a4012-404">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="a4012-405">Se questi thread sono gli unici attivi, il tempo di inversione della priorità è limitato dal tempo in cui il thread con priorità inferiore include la risorsa.</span><span class="sxs-lookup"><span data-stu-id="a4012-405">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="a4012-406">Questa condizione è deterministica e abbastanza normale.</span><span class="sxs-lookup"><span data-stu-id="a4012-406">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="a4012-407">Tuttavia, se i thread della priorità intermedia diventano attivi durante questa condizione di inversione della priorità, il tempo di inversione della priorità non è più deterministico e potrebbe causare un errore dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-407">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="a4012-408">Esistono principalmente tre metodi distinti per impedire l'inversione di priorità non deterministica in ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-408">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX SMP.</span></span> <span data-ttu-id="a4012-409">In primo luogo, le selezioni per la priorità dell'applicazione e il comportamento in fase di esecuzione possono essere progettate in modo da evitare il problema di inversione della priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-409">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="a4012-410">In secondo luogo, i thread con priorità più bassa possono utilizzare la *soglia di precedenza* per bloccare la precedenza dai thread intermedi mentre condividono risorse con thread con priorità più elevata.</span><span class="sxs-lookup"><span data-stu-id="a4012-410">Second, lower priority threads can utilize *preemption-threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="a4012-411">Infine, i thread che usano gli oggetti mutex ThreadX SMP per proteggere le risorse di sistema possono usare l' *ereditarietà della priorità* mutex facoltativa per eliminare l'inversione di priorità non deterministica.</span><span class="sxs-lookup"><span data-stu-id="a4012-411">Finally, threads using ThreadX SMP mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="a4012-412">Overhead priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-412">Priority Overhead</span></span> 
<span data-ttu-id="a4012-413">Uno dei modi più trascurati per ridurre l'overhead nel multithreading consiste nel ridurre il numero di cambi di contesto.</span><span class="sxs-lookup"><span data-stu-id="a4012-413">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="a4012-414">Come indicato in precedenza, un cambio di contesto si verifica quando l'esecuzione di un thread con priorità più alta è favorita rispetto a quella del thread in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-414">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="a4012-415">È opportuno ricordare che i thread con priorità più elevata possono diventare pronti a causa di eventi esterni (ad esempio, interrupt) e di chiamate al servizio eseguite dal thread in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-415">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="a4012-416">Per illustrare le priorità dei thread degli effetti sul sovraccarico del cambio di contesto, si supponga un ambiente a tre thread con thread denominati *Thread_1*, *Thread_2* e *Thread_3*.</span><span class="sxs-lookup"><span data-stu-id="a4012-416">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="a4012-417">Si supponga inoltre che tutti i thread siano in uno stato di sospensione in attesa di un messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-417">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="a4012-418">Quando thread_1 riceve un messaggio, lo inoltra immediatamente a thread_2.</span><span class="sxs-lookup"><span data-stu-id="a4012-418">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="a4012-419">Thread_2 quindi trasmette il messaggio al thread_3.</span><span class="sxs-lookup"><span data-stu-id="a4012-419">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="a4012-420">Thread_3 semplicemente Elimina il messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-420">Thread_3 just discards the message.</span></span> <span data-ttu-id="a4012-421">Dopo l'elaborazione del messaggio da parte di ogni thread, viene riattivato e rimane in attesa di un altro messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-421">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="a4012-422">L'elaborazione necessaria per eseguire questi tre thread varia notevolmente a seconda delle priorità.</span><span class="sxs-lookup"><span data-stu-id="a4012-422">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="a4012-423">Se tutti i thread hanno la stessa priorità, prima dell'esecuzione di ogni thread viene eseguito un singolo cambio di contesto.</span><span class="sxs-lookup"><span data-stu-id="a4012-423">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="a4012-424">Il cambio di contesto si verifica quando ogni thread viene sospeso in una coda di messaggi vuota.</span><span class="sxs-lookup"><span data-stu-id="a4012-424">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="a4012-425">Tuttavia, se thread_2 ha una priorità più elevata rispetto a thread_1 e thread_3 ha una priorità più elevata rispetto a thread_2, il numero di cambi di contesto raddoppia.</span><span class="sxs-lookup"><span data-stu-id="a4012-425">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="a4012-426">Questo è dovuto al fatto che un'altra opzione di contesto si verifica all'interno del servizio *tx_queue_send* quando rileva che un thread con priorità più alta è ora pronto.</span><span class="sxs-lookup"><span data-stu-id="a4012-426">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="a4012-427">Il meccanismo di soglia di precedenza SMP di ThreadX può evitare questi cambi di contesto aggiuntivi e consentire comunque le selezioni di priorità indicate in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a4012-427">The ThreadX SMP preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="a4012-428">Si tratta di una funzionalità importante perché consente numerose priorità dei thread durante la pianificazione, eliminando allo stesso tempo parte del contesto indesiderato che passa tra di essi durante l'esecuzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-428">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="a4012-429">Informazioni sulle prestazioni del thread in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-429">Run-time Thread Performance Information</span></span> 
<span data-ttu-id="a4012-430">ThreadX SMP fornisce informazioni facoltative sulle prestazioni del thread in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-430">ThreadX SMP provides optional run-time thread performance information.</span></span> <span data-ttu-id="a4012-431">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="a4012-431">If the ThreadX SMP library and application is built with ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="a4012-432">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-432">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-433">riprese di thread</span><span class="sxs-lookup"><span data-stu-id="a4012-433">thread resumptions</span></span>
- <span data-ttu-id="a4012-434">sospensioni di thread</span><span class="sxs-lookup"><span data-stu-id="a4012-434">thread suspensions</span></span>
- <span data-ttu-id="a4012-435">prelazioni delle chiamate al servizio</span><span class="sxs-lookup"><span data-stu-id="a4012-435">service call preemptions</span></span>
- <span data-ttu-id="a4012-436">interruzioni di interrupt</span><span class="sxs-lookup"><span data-stu-id="a4012-436">interrupt preemptions</span></span>
- <span data-ttu-id="a4012-437">inversioni di priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-437">priority inversions</span></span>
- <span data-ttu-id="a4012-438">sezioni temporali</span><span class="sxs-lookup"><span data-stu-id="a4012-438">time-slices</span></span>
- <span data-ttu-id="a4012-439">cede</span><span class="sxs-lookup"><span data-stu-id="a4012-439">relinquishes</span></span>
- <span data-ttu-id="a4012-440">Timeout thread</span><span class="sxs-lookup"><span data-stu-id="a4012-440">thread timeouts</span></span>
- <span data-ttu-id="a4012-441">interruzioni di sospensione</span><span class="sxs-lookup"><span data-stu-id="a4012-441">suspension aborts</span></span>
- <span data-ttu-id="a4012-442">il sistema inattivo restituisce</span><span class="sxs-lookup"><span data-stu-id="a4012-442">idle system returns</span></span>
- <span data-ttu-id="a4012-443">Restituisce il sistema non inattivo</span><span class="sxs-lookup"><span data-stu-id="a4012-443">non-idle system returns</span></span>

<span data-ttu-id="a4012-444">Numero totale per ogni thread:</span><span class="sxs-lookup"><span data-stu-id="a4012-444">Total number for each thread:</span></span>

- <span data-ttu-id="a4012-445">delle riprese</span><span class="sxs-lookup"><span data-stu-id="a4012-445">resumptions</span></span>
- <span data-ttu-id="a4012-446">sospensioni</span><span class="sxs-lookup"><span data-stu-id="a4012-446">suspensions</span></span>
- <span data-ttu-id="a4012-447">prelazioni delle chiamate al servizio</span><span class="sxs-lookup"><span data-stu-id="a4012-447">service call preemptions</span></span>
- <span data-ttu-id="a4012-448">interruzioni di interrupt</span><span class="sxs-lookup"><span data-stu-id="a4012-448">interrupt preemptions</span></span>
- <span data-ttu-id="a4012-449">inversioni di priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-449">priority inversions</span></span>
- <span data-ttu-id="a4012-450">sezioni temporali</span><span class="sxs-lookup"><span data-stu-id="a4012-450">time-slices</span></span>
- <span data-ttu-id="a4012-451">il thread cede</span><span class="sxs-lookup"><span data-stu-id="a4012-451">thread relinquishes</span></span>
- <span data-ttu-id="a4012-452">Timeout thread</span><span class="sxs-lookup"><span data-stu-id="a4012-452">thread timeouts</span></span>
- <span data-ttu-id="a4012-453">interruzioni di sospensione</span><span class="sxs-lookup"><span data-stu-id="a4012-453">suspension aborts</span></span>

<span data-ttu-id="a4012-454">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_thread_performance_info_get* e *tx_thread_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-454">This information is available at run-time through the services *tx_thread_performance_info_get* and *tx_thread_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-455">Le informazioni sulle prestazioni dei thread sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-455">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-456">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-456">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-457">Ad esempio, un numero relativamente elevato di prelazioni della chiamata al servizio potrebbe indicare che la priorità e/o la soglia di precedenza del thread è troppo bassa.</span><span class="sxs-lookup"><span data-stu-id="a4012-457">For example, a relatively high number of service call preemptions might suggest the thread’s priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="a4012-458">Inoltre, un numero relativamente basso di ritorni di sistema inattivi potrebbe indicare che i thread con priorità inferiore non sono sufficientemente sospesi.</span><span class="sxs-lookup"><span data-stu-id="a4012-458">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="a4012-459">Problemi di debug</span><span class="sxs-lookup"><span data-stu-id="a4012-459">Debugging Pitfalls</span></span> 
<span data-ttu-id="a4012-460">Il debug di applicazioni multithread è un po' più difficile perché lo stesso codice programma può essere eseguito da più thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-460">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="a4012-461">In questi casi, un punto di rottura da solo potrebbe non essere sufficiente.</span><span class="sxs-lookup"><span data-stu-id="a4012-461">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="a4012-462">Il debugger deve anche visualizzare la matrice del puntatore del thread corrente ***_tx_thread_current_ptr [core]*** usando un punto di interruzione condizionale per verificare se il thread chiamante è quello di cui eseguire il debug.</span><span class="sxs-lookup"><span data-stu-id="a4012-462">The debugger must also view the current thread pointer array ***_tx_thread_current_ptr[core]*** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="a4012-463">Molti di questi vengono gestiti nei pacchetti di supporto per il multithreading offerti attraverso diversi fornitori di strumenti di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-463">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="a4012-464">Grazie alla sua semplice progettazione, l'integrazione di ThreadX SMP con diversi strumenti di sviluppo è relativamente semplice.</span><span class="sxs-lookup"><span data-stu-id="a4012-464">Because of its simple design, integrating ThreadX SMP with different development tools is relatively easy.</span></span>

<span data-ttu-id="a4012-465">La dimensione dello stack è sempre un argomento di debug importante nel multithreading.</span><span class="sxs-lookup"><span data-stu-id="a4012-465">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="a4012-466">Ogni volta che viene osservato un comportamento inspiegabile, in genere è opportuno aumentare le dimensioni dello stack per tutti i thread, in particolare le dimensioni dello stack dell'ultimo thread da eseguire.</span><span class="sxs-lookup"><span data-stu-id="a4012-466">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-467">È inoltre consigliabile compilare la libreria SMP di ThreadX con TX_ENABLE_STACK_CHECKING definito.</span><span class="sxs-lookup"><span data-stu-id="a4012-467">It is also a good idea to build the ThreadX SMP library with TX_ENABLE_STACK_CHECKING defined.</span></span> <span data-ttu-id="a4012-468">Questo consente di isolare i problemi di danneggiamento dello stack nel minor tempo possibile nell'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-468">This will help isolate stack corruption problems as early in the processing as possible!</span></span>

## <a name="message-queues"></a><span data-ttu-id="a4012-469">Code di messaggi</span><span class="sxs-lookup"><span data-stu-id="a4012-469">Message Queues</span></span>

<span data-ttu-id="a4012-470">Le code di messaggi sono il mezzo principale per la comunicazione tra thread in ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-470">Message queues are the primary means of interthread communication in ThreadX SMP.</span></span> <span data-ttu-id="a4012-471">Uno o più messaggi possono risiedere in una coda di messaggi.</span><span class="sxs-lookup"><span data-stu-id="a4012-471">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="a4012-472">Una coda di messaggi che include un singolo messaggio è comunemente denominata *cassetta postale*.</span><span class="sxs-lookup"><span data-stu-id="a4012-472">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="a4012-473">I messaggi vengono copiati in una coda *tx_queue_send* e vengono copiati da una coda di *tx_queue_receive*.</span><span class="sxs-lookup"><span data-stu-id="a4012-473">Messages are copied to a queue by *tx_queue_send* and are copied from a queue by *tx_queue_receive*.</span></span> <span data-ttu-id="a4012-474">L'unica eccezione è rappresentata dal momento in cui un thread viene sospeso in attesa di un messaggio in una coda vuota.</span><span class="sxs-lookup"><span data-stu-id="a4012-474">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="a4012-475">In questo caso, il messaggio successivo inviato alla coda viene inserito direttamente nell'area di destinazione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-475">In this case, the next message sent to the queue is placed directly into the thread’s destination area.</span></span>

<span data-ttu-id="a4012-476">Ogni coda di messaggi è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-476">Each message queue is a public resource.</span></span> <span data-ttu-id="a4012-477">ThreadX SMP non impone vincoli sulla modalità di utilizzo delle code di messaggi.</span><span class="sxs-lookup"><span data-stu-id="a4012-477">ThreadX SMP places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="a4012-478">Creazione di code di messaggi</span><span class="sxs-lookup"><span data-stu-id="a4012-478">Creating Message Queues</span></span> 
<span data-ttu-id="a4012-479">Le code di messaggi vengono create durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-479">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-480">Non esiste alcun limite al numero di code di messaggi in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-480">There is no limit on the number of message queues in an application.</span></span> 

### <a name="message-size"></a><span data-ttu-id="a4012-481">Dimensioni del messaggio</span><span class="sxs-lookup"><span data-stu-id="a4012-481">Message Size</span></span> 
<span data-ttu-id="a4012-482">Ogni coda di messaggi supporta un numero di messaggi fixedsized.</span><span class="sxs-lookup"><span data-stu-id="a4012-482">Each message queue supports a number of fixedsized messages.</span></span> <span data-ttu-id="a4012-483">Le dimensioni dei messaggi disponibili sono comprese tra 1 e 16 32 bit.</span><span class="sxs-lookup"><span data-stu-id="a4012-483">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="a4012-484">La dimensione del messaggio viene specificata quando viene creata la coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-484">The message size is specified when the queue is created.</span></span> 

<span data-ttu-id="a4012-485">I messaggi dell'applicazione con dimensioni maggiori di 16 parole devono essere passati dal puntatore.</span><span class="sxs-lookup"><span data-stu-id="a4012-485">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="a4012-486">Questa operazione viene eseguita tramite la creazione di una coda con una dimensione del messaggio di 1 parola (sufficiente per mantenere un puntatore) e quindi l'invio e la ricezione di puntatori ai messaggi anziché dell'intero messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-486">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="a4012-487">Capacità coda messaggi</span><span class="sxs-lookup"><span data-stu-id="a4012-487">Message Queue Capacity</span></span> 
<span data-ttu-id="a4012-488">Il numero di messaggi che una coda può mantenere è una funzione delle dimensioni del messaggio e le dimensioni dell'area di memoria fornita durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-488">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="a4012-489">La capacità totale dei messaggi della coda viene calcolata dividendo il numero di byte in ogni messaggio nel numero totale di byte nell'area di memoria specificata.</span><span class="sxs-lookup"><span data-stu-id="a4012-489">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="a4012-490">Se, ad esempio, viene creata una coda di messaggi che supporta una dimensione del messaggio di Word a 1 32 bit (4 byte) con un'area di memoria di 100 byte, la relativa capacità è di 25 messaggi.</span><span class="sxs-lookup"><span data-stu-id="a4012-490">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="a4012-491">Area memoria coda</span><span class="sxs-lookup"><span data-stu-id="a4012-491">Queue Memory Area</span></span> 
<span data-ttu-id="a4012-492">Come indicato in precedenza, l'area di memoria per il buffering dei messaggi viene specificata durante la creazione della coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-492">As mentioned before, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="a4012-493">Analogamente ad altre aree di memoria in ThreadX SMP, può trovarsi in qualsiasi punto dello spazio degli indirizzi della destinazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-493">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="a4012-494">Si tratta di una funzionalità importante perché garantisce una notevole flessibilità all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-494">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="a4012-495">Ad esempio, un'applicazione potrebbe individuare l'area di memoria di una coda importante in RAM ad alta velocità per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a4012-495">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="a4012-496">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-496">Thread Suspension</span></span>  
<span data-ttu-id="a4012-497">I thread dell'applicazione possono essere sospesi durante il tentativo di inviare o ricevere un messaggio da una coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-497">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="a4012-498">In genere, la sospensione dei thread prevede l'attesa di un messaggio da una coda vuota.</span><span class="sxs-lookup"><span data-stu-id="a4012-498">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="a4012-499">Tuttavia, è anche possibile che un thread sospenda il tentativo di inviare un messaggio a una coda completa.</span><span class="sxs-lookup"><span data-stu-id="a4012-499">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span> 

<span data-ttu-id="a4012-500">Una volta risolta la condizione per la sospensione, il servizio richiesto viene completato e il thread in attesa viene ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-500">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="a4012-501">Se più thread sono sospesi nella stessa coda, vengono ripresi nell'ordine in cui sono stati sospesi (FIFO).</span><span class="sxs-lookup"><span data-stu-id="a4012-501">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="a4012-502">Tuttavia, la ripresa della priorità è possibile anche se l'applicazione chiama ***tx_queue_prioritize*** prima del servizio di accodamento che solleva la sospensione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-502">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="a4012-503">Il servizio accoda priorità posiziona il thread con priorità più alta all'inizio dell'elenco di sospensioni, lasciando tutti gli altri thread sospesi nello stesso ordine FIFO.</span><span class="sxs-lookup"><span data-stu-id="a4012-503">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="a4012-504">I timeout sono disponibili anche per tutte le sospensioni della coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-504">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="a4012-505">In sostanza, un timeout specifica il numero massimo di cicli del timer che il thread resterà sospeso.</span><span class="sxs-lookup"><span data-stu-id="a4012-505">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="a4012-506">Se si verifica un timeout, il thread viene ripreso e il servizio restituisce con il codice di errore appropriato.</span><span class="sxs-lookup"><span data-stu-id="a4012-506">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="a4012-507">Notifica di invio della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-507">Queue Send Notification</span></span>  
<span data-ttu-id="a4012-508">Alcune applicazioni potrebbero risultare vantaggioso ricevere notifiche ogni volta che un messaggio viene inserito in una coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-508">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="a4012-509">ThreadX SMP offre questa possibilità tramite il servizio *tx_queue_send_notify* .</span><span class="sxs-lookup"><span data-stu-id="a4012-509">ThreadX SMP provides this ability through the *tx_queue_send_notify* service.</span></span> <span data-ttu-id="a4012-510">Questo servizio registra la funzione di notifica dell'applicazione fornita con la coda specificata.</span><span class="sxs-lookup"><span data-stu-id="a4012-510">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="a4012-511">ThreadX SMP richiamerà successivamente questa funzione di notifica dell'applicazione ogni volta che un messaggio viene inviato alla coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-511">ThreadX SMP will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="a4012-512">L'elaborazione esatta all'interno della funzione di notifica dell'applicazione è determinata dall'applicazione; Tuttavia, in genere è costituito dalla ripresa del thread appropriato per l'elaborazione del nuovo messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-512">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chaining"></a><span data-ttu-id="a4012-513">™ Di concatenamento degli eventi di Accodamento</span><span class="sxs-lookup"><span data-stu-id="a4012-513">Queue Event-chaining™</span></span>  
<span data-ttu-id="a4012-514">Le funzionalità di notifica in SMP di ThreadX possono essere usate per concatenare diversi eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-514">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="a4012-515">Questa operazione è in genere utile quando un singolo thread deve elaborare più eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-515">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="a4012-516">Si supponga, ad esempio, che un singolo thread sia responsabile dell'elaborazione dei messaggi da cinque code diverse ed è necessario sospenderlo anche quando non sono disponibili messaggi.</span><span class="sxs-lookup"><span data-stu-id="a4012-516">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="a4012-517">Questa operazione viene eseguita facilmente registrando una funzione di notifica dell'applicazione per ogni coda e introducendo un semaforo di conteggio aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-517">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="a4012-518">In particolare, la funzione di notifica dell'applicazione esegue un *tx_semaphore_put* ogni volta che viene chiamato (il conteggio dei semafori rappresenta il numero totale di messaggi in tutte e cinque le code).</span><span class="sxs-lookup"><span data-stu-id="a4012-518">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="a4012-519">Il thread di elaborazione sospende in questo semaforo tramite il servizio *tx_semaphore_get* .</span><span class="sxs-lookup"><span data-stu-id="a4012-519">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="a4012-520">Quando il semaforo è disponibile (in questo caso, quando è disponibile un messaggio), il thread di elaborazione viene ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-520">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="a4012-521">Interroga quindi ogni coda per un messaggio, elabora il messaggio trovato ed esegue un'altra *tx_semaphore_get* per attendere il messaggio successivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-521">It then interrogates each queue for a message, processes the found message, and performs another *tx_semaphore_get* to wait for the next message.</span></span> <span data-ttu-id="a4012-522">Eseguire questa operazione senza concatenamento di eventi è piuttosto difficile e probabilmente richiederebbe più thread e/o codice dell'applicazione aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-522">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="a4012-523">In generale, il *concatenamento degli eventi* comporta un minor numero di thread, minore overhead e requisiti di RAM inferiori.</span><span class="sxs-lookup"><span data-stu-id="a4012-523">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="a4012-524">Fornisce inoltre un meccanismo estremamente flessibile per gestire i requisiti di sincronizzazione di sistemi più complessi.</span><span class="sxs-lookup"><span data-stu-id="a4012-524">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="a4012-525">Informazioni sulle prestazioni della coda di runtime</span><span class="sxs-lookup"><span data-stu-id="a4012-525">Run-time Queue Performance Information</span></span>  
<span data-ttu-id="a4012-526">ThreadX SMP fornisce informazioni sulle prestazioni della coda di runtime facoltative.</span><span class="sxs-lookup"><span data-stu-id="a4012-526">ThreadX SMP provides optional run-time queue performance information.</span></span> <span data-ttu-id="a4012-527">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="a4012-527">If the ThreadX SMP library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="a4012-528">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-528">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-529">messaggi inviati</span><span class="sxs-lookup"><span data-stu-id="a4012-529">messages sent</span></span>
- <span data-ttu-id="a4012-530">messaggi ricevuti</span><span class="sxs-lookup"><span data-stu-id="a4012-530">messages received</span></span>
- <span data-ttu-id="a4012-531">sospendere le sospensioni vuote</span><span class="sxs-lookup"><span data-stu-id="a4012-531">queue empty suspensions</span></span>
- <span data-ttu-id="a4012-532">sospensione completa della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-532">queue full suspensions</span></span>
- <span data-ttu-id="a4012-533">totale ritorni errore coda (sospensione non specifica di)</span><span class="sxs-lookup"><span data-stu-id="a4012-533">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="a4012-534">timeout della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-534">queue timeouts</span></span>

<span data-ttu-id="a4012-535">Numero totale per ogni coda:</span><span class="sxs-lookup"><span data-stu-id="a4012-535">Total number for each queue:</span></span>

- <span data-ttu-id="a4012-536">messaggi inviati</span><span class="sxs-lookup"><span data-stu-id="a4012-536">messages sent</span></span>
- <span data-ttu-id="a4012-537">messaggi ricevuti</span><span class="sxs-lookup"><span data-stu-id="a4012-537">messages received</span></span>
- <span data-ttu-id="a4012-538">sospendere le sospensioni vuote</span><span class="sxs-lookup"><span data-stu-id="a4012-538">queue empty suspensions</span></span>
- <span data-ttu-id="a4012-539">sospensione completa della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-539">queue full suspensions</span></span>
- <span data-ttu-id="a4012-540">totale ritorni errore coda (sospensione non specifica di)</span><span class="sxs-lookup"><span data-stu-id="a4012-540">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="a4012-541">timeout della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-541">queue timeouts</span></span>

<span data-ttu-id="a4012-542">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_queue_performance_info_get* e *tx_queue_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-542">This information is available at run-time through the services *tx_queue_performance_info_get* and *tx_queue_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-543">Le informazioni sulle prestazioni della coda sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-543">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-544">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-544">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-545">Ad esempio, un numero relativamente elevato di "sospensioni complete della coda" suggerisce un aumento delle dimensioni della coda può risultare vantaggioso.</span><span class="sxs-lookup"><span data-stu-id="a4012-545">For example, a relatively high number of “queue full suspensions” suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="a4012-546">TX_QUEUE blocchi di controllo della coda</span><span class="sxs-lookup"><span data-stu-id="a4012-546">Queue Control Block TX_QUEUE</span></span> 
<span data-ttu-id="a4012-547">Le caratteristiche di ogni coda di messaggi sono disponibili nel relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-547">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="a4012-548">Contiene informazioni interessanti, ad esempio il numero di messaggi nella coda.</span><span class="sxs-lookup"><span data-stu-id="a4012-548">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="a4012-549">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-549">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="a4012-550">I blocchi di controllo della coda di messaggi possono anche trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendola al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-550">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="a4012-551">Insidia destinazione messaggio</span><span class="sxs-lookup"><span data-stu-id="a4012-551">Message Destination Pitfall</span></span>  
<span data-ttu-id="a4012-552">Come indicato in precedenza, i messaggi vengono copiati tra l'area della coda e le aree dati dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-552">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="a4012-553">È importante assicurarsi che la destinazione di un messaggio ricevuto sia sufficientemente grande da poter conservare l'intero messaggio.</span><span class="sxs-lookup"><span data-stu-id="a4012-553">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="a4012-554">In caso contrario, la memoria che segue la destinazione del messaggio sarà probabilmente danneggiata.</span><span class="sxs-lookup"><span data-stu-id="a4012-554">If not, the memory following the message destination will likely be corrupted.</span></span> 

> [!WARNING]
> <span data-ttu-id="a4012-555">Questa operazione è particolarmente letale quando una destinazione di messaggio troppo piccola è nello stack, nulla come il danneggiamento dell'indirizzo di ritorno di una funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-555">This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="a4012-556">Conteggio dei semafori</span><span class="sxs-lookup"><span data-stu-id="a4012-556">Counting Semaphores</span></span>

<span data-ttu-id="a4012-557">ThreadX SMP fornisce semaforo di conteggio a 32 bit che variano in valore compreso tra 0 e 4.294.967.295.</span><span class="sxs-lookup"><span data-stu-id="a4012-557">ThreadX SMP provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="a4012-558">Per il conteggio dei semafori sono disponibili due operazioni: *tx_semaphore_get* e *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="a4012-558">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="a4012-559">L'operazione Get riduce il semaforo di uno.</span><span class="sxs-lookup"><span data-stu-id="a4012-559">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="a4012-560">Se il semaforo è 0, l'operazione get ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a4012-560">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="a4012-561">L'inverso dell'operazione get è l'operazione Put.</span><span class="sxs-lookup"><span data-stu-id="a4012-561">The inverse of the get operation is the put operation.</span></span> <span data-ttu-id="a4012-562">Il semaforo aumenta di uno.</span><span class="sxs-lookup"><span data-stu-id="a4012-562">It increases the semaphore by one.</span></span>

<span data-ttu-id="a4012-563">Ogni semaforo di conteggio è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-563">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="a4012-564">ThreadX SMP non impone vincoli sul conteggio dei semafori usati.</span><span class="sxs-lookup"><span data-stu-id="a4012-564">ThreadX SMP places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="a4012-565">Il conteggio dei semafori viene in genere usato per l' *esclusione reciproca*.</span><span class="sxs-lookup"><span data-stu-id="a4012-565">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="a4012-566">Tuttavia, il conteggio dei semafori può essere usato anche come metodo per la notifica degli eventi.</span><span class="sxs-lookup"><span data-stu-id="a4012-566">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="a4012-567">Esclusione reciproca</span><span class="sxs-lookup"><span data-stu-id="a4012-567">Mutual Exclusion</span></span> 
<span data-ttu-id="a4012-568">L'esclusione reciproca riguarda il controllo dell'accesso dei thread a determinate aree dell'applicazione, denominate anche *sezioni critiche* o *risorse dell'applicazione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-568">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="a4012-569">Quando viene usato per l'esclusione reciproca, il "conteggio corrente" di un semaforo rappresenta il numero totale di thread a cui è consentito l'accesso.</span><span class="sxs-lookup"><span data-stu-id="a4012-569">When used for mutual exclusion, the “current count” of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="a4012-570">Nella maggior parte dei casi, il conteggio dei semafori usati per l'esclusione reciproca avrà un valore iniziale pari a 1, ovvero un solo thread può accedere alla risorsa associata alla volta.</span><span class="sxs-lookup"><span data-stu-id="a4012-570">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="a4012-571">Il conteggio dei semafori che hanno solo valori 0 o 1 viene comunemente chiamato *semaforo binario*.</span><span class="sxs-lookup"><span data-stu-id="a4012-571">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-572">Se viene usato un semaforo binario, l'utente deve impedire allo stesso thread di eseguire un'operazione get su un semaforo di cui è già proprietario.</span><span class="sxs-lookup"><span data-stu-id="a4012-572">If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns.</span></span> <span data-ttu-id="a4012-573">Un secondo Get non ha avuto esito positivo e potrebbe causare una sospensione indefinita del thread chiamante e l'indisponibilità permanente della risorsa.</span><span class="sxs-lookup"><span data-stu-id="a4012-573">A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.</span></span>

### <a name="event-notification"></a><span data-ttu-id="a4012-574">Notifica dell'evento</span><span class="sxs-lookup"><span data-stu-id="a4012-574">Event Notification</span></span> 
<span data-ttu-id="a4012-575">È anche possibile usare il conteggio dei semafori come notifica degli eventi, in modo da producer-consumer.</span><span class="sxs-lookup"><span data-stu-id="a4012-575">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="a4012-576">Il consumer tenta di ottenere il semaforo di conteggio mentre il produttore aumenta il semaforo ogni volta che è disponibile qualcosa.</span><span class="sxs-lookup"><span data-stu-id="a4012-576">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="a4012-577">Questi semafori hanno in genere un valore iniziale pari a 0 e non aumentano fino a quando il produttore non ha qualcosa di pronto per l'utente.</span><span class="sxs-lookup"><span data-stu-id="a4012-577">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="a4012-578">I semafori usati per la notifica degli eventi possono anche trarre vantaggio dall'uso della chiamata al servizio *tx_semaphore_ceiling_put* .</span><span class="sxs-lookup"><span data-stu-id="a4012-578">Semaphores used for event notification may also benefit from use of the *tx_semaphore_ceiling_put* service call.</span></span> <span data-ttu-id="a4012-579">Questo servizio garantisce che il numero di semafori non superi mai il valore specificato nella chiamata.</span><span class="sxs-lookup"><span data-stu-id="a4012-579">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="a4012-580">Creazione di semafori di conteggio</span><span class="sxs-lookup"><span data-stu-id="a4012-580">Creating Counting Semaphores</span></span> 
<span data-ttu-id="a4012-581">Il conteggio dei semafori viene creato durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-581">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-582">Il numero iniziale del semaforo viene specificato durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-582">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="a4012-583">Non esiste alcun limite al numero di semafori in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-583">There is no limit on the number of counting semaphores in an application.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="a4012-584">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-584">Thread Suspension</span></span>  
<span data-ttu-id="a4012-585">I thread dell'applicazione possono essere sospesi durante il tentativo di eseguire un'operazione get su un semaforo con un conteggio corrente pari a 0.</span><span class="sxs-lookup"><span data-stu-id="a4012-585">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span> 

<span data-ttu-id="a4012-586">Dopo l'esecuzione di un'operazione Put, viene eseguita l'operazione Get del thread sospeso e il thread viene ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-586">After a put operation is performed, the suspended thread’s get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="a4012-587">Se più thread vengono sospesi nello stesso semaforo di conteggio, vengono ripresi nello stesso ordine in cui sono stati sospesi (FIFO).</span><span class="sxs-lookup"><span data-stu-id="a4012-587">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="a4012-588">Tuttavia, la ripresa della priorità è possibile anche se l'applicazione chiama ***tx_semaphore_prioritize*** prima della chiamata di put del semaforo che solleva la sospensione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-588">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="a4012-589">Il servizio semaforo priorità posiziona il thread con priorità più alta all'inizio dell'elenco di sospensioni, lasciando tutti gli altri thread sospesi nello stesso ordine FIFO.</span><span class="sxs-lookup"><span data-stu-id="a4012-589">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="a4012-590">Notifica put semaforo</span><span class="sxs-lookup"><span data-stu-id="a4012-590">Semaphore Put Notification</span></span> 
<span data-ttu-id="a4012-591">Alcune applicazioni potrebbero risultare vantaggioso ricevere notifiche ogni volta che viene inserito un semaforo.</span><span class="sxs-lookup"><span data-stu-id="a4012-591">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="a4012-592">ThreadX SMP offre questa possibilità tramite il servizio *tx_semaphore_put_notify* .</span><span class="sxs-lookup"><span data-stu-id="a4012-592">ThreadX SMP provides this ability through the *tx_semaphore_put_notify* service.</span></span> <span data-ttu-id="a4012-593">Questo servizio registra la funzione di notifica dell'applicazione fornita con il semaforo specificato.</span><span class="sxs-lookup"><span data-stu-id="a4012-593">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="a4012-594">ThreadX SMP richiamerà successivamente questa funzione di notifica dell'applicazione ogni volta che viene inserito il semaforo.</span><span class="sxs-lookup"><span data-stu-id="a4012-594">ThreadX SMP will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="a4012-595">L'elaborazione esatta all'interno della funzione di notifica dell'applicazione è determinata dall'applicazione; Tuttavia, in genere è costituito dalla ripresa del thread appropriato per l'elaborazione del nuovo evento Semaphore put.</span><span class="sxs-lookup"><span data-stu-id="a4012-595">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-eventchaining"></a><span data-ttu-id="a4012-596">™ Semaforo Eventchaining</span><span class="sxs-lookup"><span data-stu-id="a4012-596">Semaphore Eventchaining™</span></span> 
<span data-ttu-id="a4012-597">Le funzionalità di notifica in SMP di ThreadX possono essere usate per concatenare diversi eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-597">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="a4012-598">Questa operazione è in genere utile quando un singolo thread deve elaborare più eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-598">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="a4012-599">Ad esempio, anziché avere thread separati sospesi per un messaggio della coda, i flag di evento e un semaforo, l'applicazione può registrare una routine di notifica per ogni oggetto.</span><span class="sxs-lookup"><span data-stu-id="a4012-599">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="a4012-600">Quando viene richiamato, la routine di notifica dell'applicazione può riprendere un singolo thread, che può interrogare ogni oggetto per trovare ed elaborare il nuovo evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-600">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="a4012-601">In generale, il *concatenamento degli eventi* comporta un minor numero di thread, minore overhead e requisiti di RAM inferiori.</span><span class="sxs-lookup"><span data-stu-id="a4012-601">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="a4012-602">Fornisce inoltre un meccanismo estremamente flessibile per gestire i requisiti di sincronizzazione di sistemi più complessi.</span><span class="sxs-lookup"><span data-stu-id="a4012-602">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="a4012-603">Informazioni sulle prestazioni del semaforo in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-603">Run-time Semaphore Performance Information</span></span> 
<span data-ttu-id="a4012-604">ThreadX SMP fornisce informazioni sulle prestazioni del semaforo di run-time facoltative.</span><span class="sxs-lookup"><span data-stu-id="a4012-604">ThreadX SMP provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="a4012-605">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-605">If the ThreadX SMP library and application is built with ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="a4012-606">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-606">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-607">semaforo inserito</span><span class="sxs-lookup"><span data-stu-id="a4012-607">semaphore puts</span></span>
- <span data-ttu-id="a4012-608">semaforo ottenuto</span><span class="sxs-lookup"><span data-stu-id="a4012-608">semaphore gets</span></span>
- <span data-ttu-id="a4012-609">sospensioni semaforo Get</span><span class="sxs-lookup"><span data-stu-id="a4012-609">semaphore get suspensions</span></span>
- <span data-ttu-id="a4012-610">Timeout get semaforo</span><span class="sxs-lookup"><span data-stu-id="a4012-610">semaphore get timeouts</span></span>

<span data-ttu-id="a4012-611">Numero totale per ogni semaforo:</span><span class="sxs-lookup"><span data-stu-id="a4012-611">Total number for each semaphore:</span></span>

- <span data-ttu-id="a4012-612">semaforo inserito</span><span class="sxs-lookup"><span data-stu-id="a4012-612">semaphore puts</span></span>
- <span data-ttu-id="a4012-613">semaforo ottenuto</span><span class="sxs-lookup"><span data-stu-id="a4012-613">semaphore gets</span></span>
- <span data-ttu-id="a4012-614">sospensioni semaforo Get</span><span class="sxs-lookup"><span data-stu-id="a4012-614">semaphore get suspensions</span></span>
- <span data-ttu-id="a4012-615">Timeout get semaforo</span><span class="sxs-lookup"><span data-stu-id="a4012-615">semaphore get timeouts</span></span>

<span data-ttu-id="a4012-616">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_semaphore_performance_info_get* e *tx_semaphore_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-616">This information is available at run-time through the services *tx_semaphore_performance_info_get* and *tx_semaphore_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-617">Le informazioni sulle prestazioni del semaforo sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-617">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-618">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-618">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-619">Ad esempio, un numero relativamente elevato di "Timeout get Semaphore" potrebbe suggerire che altri thread mantengono risorse troppo lunghe.</span><span class="sxs-lookup"><span data-stu-id="a4012-619">For example, a relatively high number of “semaphore get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="a4012-620">TX_SEMAPHORE del blocco di controllo Semaphore</span><span class="sxs-lookup"><span data-stu-id="a4012-620">Semaphore Control Block TX_SEMAPHORE</span></span> 
<span data-ttu-id="a4012-621">Le caratteristiche di ogni semaforo di conteggio si trovano nel blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-621">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="a4012-622">Contiene informazioni come il numero corrente di semafori.</span><span class="sxs-lookup"><span data-stu-id="a4012-622">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="a4012-623">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-623">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="a4012-624">I blocchi di controllo Semaphore possono trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendolo al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-624">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="deadly-embrace"></a><span data-ttu-id="a4012-625">Abbraccio mortale</span><span class="sxs-lookup"><span data-stu-id="a4012-625">Deadly Embrace</span></span> 
<span data-ttu-id="a4012-626">Uno degli ostacoli più interessanti e pericolosi associati ai semafori usati per l'esclusione reciproca è il *mortale* abbandono.</span><span class="sxs-lookup"><span data-stu-id="a4012-626">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="a4012-627">Un abbraccio mortale, o un *deadlock*, è una condizione in cui due o più thread vengono sospesi a tempo indefinito durante il tentativo di ottenere i semafori già posseduti l'uno dall'altro.</span><span class="sxs-lookup"><span data-stu-id="a4012-627">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="a4012-628">Questa condizione è illustrata in modo ottimale da un due thread, un esempio di semaforo.</span><span class="sxs-lookup"><span data-stu-id="a4012-628">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="a4012-629">Si supponga che il primo thread sia proprietario del primo semaforo e che il secondo thread appartenga al secondo semaforo.</span><span class="sxs-lookup"><span data-stu-id="a4012-629">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="a4012-630">Se il primo thread tenta di ottenere il secondo semaforo e allo stesso tempo il secondo thread tenta di ottenere il primo semaforo, entrambi i thread entrano in una condizione di deadlock.</span><span class="sxs-lookup"><span data-stu-id="a4012-630">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="a4012-631">Inoltre, se questi thread rimarranno sospesi per sempre, anche le risorse associate vengono bloccate per sempre.</span><span class="sxs-lookup"><span data-stu-id="a4012-631">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="a4012-632">Questo esempio è illustrato nella figura 7 della pagina 78.</span><span class="sxs-lookup"><span data-stu-id="a4012-632">Figure 7 on page 78 illustrates this example.</span></span>

![Abbraccio mortale](media/image10.png)

<span data-ttu-id="a4012-634">**FIGURA 7. Esempio di thread sospesi**</span><span class="sxs-lookup"><span data-stu-id="a4012-634">**FIGURE 7. Example of Suspended Threads**</span></span>

<span data-ttu-id="a4012-635">Per i sistemi in tempo reale, gli abbracci letali possono essere evitati inserendo alcune restrizioni sul modo in cui i thread ottengono i semafori.</span><span class="sxs-lookup"><span data-stu-id="a4012-635">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="a4012-636">I thread possono avere un solo semaforo alla volta.</span><span class="sxs-lookup"><span data-stu-id="a4012-636">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="a4012-637">In alternativa, i thread possono essere proprietari di più semafori se li raccolgono nello stesso ordine.</span><span class="sxs-lookup"><span data-stu-id="a4012-637">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="a4012-638">Nell'esempio precedente, se il primo e il secondo thread ottengono il primo e il secondo semaforo nell'ordine, l'abbraccio mortale viene impedito.</span><span class="sxs-lookup"><span data-stu-id="a4012-638">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-639">È anche possibile usare il timeout di sospensione associato all'operazione get per il ripristino da un abbraccio mortale.</span><span class="sxs-lookup"><span data-stu-id="a4012-639">It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="a4012-640">Inversione priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-640">Priority Inversion</span></span> 
<span data-ttu-id="a4012-641">Un altro trabocchetto associato ai semafori di esclusione reciproca è la priorità Inversion.</span><span class="sxs-lookup"><span data-stu-id="a4012-641">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="a4012-642">Questo argomento viene discusso più completamente in "problemi relativi alla priorità del thread" nella pagina 64.</span><span class="sxs-lookup"><span data-stu-id="a4012-642">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span>

<span data-ttu-id="a4012-643">Il problema di base è dovuto a una situazione in cui un thread con priorità più bassa ha un semaforo che richiede un thread con priorità più elevata.</span><span class="sxs-lookup"><span data-stu-id="a4012-643">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="a4012-644">Si tratta di un comportamento normale.</span><span class="sxs-lookup"><span data-stu-id="a4012-644">This in itself is normal.</span></span> <span data-ttu-id="a4012-645">Tuttavia, i thread con le priorità tra di essi possono causare l'inversione della priorità per l'ultimo periodo di tempo non deterministico.</span><span class="sxs-lookup"><span data-stu-id="a4012-645">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="a4012-646">Questo può essere gestito tramite un'attenta selezione delle priorità dei thread, usando la soglia di precedenza e aumentando temporaneamente la priorità del thread che possiede la risorsa a quello del thread con priorità alta.</span><span class="sxs-lookup"><span data-stu-id="a4012-646">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="a4012-647">Mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-647">Mutexes</span></span>

<span data-ttu-id="a4012-648">Oltre ai semafori, ThreadX SMP fornisce anche un oggetto mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-648">In addition to semaphores, ThreadX SMP also provides a mutex object.</span></span> <span data-ttu-id="a4012-649">Un mutex è fondamentalmente un semaforo binario, il che significa che un solo thread può essere proprietario di un mutex alla volta.</span><span class="sxs-lookup"><span data-stu-id="a4012-649">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="a4012-650">Inoltre, lo stesso thread può eseguire un'operazione mutex Get riuscita su un mutex di proprietà più volte, 4.294.967.295 come Exact.</span><span class="sxs-lookup"><span data-stu-id="a4012-650">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="a4012-651">Nell'oggetto mutex sono presenti due operazioni: \***tx_mutex_get** _ e _ *_tx_mutex_put_* \*.</span><span class="sxs-lookup"><span data-stu-id="a4012-651">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="a4012-652">L'operazione get ottiene un mutex non di proprietà di un altro thread, mentre l'operazione Put rilascia un mutex ottenuto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a4012-652">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="a4012-653">Affinché un thread rilasci un mutex, il numero di operazioni Put deve essere uguale al numero di operazioni get precedenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-653">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="a4012-654">Ogni mutex è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-654">Each mutex is a public resource.</span></span> <span data-ttu-id="a4012-655">ThreadX SMP non impone vincoli per la modalità di utilizzo di mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-655">ThreadX SMP places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="a4012-656">I mutex ThreadX vengono usati esclusivamente per l' *esclusione reciproca*.</span><span class="sxs-lookup"><span data-stu-id="a4012-656">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="a4012-657">Diversamente dal conteggio dei semafori, i mutex non sono usati come metodo per la notifica degli eventi.</span><span class="sxs-lookup"><span data-stu-id="a4012-657">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="a4012-658">Esclusione reciproca mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-658">Mutex Mutual Exclusion</span></span> 
<span data-ttu-id="a4012-659">Analogamente a quanto descritto nella sezione Counting Semaphore, l'esclusione reciproca riguarda il controllo dell'accesso dei thread a determinate aree dell'applicazione, denominate anche *sezioni critiche* o *risorse dell'applicazione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-659">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="a4012-660">Se disponibile, un mutex ThreadX SMP avrà un numero di proprietà pari a 0.</span><span class="sxs-lookup"><span data-stu-id="a4012-660">When available, a ThreadX SMP mutex will have an ownership count of 0.</span></span> <span data-ttu-id="a4012-661">Dopo che il mutex è stato ottenuto da un thread, il numero di proprietà viene incrementato una volta per ogni operazione Get riuscita eseguita sul mutex e decrementa per ogni operazione Put riuscita.</span><span class="sxs-lookup"><span data-stu-id="a4012-661">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="a4012-662">Creazione di mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-662">Creating Mutexes</span></span> 
<span data-ttu-id="a4012-663">I mutex ThreadX SMP vengono creati durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-663">ThreadX SMP mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-664">La condizione iniziale di un mutex è sempre "disponibile".</span><span class="sxs-lookup"><span data-stu-id="a4012-664">The initial condition of a mutex is always “available.”</span></span> <span data-ttu-id="a4012-665">È possibile creare anche un mutex con l' *ereditarietà prioritaria* selezionata.</span><span class="sxs-lookup"><span data-stu-id="a4012-665">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="a4012-666">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-666">Thread Suspension</span></span> 
<span data-ttu-id="a4012-667">I thread dell'applicazione possono essere sospesi durante il tentativo di eseguire un'operazione get su un mutex già di proprietà di un altro thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-667">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="a4012-668">Quando il thread proprietario esegue lo stesso numero di operazioni Put, viene eseguita l'operazione Get del thread sospeso, assegnando la proprietà del mutex e il thread viene ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-668">After the same number of put operations are performed by the owning thread, the suspended thread’s get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="a4012-669">Se più thread vengono sospesi nello stesso mutex, vengono ripresi nello stesso ordine in cui sono stati sospesi (FIFO).</span><span class="sxs-lookup"><span data-stu-id="a4012-669">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="a4012-670">Tuttavia, la ripresa della priorità viene eseguita automaticamente se l'ereditarietà della priorità mutex è stata selezionata durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-670">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="a4012-671">La ripresa della priorità è inoltre possibile se l'applicazione chiama ***tx_mutex_prioritize*** prima della chiamata put mutex che solleva la sospensione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-671">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="a4012-672">Il servizio di assegnazione delle priorità di mutex posiziona il thread con priorità più elevata all'inizio dell'elenco di sospensioni, lasciando tutti gli altri thread sospesi nello stesso ordine FIFO.</span><span class="sxs-lookup"><span data-stu-id="a4012-672">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="a4012-673">Informazioni sulle prestazioni del mutex in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-673">Run-time Mutex Performance Information</span></span> 
<span data-ttu-id="a4012-674">ThreadX SMP fornisce informazioni sulle prestazioni di mutex in fase di esecuzione facoltative.</span><span class="sxs-lookup"><span data-stu-id="a4012-674">ThreadX SMP provides optional run-time mutex performance information.</span></span> <span data-ttu-id="a4012-675">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-675">If the ThreadX SMP library and application is built with ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="a4012-676">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-676">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-677">mutex put</span><span class="sxs-lookup"><span data-stu-id="a4012-677">mutex puts</span></span>
- <span data-ttu-id="a4012-678">mutex ottiene</span><span class="sxs-lookup"><span data-stu-id="a4012-678">mutex gets</span></span>
- <span data-ttu-id="a4012-679">sospensioni mutex Get</span><span class="sxs-lookup"><span data-stu-id="a4012-679">mutex get suspensions</span></span>
- <span data-ttu-id="a4012-680">Timeout get mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-680">mutex get timeouts</span></span>
- <span data-ttu-id="a4012-681">inversioni di priorità mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-681">mutex priority inversions</span></span>
- <span data-ttu-id="a4012-682">ereditarietà priorità mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-682">mutex priority inheritances</span></span>

<span data-ttu-id="a4012-683">Numero totale per ogni mutex:</span><span class="sxs-lookup"><span data-stu-id="a4012-683">Total number for each mutex:</span></span>

- <span data-ttu-id="a4012-684">mutex put</span><span class="sxs-lookup"><span data-stu-id="a4012-684">mutex puts</span></span>
- <span data-ttu-id="a4012-685">mutex ottiene</span><span class="sxs-lookup"><span data-stu-id="a4012-685">mutex gets</span></span>
- <span data-ttu-id="a4012-686">sospensioni mutex Get</span><span class="sxs-lookup"><span data-stu-id="a4012-686">mutex get suspensions</span></span>
- <span data-ttu-id="a4012-687">Timeout get mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-687">mutex get timeouts</span></span>
- <span data-ttu-id="a4012-688">inversioni di priorità mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-688">mutex priority inversions</span></span>
- <span data-ttu-id="a4012-689">ereditarietà priorità mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-689">mutex priority inheritances</span></span>

<span data-ttu-id="a4012-690">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_mutex_performance_info_get* e *tx_mutex_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-690">This information is available at run-time through the services *tx_mutex_performance_info_get* and *tx_mutex_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-691">Le informazioni sulle prestazioni di mutex sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-691">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-692">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-692">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-693">Ad esempio, un numero relativamente elevato di "Timeout get mutex" potrebbe suggerire che altri thread mantengono risorse troppo lunghe.</span><span class="sxs-lookup"><span data-stu-id="a4012-693">For example, a relatively high number of “mutex get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="a4012-694">TX_MUTEX del blocco di controllo mutex</span><span class="sxs-lookup"><span data-stu-id="a4012-694">Mutex Control Block TX_MUTEX</span></span> 
<span data-ttu-id="a4012-695">Le caratteristiche di ogni mutex sono disponibili nel relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-695">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="a4012-696">Contiene informazioni come il conteggio di proprietà Mutex corrente insieme al puntatore del thread proprietario del mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-696">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="a4012-697">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-697">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="a4012-698">I blocchi di controllo mutex possono trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendolo al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-698">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="a4012-699">Abbraccio mortale</span><span class="sxs-lookup"><span data-stu-id="a4012-699">Deadly Embrace</span></span>  
<span data-ttu-id="a4012-700">Uno degli errori più interessanti e pericolosi associati alla proprietà di mutex è l' *abbraccio mortale*.</span><span class="sxs-lookup"><span data-stu-id="a4012-700">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="a4012-701">Un abbraccio mortale, o un *deadlock*, è una condizione in cui due o più thread vengono sospesi a tempo indefinito durante il tentativo di ottenere un mutex già di proprietà degli altri thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-701">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="a4012-702">La discussione sull' *abbraccio mortale* e sui relativi rimedi trovati nella pagina 77 è completamente valida anche per l'oggetto mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-702">The discussion of *deadly embrace* and its remedies found on page 77 is completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="a4012-703">Inversione priorità</span><span class="sxs-lookup"><span data-stu-id="a4012-703">Priority Inversion</span></span> 
<span data-ttu-id="a4012-704">Come indicato in precedenza, un grave problema associato all'esclusione reciproca è la priorità Inversion.</span><span class="sxs-lookup"><span data-stu-id="a4012-704">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="a4012-705">Questo argomento viene discusso più completamente in "problemi relativi alla priorità del thread" nella pagina 64.</span><span class="sxs-lookup"><span data-stu-id="a4012-705">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span> 

<span data-ttu-id="a4012-706">Il problema di base è dovuto a una situazione in cui un thread con priorità più bassa ha un semaforo che richiede un thread con priorità più elevata.</span><span class="sxs-lookup"><span data-stu-id="a4012-706">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="a4012-707">Si tratta di un comportamento normale.</span><span class="sxs-lookup"><span data-stu-id="a4012-707">This in itself is normal.</span></span> <span data-ttu-id="a4012-708">Tuttavia, i thread con le priorità tra di essi possono causare l'inversione della priorità per l'ultimo periodo di tempo non deterministico.</span><span class="sxs-lookup"><span data-stu-id="a4012-708">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="a4012-709">A differenza dei semafori descritti in precedenza, l'oggetto mutex ThreadX SMP ha un' *ereditarietà prioritaria* facoltativa.</span><span class="sxs-lookup"><span data-stu-id="a4012-709">Unlike semaphores discussed previously, the ThreadX SMP mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="a4012-710">La priorità di base dell'ereditarietà è che un thread con priorità inferiore ha la priorità generata temporaneamente alla priorità di un thread con priorità alta che desidera lo stesso mutex di proprietà del thread con priorità inferiore.</span><span class="sxs-lookup"><span data-stu-id="a4012-710">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="a4012-711">Quando il thread con priorità più bassa rilascia il mutex, viene ripristinata la priorità originale e al thread con priorità superiore viene assegnata la proprietà del mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-711">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="a4012-712">Questa funzionalità Elimina l'inversione di priorità non deterministica deselezionando la quantità di inversione fino al momento in cui il thread con priorità inferiore include il mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-712">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="a4012-713">Naturalmente, le tecniche descritte in precedenza in questo capitolo per gestire l'inversione di priorità non deterministica sono valide anche per i mutex.</span><span class="sxs-lookup"><span data-stu-id="a4012-713">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="a4012-714">Flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-714">Event Flags</span></span>

<span data-ttu-id="a4012-715">I flag di evento forniscono uno strumento potente per la sincronizzazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-715">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="a4012-716">Ogni flag di evento è rappresentato da un solo bit.</span><span class="sxs-lookup"><span data-stu-id="a4012-716">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="a4012-717">I flag di evento sono disposti in gruppi di 32.</span><span class="sxs-lookup"><span data-stu-id="a4012-717">Event flags are arranged in groups of 32.</span></span>

<span data-ttu-id="a4012-718">I thread possono operare su tutti i flag di evento 32 in un gruppo nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="a4012-718">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="a4012-719">Gli eventi vengono impostati dal *tx_event_flags_set* e vengono recuperati da *tx_event_flags_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-719">Events are set by *tx_event_flags_set* and are retrieved by *tx_event_flags_get*.</span></span>

<span data-ttu-id="a4012-720">L'impostazione dei flag di evento viene eseguita con un'operazione AND/OR logica tra i flag di evento correnti e i nuovi flag di evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-720">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="a4012-721">Il tipo di operazione logica (AND o OR) viene specificato nella chiamata *tx_event_flags_set* .</span><span class="sxs-lookup"><span data-stu-id="a4012-721">The type of logical operation (either an AND or OR) is specified in the *tx_event_flags_set* call.</span></span>

<span data-ttu-id="a4012-722">Sono disponibili opzioni logiche simili per il recupero dei flag di evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-722">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="a4012-723">Una richiesta GET può specificare che tutti i flag di evento specificati sono obbligatori (AND logico).</span><span class="sxs-lookup"><span data-stu-id="a4012-723">A get request can specify that all specified event flags are required (a logical AND).</span></span> <span data-ttu-id="a4012-724">In alternativa, una richiesta GET può specificare che uno dei flag evento specificati soddisferà la richiesta (un OR logico).</span><span class="sxs-lookup"><span data-stu-id="a4012-724">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="a4012-725">Il tipo di operazione logica associata al recupero dei flag di evento è specificato nella chiamata *tx_event_flags_get* .</span><span class="sxs-lookup"><span data-stu-id="a4012-725">The type of logical operation associated with event flags retrieval is specified in the *tx_event_flags_get* call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-726">I flag di evento che soddisfano una richiesta GET vengono utilizzati, ovvero impostati su zero, se **TX_OR_CLEAR** o **TX_AND_CLEAR** sono specificati dalla richiesta.</span><span class="sxs-lookup"><span data-stu-id="a4012-726">Event flags that satisfy a get request are consumed, i.e., set to zero, if **TX_OR_CLEAR** or **TX_AND_CLEAR** are specified by the request.</span></span>

<span data-ttu-id="a4012-727">Ogni gruppo di flag di evento è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-727">Each event flags group is a public resource.</span></span> <span data-ttu-id="a4012-728">ThreadX SMP non impone vincoli sulla modalità di utilizzo di gruppi di flag di evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-728">ThreadX SMP places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="a4012-729">Creazione di gruppi di flag di evento</span><span class="sxs-lookup"><span data-stu-id="a4012-729">Creating Event Flags Groups</span></span>
<span data-ttu-id="a4012-730">I gruppi di flag di evento vengono creati durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-730">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-731">Al momento della creazione, tutti i flag di evento nel gruppo vengono impostati su zero.</span><span class="sxs-lookup"><span data-stu-id="a4012-731">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="a4012-732">Non esiste alcun limite al numero di gruppi di flag di evento in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-732">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="a4012-733">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-733">Thread Suspension</span></span> 
<span data-ttu-id="a4012-734">I thread dell'applicazione possono essere sospesi durante il tentativo di ottenere qualsiasi combinazione logica di flag evento da un gruppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-734">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="a4012-735">Dopo l'impostazione di un flag di evento, vengono esaminate le richieste Get di tutti i thread sospesi.</span><span class="sxs-lookup"><span data-stu-id="a4012-735">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="a4012-736">Vengono ripresi tutti i thread che ora hanno i flag di evento richiesti.</span><span class="sxs-lookup"><span data-stu-id="a4012-736">All the threads that now have the required event flags are resumed.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-737">Tutti i thread sospesi in un gruppo di flag di evento vengono esaminati quando vengono impostati i flag evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-737">All suspended threads on an event flags group are reviewed when its event flags are set.</span></span> <span data-ttu-id="a4012-738">Questo, ovviamente, introduce un sovraccarico aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-738">This, of course, introduces additional overhead.</span></span> <span data-ttu-id="a4012-739">È pertanto consigliabile limitare il numero di thread che usano lo stesso gruppo di flag di evento a un numero ragionevole.</span><span class="sxs-lookup"><span data-stu-id="a4012-739">Therefore, it is good practice to limit the number of threads using the same event flags group to a reasonable number.</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="a4012-740">Notifica set di flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-740">Event Flags Set Notification</span></span> 
<span data-ttu-id="a4012-741">Alcune applicazioni potrebbero risultare vantaggioso ricevere una notifica ogni volta che viene impostato un flag di evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-741">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="a4012-742">ThreadX SMP offre questa possibilità tramite il servizio *tx_event_flags_set_notify* .</span><span class="sxs-lookup"><span data-stu-id="a4012-742">ThreadX SMP provides this ability through the *tx_event_flags_set_notify* service.</span></span> <span data-ttu-id="a4012-743">Questo servizio registra la funzione di notifica dell'applicazione fornita con il gruppo di flag di evento specificato.</span><span class="sxs-lookup"><span data-stu-id="a4012-743">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="a4012-744">ThreadX SMP richiamerà successivamente questa funzione di notifica dell'applicazione ogni volta che viene impostato un flag di evento nel gruppo.</span><span class="sxs-lookup"><span data-stu-id="a4012-744">ThreadX SMP will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="a4012-745">L'elaborazione esatta all'interno della funzione di notifica dell'applicazione è determinata dall'applicazione, ma in genere è costituita dalla ripresa del thread appropriato per l'elaborazione del nuovo flag di evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-745">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span> 

### <a name="event-flags-event-chaining"></a><span data-ttu-id="a4012-746">Flag evento-concatenamento eventi™</span><span class="sxs-lookup"><span data-stu-id="a4012-746">Event Flags Event-chaining™</span></span> 
<span data-ttu-id="a4012-747">Le funzionalità di notifica in SMP di ThreadX possono essere usate per "concatenare" vari eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-747">The notification capabilities in ThreadX SMP can be used to “chain” various synchronization events together.</span></span> <span data-ttu-id="a4012-748">Questa operazione è in genere utile quando un singolo thread deve elaborare più eventi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-748">This is typically useful when a single thread must process multiple synchronization events.</span></span> 

<span data-ttu-id="a4012-749">Ad esempio, anziché avere thread separati sospesi per un messaggio della coda, i flag di evento e un semaforo, l'applicazione può registrare una routine di notifica per ogni oggetto.</span><span class="sxs-lookup"><span data-stu-id="a4012-749">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="a4012-750">Quando viene richiamato, la routine di notifica dell'applicazione può riprendere un singolo thread, che può interrogare ogni oggetto per trovare ed elaborare il nuovo evento.</span><span class="sxs-lookup"><span data-stu-id="a4012-750">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span> 

<span data-ttu-id="a4012-751">In generale, il *concatenamento degli eventi* comporta un minor numero di thread, minore overhead e requisiti di RAM inferiori.</span><span class="sxs-lookup"><span data-stu-id="a4012-751">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="a4012-752">Fornisce inoltre un meccanismo estremamente flessibile per gestire i requisiti di sincronizzazione di sistemi più complessi.</span><span class="sxs-lookup"><span data-stu-id="a4012-752">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span> 

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="a4012-753">Informazioni sulle prestazioni di flag di runtime</span><span class="sxs-lookup"><span data-stu-id="a4012-753">Run-time Event Flags Performance Information</span></span> 
<span data-ttu-id="a4012-754">ThreadX SMP fornisce informazioni sulle prestazioni di flag di runtime facoltativi.</span><span class="sxs-lookup"><span data-stu-id="a4012-754">ThreadX SMP provides optional run-time event flags performance information.</span></span> <span data-ttu-id="a4012-755">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-755">If the ThreadX SMP library and application is built with ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="a4012-756">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-756">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-757">set di flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-757">event flags sets</span></span>
- <span data-ttu-id="a4012-758">Flag evento ottenuti</span><span class="sxs-lookup"><span data-stu-id="a4012-758">event flags gets</span></span>
- <span data-ttu-id="a4012-759">i flag evento ottengono sospensioni</span><span class="sxs-lookup"><span data-stu-id="a4012-759">event flags get suspensions</span></span>
- <span data-ttu-id="a4012-760">timeout di Get dei flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-760">event flags get timeouts</span></span>

<span data-ttu-id="a4012-761">Numero totale per ogni gruppo di flag di evento:</span><span class="sxs-lookup"><span data-stu-id="a4012-761">Total number for each event flags group:</span></span>

- <span data-ttu-id="a4012-762">set di flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-762">event flags sets</span></span>
- <span data-ttu-id="a4012-763">Flag evento ottenuti</span><span class="sxs-lookup"><span data-stu-id="a4012-763">event flags gets</span></span>
- <span data-ttu-id="a4012-764">i flag evento ottengono sospensioni</span><span class="sxs-lookup"><span data-stu-id="a4012-764">event flags get suspensions</span></span>
- <span data-ttu-id="a4012-765">timeout di Get dei flag evento</span><span class="sxs-lookup"><span data-stu-id="a4012-765">event flags get timeouts</span></span>

<span data-ttu-id="a4012-766">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_event_flags_performance_info_get* e *tx_event_flags_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-766">This information is available at run-time through the services *tx_event_flags_performance_info_get* and *tx_event_flags_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-767">Le informazioni sulle prestazioni dei flag di evento sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-767">Event Flags performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-768">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-768">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-769">Ad esempio, un numero relativamente elevato di timeout nel servizio *tx_event_flags_get* potrebbe indicare che il timeout di sospensione dei flag di evento è troppo breve.</span><span class="sxs-lookup"><span data-stu-id="a4012-769">For example, a relatively high number of timeouts on the *tx_event_flags_get* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="a4012-770">Blocco di controllo gruppo flag di evento TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="a4012-770">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>
<span data-ttu-id="a4012-771">Le caratteristiche di ogni gruppo di flag di evento sono disponibili nel relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-771">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="a4012-772">Contiene informazioni quali le impostazioni dei flag di evento correnti e il numero di thread sospesi per gli eventi.</span><span class="sxs-lookup"><span data-stu-id="a4012-772">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="a4012-773">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-773">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="a4012-774">I blocchi di controllo del gruppo di eventi possono trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendola al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-774">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="memory-block-pools"></a><span data-ttu-id="a4012-775">Pool di blocchi di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-775">Memory Block Pools</span></span>  

<span data-ttu-id="a4012-776">L'allocazione della memoria in modo rapido e deterministico è sempre un problema in applicazioni in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-776">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="a4012-777">Tenendo presente questo aspetto, ThreadX SMP fornisce la possibilità di creare e gestire più pool di blocchi di memoria di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="a4012-777">With this in mind, ThreadX SMP provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="a4012-778">Poiché i pool di blocchi di memoria sono costituiti da blocchi di dimensioni fisse, non si verificano mai problemi di frammentazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-778">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="a4012-779">Naturalmente, la frammentazione causa comportamenti intrinsecamente non deterministici.</span><span class="sxs-lookup"><span data-stu-id="a4012-779">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="a4012-780">Inoltre, il tempo necessario per allocare e liberare un blocco di memoria di dimensioni fisse è paragonabile a quello della semplice manipolazione di elenchi collegati.</span><span class="sxs-lookup"><span data-stu-id="a4012-780">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="a4012-781">Inoltre, l'allocazione e la deallocazione dei blocchi di memoria vengono eseguite all'inizio dell'elenco disponibile.</span><span class="sxs-lookup"><span data-stu-id="a4012-781">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="a4012-782">Questa operazione fornisce l'elaborazione dell'elenco collegato più veloce possibile e potrebbe contribuire a tenere il blocco di memoria effettivo nella cache.</span><span class="sxs-lookup"><span data-stu-id="a4012-782">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="a4012-783">La mancanza di flessibilità è lo svantaggio principale dei pool di memoria a dimensione fissa.</span><span class="sxs-lookup"><span data-stu-id="a4012-783">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="a4012-784">Le dimensioni del blocco di un pool devono essere sufficienti per gestire i requisiti di memoria del caso peggiori degli utenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-784">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="a4012-785">Naturalmente, la memoria può essere sprecata se vengono apportate molte richieste di memoria di dimensioni diverse allo stesso pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-785">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="a4012-786">Una possibile soluzione consiste nel creare diversi pool di blocchi di memoria diversi che contengono blocchi di memoria di dimensioni diverse.</span><span class="sxs-lookup"><span data-stu-id="a4012-786">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="a4012-787">Ogni pool di blocchi di memoria è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-787">Each memory block pool is a public resource.</span></span> <span data-ttu-id="a4012-788">ThreadX SMP non impone vincoli per la modalità di utilizzo del pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-788">ThreadX SMP places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="a4012-789">Creazione di pool di blocchi di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-789">Creating Memory Block Pools</span></span>  
<span data-ttu-id="a4012-790">I pool di blocchi di memoria vengono creati durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-790">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-791">Non esiste alcun limite al numero di pool di blocchi di memoria in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-791">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="a4012-792">Dimensioni blocco di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-792">Memory Block Size</span></span>  
<span data-ttu-id="a4012-793">Come indicato in precedenza, i pool di blocchi di memoria contengono un numero di blocchi di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="a4012-793">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="a4012-794">Le dimensioni del blocco, in byte, vengono specificate durante la creazione del pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-794">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-795">ThreadX SMP aggiunge una piccola quantità di overhead, ovvero la dimensione di un puntatore C, a ogni blocco di memoria nel pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-795">ThreadX SMP adds a small amount of overhead— the size of a C pointer—to each memory block in the pool.</span></span> <span data-ttu-id="a4012-796">Inoltre, ThreadX SMP potrebbe dover riempire le dimensioni del blocco per evitare l'inizio di ogni blocco di memoria nell'allineamento appropriato.</span><span class="sxs-lookup"><span data-stu-id="a4012-796">In addition, ThreadX SMP might have to pad the block size to keep the beginning of each memory block on proper alignment.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="a4012-797">Capacità pool</span><span class="sxs-lookup"><span data-stu-id="a4012-797">Pool Capacity</span></span> 
<span data-ttu-id="a4012-798">Il numero di blocchi di memoria in un pool è una funzione delle dimensioni del blocco e il numero totale di byte nell'area di memoria fornita durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-798">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="a4012-799">La capacità di un pool viene calcolata dividendo le dimensioni del blocco (inclusa la spaziatura interna e i byte di overhead del puntatore) nel numero totale di byte nell'area di memoria specificata.</span><span class="sxs-lookup"><span data-stu-id="a4012-799">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="a4012-800">Area di memoria del pool</span><span class="sxs-lookup"><span data-stu-id="a4012-800">Pool’s Memory Area</span></span> 
<span data-ttu-id="a4012-801">Come indicato in precedenza, l'area di memoria per il pool di blocchi viene specificata durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-801">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="a4012-802">Analogamente ad altre aree di memoria in ThreadX SMP, può trovarsi in qualsiasi punto dello spazio degli indirizzi della destinazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-802">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="a4012-803">Si tratta di una funzionalità importante grazie alla notevole flessibilità offerta.</span><span class="sxs-lookup"><span data-stu-id="a4012-803">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="a4012-804">Si supponga, ad esempio, che un prodotto di comunicazione disponga di un'area di memoria ad alta velocità per l'I/O.</span><span class="sxs-lookup"><span data-stu-id="a4012-804">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="a4012-805">Questa area di memoria è facilmente gestibile rendendola in un pool di blocchi di memoria ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-805">This memory area is easily managed by making it into a ThreadX SMP memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="a4012-806">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-806">Thread Suspension</span></span> 
<span data-ttu-id="a4012-807">I thread dell'applicazione possono essere sospesi in attesa di un blocco di memoria da un pool vuoto.</span><span class="sxs-lookup"><span data-stu-id="a4012-807">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="a4012-808">Quando un blocco viene restituito al pool, al thread sospeso viene assegnato questo blocco e il thread viene ripreso.</span><span class="sxs-lookup"><span data-stu-id="a4012-808">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="a4012-809">Se più thread vengono sospesi nello stesso pool di blocchi di memoria, verranno ripresi nell'ordine in cui sono stati sospesi (FIFO).</span><span class="sxs-lookup"><span data-stu-id="a4012-809">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="a4012-810">Tuttavia, la ripresa della priorità è possibile anche se l'applicazione chiama ***tx_block_pool_prioritize*** prima della chiamata di rilascio del blocco che solleva la sospensione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-810">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="a4012-811">Il servizio di assegnazione delle priorità del pool di blocchi posiziona il thread con priorità più elevata all'inizio dell'elenco di sospensioni, lasciando tutti gli altri thread sospesi nello stesso ordine FIFO.</span><span class="sxs-lookup"><span data-stu-id="a4012-811">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="a4012-812">Informazioni sulle prestazioni del pool di blocchi in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-812">Run-time Block Pool Performance Information</span></span>  
<span data-ttu-id="a4012-813">ThreadX SMP fornisce informazioni sulle prestazioni del pool di blocchi in fase di esecuzione facoltative.</span><span class="sxs-lookup"><span data-stu-id="a4012-813">ThreadX SMP provides optional run-time block pool performance information.</span></span> <span data-ttu-id="a4012-814">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-814">If the ThreadX SMP library and application is built with ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="a4012-815">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-815">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-816">blocchi allocati</span><span class="sxs-lookup"><span data-stu-id="a4012-816">blocks allocated</span></span>
- <span data-ttu-id="a4012-817">blocchi rilasciati</span><span class="sxs-lookup"><span data-stu-id="a4012-817">blocks released</span></span>
- <span data-ttu-id="a4012-818">sospensioni di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-818">allocation suspensions</span></span>
- <span data-ttu-id="a4012-819">timeout di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-819">allocation timeouts</span></span>

<span data-ttu-id="a4012-820">Numero totale per ogni pool di blocchi:</span><span class="sxs-lookup"><span data-stu-id="a4012-820">Total number for each block pool:</span></span>

- <span data-ttu-id="a4012-821">blocchi allocati</span><span class="sxs-lookup"><span data-stu-id="a4012-821">blocks allocated</span></span>
- <span data-ttu-id="a4012-822">blocchi rilasciati</span><span class="sxs-lookup"><span data-stu-id="a4012-822">blocks released</span></span>
- <span data-ttu-id="a4012-823">sospensioni di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-823">allocation suspensions</span></span>
- <span data-ttu-id="a4012-824">timeout di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-824">allocation timeouts</span></span>

<span data-ttu-id="a4012-825">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_block_pool_performance_info_get* e *tx_block_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-825">This information is available at run-time through the services *tx_block_pool_performance_info_get* and *tx_block_pool_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-826">Le informazioni sulle prestazioni del pool di blocchi sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-826">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-827">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-827">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-828">Ad esempio, un numero relativamente elevato di "sospensioni di allocazione" potrebbe indicare che il pool di blocchi è troppo piccolo.</span><span class="sxs-lookup"><span data-stu-id="a4012-828">For example, a relatively high number of “allocation suspensions” might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="a4012-829">Blocco di controllo del pool di blocchi di memoria TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="a4012-829">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>  
<span data-ttu-id="a4012-830">Le caratteristiche di ogni pool di blocchi di memoria si trovano nel blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-830">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="a4012-831">Contiene informazioni quali il numero di blocchi di memoria disponibili e le dimensioni del blocco del pool di memoria.</span><span class="sxs-lookup"><span data-stu-id="a4012-831">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="a4012-832">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-832">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="a4012-833">I blocchi di controllo del pool possono anche trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendola al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-833">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="a4012-834">Sovrascrittura di blocchi di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-834">Overwriting Memory Blocks</span></span>  
<span data-ttu-id="a4012-835">È importante assicurarsi che l'utente di un blocco di memoria allocato non scriva al di fuori dei limiti.</span><span class="sxs-lookup"><span data-stu-id="a4012-835">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="a4012-836">In tal caso, il danneggiamento si verifica in un'area di memoria adiacente (in genere successiva).</span><span class="sxs-lookup"><span data-stu-id="a4012-836">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="a4012-837">I risultati sono imprevedibili e spesso fatali.</span><span class="sxs-lookup"><span data-stu-id="a4012-837">The results are unpredictable and often fatal!</span></span> 

## <a name="memory-byte-pools"></a><span data-ttu-id="a4012-838">Pool di byte di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-838">Memory Byte Pools</span></span>

<span data-ttu-id="a4012-839">I pool di byte di memoria SMP ThreadX sono simili a un heap C standard.</span><span class="sxs-lookup"><span data-stu-id="a4012-839">ThreadX SMP memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="a4012-840">Diversamente dall'heap C standard, è possibile avere più pool di byte di memoria.</span><span class="sxs-lookup"><span data-stu-id="a4012-840">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="a4012-841">Inoltre, i thread possono sospendere in un pool fino a quando non è disponibile la memoria richiesta.</span><span class="sxs-lookup"><span data-stu-id="a4012-841">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="a4012-842">Le allocazioni dai pool di byte di memoria sono simili alle chiamate *malloc* tradizionali, che includono la quantità di memoria desiderata (in byte).</span><span class="sxs-lookup"><span data-stu-id="a4012-842">Allocations from memory byte pools are similar to traditional *malloc* calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="a4012-843">La memoria viene allocata dal pool in modo *appropriato* . ovvero, viene utilizzato il primo blocco di memoria libera che soddisfa la richiesta.</span><span class="sxs-lookup"><span data-stu-id="a4012-843">Memory is allocated from the pool in a *first-fit* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="a4012-844">Una quantità eccessiva di memoria da questo blocco viene convertita in un nuovo blocco e inserita nuovamente nell'elenco di memoria libera.</span><span class="sxs-lookup"><span data-stu-id="a4012-844">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="a4012-845">Questo processo è denominato *frammentazione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-845">This process is called *fragmentation*.</span></span>

<span data-ttu-id="a4012-846">I blocchi di memoria liberi adiacenti vengono *Uniti* durante una ricerca di allocazione successiva per un blocco di memoria disponibile sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="a4012-846">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="a4012-847">Questo processo è denominato *deframmentazione*.</span><span class="sxs-lookup"><span data-stu-id="a4012-847">This process is called *de-fragmentation*.</span></span>

<span data-ttu-id="a4012-848">Ogni pool di byte di memoria è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-848">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="a4012-849">ThreadX SMP non impone vincoli per la modalità di utilizzo dei pool, ad eccezione del fatto che non è possibile chiamare i servizi byte di memoria da ISRs.</span><span class="sxs-lookup"><span data-stu-id="a4012-849">ThreadX SMP places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="a4012-850">Creazione di pool di byte di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-850">Creating Memory Byte Pools</span></span> 
<span data-ttu-id="a4012-851">I pool di byte di memoria vengono creati durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-851">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-852">Non esiste alcun limite al numero di pool di byte di memoria in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-852">There is no limit on the number of memory byte pools in an application.</span></span>  

### <a name="pool-capacity"></a><span data-ttu-id="a4012-853">Capacità pool</span><span class="sxs-lookup"><span data-stu-id="a4012-853">Pool Capacity</span></span> 
<span data-ttu-id="a4012-854">Il numero di byte allocabili in un pool di byte di memoria è leggermente inferiore a quello specificato durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-854">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="a4012-855">Ciò è dovuto al fatto che la gestione dell'area di memoria libera introduce un sovraccarico.</span><span class="sxs-lookup"><span data-stu-id="a4012-855">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="a4012-856">Ogni blocco di memoria disponibile nel pool richiede l'equivalente di due puntatori C di overhead.</span><span class="sxs-lookup"><span data-stu-id="a4012-856">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="a4012-857">Il pool viene inoltre creato con due blocchi, un blocco libero di grandi dimensioni e un piccolo blocco allocato in modo permanente alla fine dell'area di memoria.</span><span class="sxs-lookup"><span data-stu-id="a4012-857">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="a4012-858">Questo blocco allocato viene utilizzato per migliorare le prestazioni dell'algoritmo di allocazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-858">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="a4012-859">Elimina la necessità di verificare continuamente la fine dell'area del pool durante l'Unione.</span><span class="sxs-lookup"><span data-stu-id="a4012-859">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>  

<span data-ttu-id="a4012-860">Durante la fase di esecuzione, la quantità di overhead nel pool aumenta in genere.</span><span class="sxs-lookup"><span data-stu-id="a4012-860">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="a4012-861">Le allocazioni di un numero dispari di byte vengono riempite per garantire un corretto allineamento del blocco di memoria successivo.</span><span class="sxs-lookup"><span data-stu-id="a4012-861">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="a4012-862">Inoltre, l'overhead aumenta quando il pool diventa più frammentato.</span><span class="sxs-lookup"><span data-stu-id="a4012-862">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="a4012-863">Area di memoria del pool</span><span class="sxs-lookup"><span data-stu-id="a4012-863">Pool’s Memory Area</span></span>  
<span data-ttu-id="a4012-864">L'area di memoria per un pool di byte di memoria viene specificata durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-864">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="a4012-865">Analogamente ad altre aree di memoria in ThreadX SMP, può trovarsi in qualsiasi punto dello spazio degli indirizzi della destinazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-865">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span> 

<span data-ttu-id="a4012-866">Si tratta di una funzionalità importante grazie alla notevole flessibilità offerta.</span><span class="sxs-lookup"><span data-stu-id="a4012-866">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="a4012-867">Se, ad esempio, l'hardware di destinazione ha un'area di memoria ad alta velocità e un'area di memoria a bassa velocità, l'utente può gestire l'allocazione di memoria per entrambe le aree creando un pool in ognuno di essi.</span><span class="sxs-lookup"><span data-stu-id="a4012-867">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="a4012-868">Sospensione thread</span><span class="sxs-lookup"><span data-stu-id="a4012-868">Thread Suspension</span></span>  
<span data-ttu-id="a4012-869">I thread dell'applicazione possono essere sospesi in attesa di byte di memoria da un pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-869">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="a4012-870">Quando è disponibile una quantità di memoria contigua sufficiente, ai thread sospesi viene assegnata la memoria richiesta e i thread vengono ripresi.</span><span class="sxs-lookup"><span data-stu-id="a4012-870">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span> 

<span data-ttu-id="a4012-871">Se più thread vengono sospesi nello stesso pool di byte di memoria, vengono assegnati alla memoria (ripresa) nell'ordine in cui sono stati sospesi (FIFO).</span><span class="sxs-lookup"><span data-stu-id="a4012-871">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span> 

<span data-ttu-id="a4012-872">Tuttavia, la ripresa della priorità è possibile anche se l'applicazione chiama ***tx_byte_pool_prioritize*** prima della chiamata di rilascio di byte che solleva la sospensione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-872">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="a4012-873">Il servizio di assegnazione delle priorità del pool di byte inserisce il thread con priorità più elevata all'inizio dell'elenco di sospensioni, lasciando tutti gli altri thread sospesi nello stesso ordine FIFO.</span><span class="sxs-lookup"><span data-stu-id="a4012-873">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="a4012-874">Informazioni sulle prestazioni del pool di byte in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-874">Run-time Byte Pool Performance Information</span></span>  
<span data-ttu-id="a4012-875">ThreadX SMP fornisce informazioni sulle prestazioni del pool di byte in fase di esecuzione facoltative.</span><span class="sxs-lookup"><span data-stu-id="a4012-875">ThreadX SMP provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="a4012-876">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-876">If the ThreadX SMP library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="a4012-877">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-877">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-878">allocazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-878">allocations</span></span>
- <span data-ttu-id="a4012-879">versioni</span><span class="sxs-lookup"><span data-stu-id="a4012-879">releases</span></span>
- <span data-ttu-id="a4012-880">frammenti cercati</span><span class="sxs-lookup"><span data-stu-id="a4012-880">fragments searched</span></span>
- <span data-ttu-id="a4012-881">frammenti Uniti</span><span class="sxs-lookup"><span data-stu-id="a4012-881">fragments merged</span></span>
- <span data-ttu-id="a4012-882">frammenti creati</span><span class="sxs-lookup"><span data-stu-id="a4012-882">fragments created</span></span>
- <span data-ttu-id="a4012-883">sospensioni di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-883">allocation suspensions</span></span>
- <span data-ttu-id="a4012-884">timeout di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-884">allocation timeouts</span></span>

<span data-ttu-id="a4012-885">Numero totale per ogni pool di byte:</span><span class="sxs-lookup"><span data-stu-id="a4012-885">Total number for each byte pool:</span></span>

- <span data-ttu-id="a4012-886">allocazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-886">allocations</span></span>
- <span data-ttu-id="a4012-887">versioni</span><span class="sxs-lookup"><span data-stu-id="a4012-887">releases</span></span>
- <span data-ttu-id="a4012-888">frammenti cercati</span><span class="sxs-lookup"><span data-stu-id="a4012-888">fragments searched</span></span>
- <span data-ttu-id="a4012-889">frammenti Uniti</span><span class="sxs-lookup"><span data-stu-id="a4012-889">fragments merged</span></span>
- <span data-ttu-id="a4012-890">frammenti creati</span><span class="sxs-lookup"><span data-stu-id="a4012-890">fragments created</span></span>
- <span data-ttu-id="a4012-891">sospensioni di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-891">allocation suspensions</span></span>
- <span data-ttu-id="a4012-892">timeout di allocazione</span><span class="sxs-lookup"><span data-stu-id="a4012-892">allocation timeouts</span></span>

<span data-ttu-id="a4012-893">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_byte_pool_performance_info_get* e *tx_byte_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-893">This information is available at run-time through the services *tx_byte_pool_performance_info_get* and *tx_byte_pool_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-894">Le informazioni sulle prestazioni del pool di byte sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-894">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-895">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-895">It is also useful in optimizing the application.</span></span> <span data-ttu-id="a4012-896">Ad esempio, un numero relativamente elevato di "sospensioni di allocazione" potrebbe indicare che il pool di byte è troppo piccolo.</span><span class="sxs-lookup"><span data-stu-id="a4012-896">For example, a relatively high number of “allocation suspensions” might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="a4012-897">TX_BYTE_POOL blocco di controllo pool di byte di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-897">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>  
<span data-ttu-id="a4012-898">Le caratteristiche di ogni pool di byte di memoria si trovano nel blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-898">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="a4012-899">Contiene informazioni utili, ad esempio il numero di byte disponibili nel pool.</span><span class="sxs-lookup"><span data-stu-id="a4012-899">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="a4012-900">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-900">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="a4012-901">I blocchi di controllo del pool possono anche trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendola al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-901">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="nondeterministic-behavior"></a><span data-ttu-id="a4012-902">Comportamento non deterministico</span><span class="sxs-lookup"><span data-stu-id="a4012-902">Nondeterministic Behavior</span></span> 
<span data-ttu-id="a4012-903">Sebbene i pool di byte di memoria forniscano l'allocazione di memoria più flessibile, soffrono anche di un comportamento non deterministico.</span><span class="sxs-lookup"><span data-stu-id="a4012-903">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="a4012-904">Ad esempio, un pool di byte di memoria potrebbe avere 2.000 byte di memoria disponibile, ma potrebbe non essere in grado di soddisfare una richiesta di allocazione di 1.000 byte.</span><span class="sxs-lookup"><span data-stu-id="a4012-904">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="a4012-905">Questo perché non esistono garanzie sul numero di byte liberi contigui.</span><span class="sxs-lookup"><span data-stu-id="a4012-905">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="a4012-906">Anche se esiste un blocco libero a 1.000 byte, non sono previste garanzie sul tempo necessario per trovare il blocco.</span><span class="sxs-lookup"><span data-stu-id="a4012-906">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="a4012-907">È possibile che l'intero pool di memoria debba eseguire la ricerca per trovare il blocco di 1.000 byte.</span><span class="sxs-lookup"><span data-stu-id="a4012-907">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="a4012-908">Per questo motivo, è in genere consigliabile evitare l'utilizzo di servizi byte di memoria in aree in cui è necessario il comportamento deterministico in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-908">Because of this, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required.</span></span> <span data-ttu-id="a4012-909">Molte applicazioni preallocano la memoria necessaria durante l'inizializzazione o la configurazione in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-909">Many applications pre-allocate their required memory during initialization or run-time configuration.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="a4012-910">Sovrascrittura di blocchi di memoria</span><span class="sxs-lookup"><span data-stu-id="a4012-910">Overwriting Memory Blocks</span></span> 
<span data-ttu-id="a4012-911">È importante assicurarsi che l'utente della memoria allocata non scriva al di fuori dei limiti.</span><span class="sxs-lookup"><span data-stu-id="a4012-911">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="a4012-912">In tal caso, il danneggiamento si verifica in un'area di memoria adiacente (in genere successiva).</span><span class="sxs-lookup"><span data-stu-id="a4012-912">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="a4012-913">I risultati sono imprevedibili e spesso fatali.</span><span class="sxs-lookup"><span data-stu-id="a4012-913">The results are unpredictable and often fatal!</span></span> 

## <a name="application-timers"></a><span data-ttu-id="a4012-914">Timer applicazione</span><span class="sxs-lookup"><span data-stu-id="a4012-914">Application Timers</span></span>

<span data-ttu-id="a4012-915">Una risposta rapida a eventi esterni asincroni è la funzione più importante delle applicazioni incorporate in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-915">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="a4012-916">Tuttavia, molte di queste applicazioni devono anche eseguire determinate attività a intervalli di tempo prestabiliti.</span><span class="sxs-lookup"><span data-stu-id="a4012-916">However, many of these applications must also perform certain activities at pre-determined intervals of time.</span></span>

<span data-ttu-id="a4012-917">I timer dell'applicazione SMP di ThreadX offrono alle applicazioni la possibilità di eseguire funzioni C dell'applicazione a intervalli di tempo specifici.</span><span class="sxs-lookup"><span data-stu-id="a4012-917">ThreadX SMP application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="a4012-918">È anche possibile che un timer dell'applicazione SCADA una sola volta.</span><span class="sxs-lookup"><span data-stu-id="a4012-918">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="a4012-919">Questo tipo di timer è denominato *timer* monouso, mentre i timer per intervalli ripetuti vengono chiamati timer *periodici*.</span><span class="sxs-lookup"><span data-stu-id="a4012-919">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="a4012-920">Ogni timer dell'applicazione è una risorsa pubblica.</span><span class="sxs-lookup"><span data-stu-id="a4012-920">Each application timer is a public resource.</span></span> <span data-ttu-id="a4012-921">ThreadX SMP non impone vincoli sul modo in cui vengono usati i timer applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-921">ThreadX SMP places no constraints on how application timers are used.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-922">I timer dell'applicazione possono essere esclusi dall'esecuzione in qualsiasi core tramite l'API tx_timer_smp_core_exclude.</span><span class="sxs-lookup"><span data-stu-id="a4012-922">Application timers can be excluded from execution on any core via the tx_timer_smp_core_exclude API.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="a4012-923">Intervalli timer</span><span class="sxs-lookup"><span data-stu-id="a4012-923">Timer Intervals</span></span> 
<span data-ttu-id="a4012-924">Negli intervalli di tempo SMP ThreadX sono misurati in base a interrupt timer periodici.</span><span class="sxs-lookup"><span data-stu-id="a4012-924">In ThreadX SMP time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="a4012-925">Ogni interrupt del timer viene chiamato *ciclo* del timer.</span><span class="sxs-lookup"><span data-stu-id="a4012-925">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="a4012-926">Il tempo effettivo tra i cicli del timer viene specificato dall'applicazione, ma 10 ms è la norma per la maggior parte delle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="a4012-926">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="a4012-927">La configurazione del timer periodico si trova in genere nel file di assembly ***tx_initialize_low_level*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-927">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="a4012-928">Vale la pena ricordare che l'hardware sottostante deve avere la possibilità di generare interruzioni periodiche per il funzionamento dei timer dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-928">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="a4012-929">In alcuni casi, il processore ha una funzionalità di interrupt periodica incorporata.</span><span class="sxs-lookup"><span data-stu-id="a4012-929">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="a4012-930">Se il processore non è in grado di eseguire questa operazione, è necessario che la lavagna dell'utente disponga di un dispositivo periferico in grado di generare interruzioni periodiche.</span><span class="sxs-lookup"><span data-stu-id="a4012-930">If the processor doesn’t have this ability, the user’s board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a4012-931">ThreadX SMP può comunque funzionare anche senza un'origine interrupt periodica.</span><span class="sxs-lookup"><span data-stu-id="a4012-931">ThreadX SMP can still function even without a periodic interrupt source.</span></span> <span data-ttu-id="a4012-932">Tuttavia, tutte le operazioni di elaborazione correlate al timer vengono disabilitate.</span><span class="sxs-lookup"><span data-stu-id="a4012-932">However, all timer-related processing is then disabled.</span></span> <span data-ttu-id="a4012-933">Sono inclusi timeslicing, i timeout di sospensione e i servizi timer.</span><span class="sxs-lookup"><span data-stu-id="a4012-933">This includes timeslicing, suspension time-outs, and timer services.</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="a4012-934">Accuratezza timer</span><span class="sxs-lookup"><span data-stu-id="a4012-934">Timer Accuracy</span></span> 
<span data-ttu-id="a4012-935">Le scadenze del timer vengono specificate in termini di cicli.</span><span class="sxs-lookup"><span data-stu-id="a4012-935">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="a4012-936">Il valore di scadenza specificato viene diminuito di uno per ogni ciclo del timer.</span><span class="sxs-lookup"><span data-stu-id="a4012-936">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="a4012-937">Poiché un timer dell'applicazione può essere abilitato immediatamente prima di un interrupt del timer (o un segno di timer), l'ora di scadenza effettiva potrebbe essere fino a un segno di prima.</span><span class="sxs-lookup"><span data-stu-id="a4012-937">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="a4012-938">Se la frequenza di battito del timer è 10 ms, i timer dell'applicazione possono scadere prima di 10 ms.</span><span class="sxs-lookup"><span data-stu-id="a4012-938">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="a4012-939">Questa operazione è più significativa per i timer 10 ms di 1 secondo.</span><span class="sxs-lookup"><span data-stu-id="a4012-939">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="a4012-940">Naturalmente, l'aumento della frequenza di interrupt del timer diminuisce questo margine di errore.</span><span class="sxs-lookup"><span data-stu-id="a4012-940">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="a4012-941">Esecuzione del timer</span><span class="sxs-lookup"><span data-stu-id="a4012-941">Timer Execution</span></span> 
<span data-ttu-id="a4012-942">I timer dell'applicazione vengono eseguiti nell'ordine in cui diventano attivi.</span><span class="sxs-lookup"><span data-stu-id="a4012-942">Application timers execute in the order they become active.</span></span> <span data-ttu-id="a4012-943">Se, ad esempio, vengono creati tre timer con lo stesso valore di scadenza e attivato, l'esecuzione delle funzioni di scadenza corrispondenti verrà garantita nell'ordine in cui sono state attivate.</span><span class="sxs-lookup"><span data-stu-id="a4012-943">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span> 

### <a name="creating-application-timers"></a><span data-ttu-id="a4012-944">Creazione di timer applicazione</span><span class="sxs-lookup"><span data-stu-id="a4012-944">Creating Application Timers</span></span> 
<span data-ttu-id="a4012-945">I timer dell'applicazione vengono creati durante l'inizializzazione o durante la fase di esecuzione dai thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-945">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="a4012-946">Non esiste alcun limite al numero di timer applicazione in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-946">There is no limit on the number of application timers in an application.</span></span> 

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="a4012-947">Informazioni sulle prestazioni del timer dell'applicazione in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="a4012-947">Run-time Application Timer Performance Information</span></span>  
<span data-ttu-id="a4012-948">ThreadX SMP fornisce informazioni sulle prestazioni del timer dell'applicazione in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-948">ThreadX SMP provides optional run-time application timer performance information.</span></span> <span data-ttu-id="a4012-949">Se la libreria SMP di ThreadX e l'applicazione sono compilate con ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** definito, threadX SMP accumula le informazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a4012-949">If the ThreadX SMP library and application are built with ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="a4012-950">Numero totale per il sistema globale:</span><span class="sxs-lookup"><span data-stu-id="a4012-950">Total number for the overall system:</span></span>

- <span data-ttu-id="a4012-951">attivazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-951">activations</span></span>
- <span data-ttu-id="a4012-952">disattivazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-952">deactivations</span></span>
- <span data-ttu-id="a4012-953">Riattivazioni (timer periodici)</span><span class="sxs-lookup"><span data-stu-id="a4012-953">reactivations (periodic timers)</span></span>
- <span data-ttu-id="a4012-954">expirations</span><span class="sxs-lookup"><span data-stu-id="a4012-954">expirations</span></span>
- <span data-ttu-id="a4012-955">rettifiche di scadenza</span><span class="sxs-lookup"><span data-stu-id="a4012-955">expiration adjustments</span></span>

<span data-ttu-id="a4012-956">Numero totale per ogni timer applicazione:</span><span class="sxs-lookup"><span data-stu-id="a4012-956">Total number for each application timer:</span></span>

- <span data-ttu-id="a4012-957">attivazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-957">activations</span></span>
- <span data-ttu-id="a4012-958">disattivazioni</span><span class="sxs-lookup"><span data-stu-id="a4012-958">deactivations</span></span>
- <span data-ttu-id="a4012-959">Riattivazioni (timer periodici)</span><span class="sxs-lookup"><span data-stu-id="a4012-959">reactivations (periodic timers)</span></span>
- <span data-ttu-id="a4012-960">expirations</span><span class="sxs-lookup"><span data-stu-id="a4012-960">expirations</span></span>
- <span data-ttu-id="a4012-961">rettifiche di scadenza</span><span class="sxs-lookup"><span data-stu-id="a4012-961">expiration adjustments</span></span>

<span data-ttu-id="a4012-962">Queste informazioni sono disponibili in fase di esecuzione tramite i servizi *tx_timer_performance_info_get* e *tx_timer_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="a4012-962">This information is available at run-time through the services *tx_timer_performance_info_get* and *tx_timer_performance_system_info_get*.</span></span> <span data-ttu-id="a4012-963">Le informazioni sulle prestazioni del timer applicazione sono utili per determinare se l'applicazione funziona correttamente.</span><span class="sxs-lookup"><span data-stu-id="a4012-963">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="a4012-964">È utile anche per ottimizzare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-964">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="a4012-965">TX_TIMER blocco di controllo timer applicazione</span><span class="sxs-lookup"><span data-stu-id="a4012-965">Application Timer Control Block TX_TIMER</span></span> 
<span data-ttu-id="a4012-966">Le caratteristiche di ogni timer dell'applicazione si trovano nel relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a4012-966">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="a4012-967">Contiene informazioni utili, ad esempio il valore di identificazione della scadenza a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="a4012-967">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="a4012-968">Questa struttura viene definita nel file ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="a4012-968">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="a4012-969">I blocchi di controllo del timer applicazione possono trovarsi in qualsiasi punto della memoria, ma è più comune fare in modo che il controllo blocchi una struttura globale definendolo al di fuori dell'ambito di qualsiasi funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-969">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="excessive-timers"></a><span data-ttu-id="a4012-970">Timer eccessivi</span><span class="sxs-lookup"><span data-stu-id="a4012-970">Excessive Timers</span></span> 
<span data-ttu-id="a4012-971">Per impostazione predefinita, i timer dell'applicazione vengono eseguiti da un thread di sistema nascosto eseguito con priorità zero, che in genere è superiore a qualsiasi thread dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-971">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="a4012-972">Per questo motivo, l'elaborazione all'interno dei timer dell'applicazione deve essere mantenuta al minimo.</span><span class="sxs-lookup"><span data-stu-id="a4012-972">Because of this, processing inside application timers should be kept to a minimum.</span></span> 

<span data-ttu-id="a4012-973">È inoltre importante evitare, quando possibile, i timer che scadono ogni ciclo del timer.</span><span class="sxs-lookup"><span data-stu-id="a4012-973">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="a4012-974">Una situazione di questo tipo può causare un sovraccarico eccessivo nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-974">Such a situation might induce excessive overhead in the application.</span></span>

> [!WARNING]
> <span data-ttu-id="a4012-975">Come indicato in precedenza, i timer dell'applicazione vengono eseguiti da un thread di sistema nascosto.</span><span class="sxs-lookup"><span data-stu-id="a4012-975">As mentioned previously, application timers are executed from a hidden system thread.</span></span> <span data-ttu-id="a4012-976">È pertanto importante non selezionare la sospensione per le chiamate al servizio ThreadX SMP effettuate dall'interno della funzione di scadenza del timer dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-976">It is, therefore, important not to select suspension on any ThreadX SMP service calls made from within the application timer’s expiration function.</span></span>

## <a name="relative-time"></a><span data-ttu-id="a4012-977">Ora relativa</span><span class="sxs-lookup"><span data-stu-id="a4012-977">Relative Time</span></span>

<span data-ttu-id="a4012-978">Oltre ai timer per le applicazioni citati in precedenza, ThreadX SMP fornisce un singolo contatore di cicli a 32 bit a incremento continuo.</span><span class="sxs-lookup"><span data-stu-id="a4012-978">In addition to the application timers mentioned previously, ThreadX SMP provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="a4012-979">Il contatore o l' *ora* del segno di verifica viene aumentato di uno per ogni interrupt del timer.</span><span class="sxs-lookup"><span data-stu-id="a4012-979">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="a4012-980">L'applicazione può leggere o impostare questo contatore a 32 bit tramite chiamate rispettivamente a *tx_time_get* e *tx_time_set*.</span><span class="sxs-lookup"><span data-stu-id="a4012-980">The application can read or set this 32-bit counter through calls to *tx_time_get* and *tx_time_set*, respectively.</span></span> <span data-ttu-id="a4012-981">L'uso di questo contatore di cicli è determinato completamente dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a4012-981">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="a4012-982">Non viene utilizzato internamente da ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-982">It is not used internally by ThreadX SMP.</span></span>

### <a name="interrupts"></a><span data-ttu-id="a4012-983">Interrompe</span><span class="sxs-lookup"><span data-stu-id="a4012-983">Interrupts</span></span> 
<span data-ttu-id="a4012-984">Una risposta rapida agli eventi asincroni è la funzione principale di applicazioni incorporate in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="a4012-984">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="a4012-985">L'applicazione sa che tale evento è presente attraverso gli interrupt hardware.</span><span class="sxs-lookup"><span data-stu-id="a4012-985">The application knows such an event is present through hardware interrupts.</span></span> 

<span data-ttu-id="a4012-986">Un interrupt è una modifica asincrona nell'esecuzione del processore.</span><span class="sxs-lookup"><span data-stu-id="a4012-986">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="a4012-987">In genere, quando si verifica un interrupt, il processore salva una piccola parte dell'esecuzione corrente nello stack e trasferisce il controllo al vettore di interrupt appropriato.</span><span class="sxs-lookup"><span data-stu-id="a4012-987">Typically, when an interrupt occurs, the processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="a4012-988">Il vettore di interrupt è fondamentalmente solo l'indirizzo della routine responsabile della gestione dell'interrupt del tipo specifico.</span><span class="sxs-lookup"><span data-stu-id="a4012-988">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="a4012-989">La procedura di gestione degli interrupt esatta è specifica del processore.</span><span class="sxs-lookup"><span data-stu-id="a4012-989">The exact interrupt handling procedure is processor specific.</span></span> 

### <a name="interrupt-control"></a><span data-ttu-id="a4012-990">Interrompi controllo</span><span class="sxs-lookup"><span data-stu-id="a4012-990">Interrupt Control</span></span> 
<span data-ttu-id="a4012-991">Il servizio *tx_interrupt_control* consente alle applicazioni di abilitare e disabilitare gli interrupt.</span><span class="sxs-lookup"><span data-stu-id="a4012-991">The *tx_interrupt_control* service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="a4012-992">Questo servizio restituisce la postura di abilitazione/disabilitazione dell'interrupt precedente.</span><span class="sxs-lookup"><span data-stu-id="a4012-992">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="a4012-993">È importante ricordare che il controllo interrupt influisca solo sul segmento di programma attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-993">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="a4012-994">Ad esempio, se un thread Disabilita gli interrupt, restano disabilitati solo durante l'esecuzione del thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-994">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span> 

> [!WARNING]
> <span data-ttu-id="a4012-995">Un interrupt non mascherabile (NMI) è un interrupt che non può essere disabilitato dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="a4012-995">A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware.</span></span> <span data-ttu-id="a4012-996">Tale interrupt può essere utilizzato dalle applicazioni SMP di ThreadX.</span><span class="sxs-lookup"><span data-stu-id="a4012-996">Such an interrupt may be used by ThreadX SMP applications.</span></span> <span data-ttu-id="a4012-997">Tuttavia, la routine di gestione NMI dell'applicazione non è autorizzata a usare la gestione del contesto SMP di ThreadX o qualsiasi servizio API.</span><span class="sxs-lookup"><span data-stu-id="a4012-997">However, the application’s NMI handling routine is not allowed to use ThreadX SMP context management or any API services.</span></span> <span data-ttu-id="a4012-998">Interrupt gestiti di ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="a4012-998">ThreadX SMP Managed Interrupts</span></span>

<span data-ttu-id="a4012-999">ThreadX SMP fornisce applicazioni con gestione completa degli interrupt.</span><span class="sxs-lookup"><span data-stu-id="a4012-999">ThreadX SMP provides applications with complete interrupt management.</span></span> <span data-ttu-id="a4012-1000">Questa gestione include il salvataggio e il ripristino del contesto dell'esecuzione interrotta.</span><span class="sxs-lookup"><span data-stu-id="a4012-1000">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="a4012-1001">Inoltre, ThreadX SMP consente la chiamata di determinati servizi dall'interno di routine del servizio di interrupt (ISRs).</span><span class="sxs-lookup"><span data-stu-id="a4012-1001">In addition, ThreadX SMP allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="a4012-1002">Di seguito è riportato un elenco di SMPservices ThreadX consentiti da ISRs dell'applicazione:</span><span class="sxs-lookup"><span data-stu-id="a4012-1002">The following is a list of ThreadX SMPservices allowed from application ISRs:</span></span>

- <span data-ttu-id="a4012-1003">tx_block_allocate</span><span class="sxs-lookup"><span data-stu-id="a4012-1003">tx_block_allocate</span></span> 
- <span data-ttu-id="a4012-1004">tx_block_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1004">tx_block_pool_info_get</span></span> 
- <span data-ttu-id="a4012-1005">tx_block_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="a4012-1005">tx_block_pool_prioritize</span></span> 
- <span data-ttu-id="a4012-1006">tx_block_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1006">tx_block_pool_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1007">tx_block_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1007">tx_block_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1008">tx_block_release</span><span class="sxs-lookup"><span data-stu-id="a4012-1008">tx_block_release</span></span> 
- <span data-ttu-id="a4012-1009">tx_byte_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1009">tx_byte_pool_info_get</span></span> 
- <span data-ttu-id="a4012-1010">tx_byte_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1010">tx_byte_pool_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1011">tx_byte_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1011">tx_byte_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1012">tx_byte_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="a4012-1012">tx_byte_pool_prioritize</span></span> 
- <span data-ttu-id="a4012-1013">tx_event_flags_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1013">tx_event_flags_info_get</span></span> 
- <span data-ttu-id="a4012-1014">tx_event_flags_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1014">tx_event_flags_get</span></span> 
- <span data-ttu-id="a4012-1015">tx_event_flags_set</span><span class="sxs-lookup"><span data-stu-id="a4012-1015">tx_event_flags_set</span></span> 
- <span data-ttu-id="a4012-1016">tx_event_flags_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1016">tx_event_flags_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1017">tx_event_flags_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1017">tx_event_flags_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1018">tx_event_flags_set_notify</span><span class="sxs-lookup"><span data-stu-id="a4012-1018">tx_event_flags_set_notify</span></span> 
- <span data-ttu-id="a4012-1019">tx_interrupt_control</span><span class="sxs-lookup"><span data-stu-id="a4012-1019">tx_interrupt_control</span></span> 
- <span data-ttu-id="a4012-1020">tx_mutex_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1020">tx_mutex_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1021">tx_mutex_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1021">tx_mutex_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1022">tx_queue_front_send</span><span class="sxs-lookup"><span data-stu-id="a4012-1022">tx_queue_front_send</span></span> 
- <span data-ttu-id="a4012-1023">tx_queue_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1023">tx_queue_info_get</span></span> 
- <span data-ttu-id="a4012-1024">tx_queue_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1024">tx_queue_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1025">tx_queue_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1025">tx_queue_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1026">tx_queue_prioritize</span><span class="sxs-lookup"><span data-stu-id="a4012-1026">tx_queue_prioritize</span></span> 
- <span data-ttu-id="a4012-1027">tx_queue_receive</span><span class="sxs-lookup"><span data-stu-id="a4012-1027">tx_queue_receive</span></span> 
- <span data-ttu-id="a4012-1028">tx_queue_send</span><span class="sxs-lookup"><span data-stu-id="a4012-1028">tx_queue_send</span></span> 
- <span data-ttu-id="a4012-1029">tx_semaphore_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1029">tx_semaphore_get</span></span> 
- <span data-ttu-id="a4012-1030">tx_queue_send_notify</span><span class="sxs-lookup"><span data-stu-id="a4012-1030">tx_queue_send_notify</span></span> 
- <span data-ttu-id="a4012-1031">tx_semaphore_ceiling_put</span><span class="sxs-lookup"><span data-stu-id="a4012-1031">tx_semaphore_ceiling_put</span></span> 
- <span data-ttu-id="a4012-1032">tx_semaphore_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1032">tx_semaphore_info_get</span></span> 
- <span data-ttu-id="a4012-1033">tx_semaphore_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1033">tx_semaphore_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1034">tx_semaphore_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1034">tx_semaphore_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1035">tx_semaphore_prioritize</span><span class="sxs-lookup"><span data-stu-id="a4012-1035">tx_semaphore_prioritize</span></span> 
- <span data-ttu-id="a4012-1036">tx_semaphore_put</span><span class="sxs-lookup"><span data-stu-id="a4012-1036">tx_semaphore_put</span></span> 
- <span data-ttu-id="a4012-1037">tx_thread_identify</span><span class="sxs-lookup"><span data-stu-id="a4012-1037">tx_thread_identify</span></span> 
- <span data-ttu-id="a4012-1038">tx_semaphore_put_notify</span><span class="sxs-lookup"><span data-stu-id="a4012-1038">tx_semaphore_put_notify</span></span> 
- <span data-ttu-id="a4012-1039">tx_thread_entry_exit_notify</span><span class="sxs-lookup"><span data-stu-id="a4012-1039">tx_thread_entry_exit_notify</span></span> 
- <span data-ttu-id="a4012-1040">tx_thread_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1040">tx_thread_info_get</span></span> 
- <span data-ttu-id="a4012-1041">tx_thread_resume</span><span class="sxs-lookup"><span data-stu-id="a4012-1041">tx_thread_resume</span></span> 
- <span data-ttu-id="a4012-1042">tx_thread_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1042">tx_thread_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1043">tx_thread_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1043">tx_thread_performance_system_info_get</span></span> 
- <span data-ttu-id="a4012-1044">tx_thread_stack_error_notify</span><span class="sxs-lookup"><span data-stu-id="a4012-1044">tx_thread_stack_error_notify</span></span> 
- <span data-ttu-id="a4012-1045">tx_thread_wait_abort</span><span class="sxs-lookup"><span data-stu-id="a4012-1045">tx_thread_wait_abort</span></span> 
- <span data-ttu-id="a4012-1046">tx_time_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1046">tx_time_get</span></span> 
- <span data-ttu-id="a4012-1047">tx_time_set</span><span class="sxs-lookup"><span data-stu-id="a4012-1047">tx_time_set</span></span> 
- <span data-ttu-id="a4012-1048">tx_timer_activate</span><span class="sxs-lookup"><span data-stu-id="a4012-1048">tx_timer_activate</span></span> 
- <span data-ttu-id="a4012-1049">tx_timer_change</span><span class="sxs-lookup"><span data-stu-id="a4012-1049">tx_timer_change</span></span> 
- <span data-ttu-id="a4012-1050">tx_timer_deactivate</span><span class="sxs-lookup"><span data-stu-id="a4012-1050">tx_timer_deactivate</span></span> 
- <span data-ttu-id="a4012-1051">tx_timer_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1051">tx_timer_info_get</span></span> 
- <span data-ttu-id="a4012-1052">tx_timer_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1052">tx_timer_performance_info_get</span></span> 
- <span data-ttu-id="a4012-1053">tx_timer_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="a4012-1053">tx_timer_performance_system_info_get</span></span>

> [!WARNING]
> <span data-ttu-id="a4012-1054">La sospensione non è consentita da ISRs.</span><span class="sxs-lookup"><span data-stu-id="a4012-1054">Suspension is not allowed from ISRs.</span></span> <span data-ttu-id="a4012-1055">Pertanto, il parametro **WAIT_OPTION** per tutte le chiamate al servizio threadX SMP effettuate da un ISR deve essere impostato su **TX_NO_WAIT**.</span><span class="sxs-lookup"><span data-stu-id="a4012-1055">Therefore, the **wait_option** parameter for all ThreadX SMP service calls made from an ISR must be set to **TX_NO_WAIT**.</span></span>

### <a name="isr-template"></a><span data-ttu-id="a4012-1056">Modello ISR</span><span class="sxs-lookup"><span data-stu-id="a4012-1056">ISR Template</span></span> 
<span data-ttu-id="a4012-1057">Per gestire gli interrupt dell'applicazione, è necessario chiamare diverse utilità SMP di ThreadX all'inizio e alla fine dell'applicazione ISRs.</span><span class="sxs-lookup"><span data-stu-id="a4012-1057">To manage application interrupts, several ThreadX SMP utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="a4012-1058">Il formato esatto per la gestione degli interrupt varia a seconda delle porte.</span><span class="sxs-lookup"><span data-stu-id="a4012-1058">The exact format for interrupt handling varies between ports.</span></span> <span data-ttu-id="a4012-1059">Esaminare il file di ***readme_threadx.txt*** nel disco di distribuzione per istruzioni specifiche sulla gestione di ISRs.</span><span class="sxs-lookup"><span data-stu-id="a4012-1059">Review the ***readme_threadx.txt*** file on the distribution disk for specific instructions on managing ISRs.</span></span>

<span data-ttu-id="a4012-1060">Il piccolo segmento di codice seguente è tipico della maggior parte delle ISRs gestite da ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-1060">The following small code segment is typical of most ThreadX SMP managed ISRs.</span></span> <span data-ttu-id="a4012-1061">Nella maggior parte dei casi, questa elaborazione è in linguaggio assembly.</span><span class="sxs-lookup"><span data-stu-id="a4012-1061">In most cases, this processing is in assembly language.</span></span>

<span data-ttu-id="a4012-1062">**_application_ISR_vector_entry**:</span><span class="sxs-lookup"><span data-stu-id="a4012-1062">**_application_ISR_vector_entry**:</span></span>  
<span data-ttu-id="a4012-1063">; Salva contesto e prepara per</span><span class="sxs-lookup"><span data-stu-id="a4012-1063">; Save context and prepare for</span></span>  
<span data-ttu-id="a4012-1064">; Uso di ThreadX SMP chiamando il ISR</span><span class="sxs-lookup"><span data-stu-id="a4012-1064">; ThreadX SMP use by calling the ISR</span></span>  
<span data-ttu-id="a4012-1065">; funzione entry.</span><span class="sxs-lookup"><span data-stu-id="a4012-1065">; entry function.</span></span>  
<span data-ttu-id="a4012-1066">CHIAMA **_tx_thread_context_save**</span><span class="sxs-lookup"><span data-stu-id="a4012-1066">CALL **_tx_thread_context_save**</span></span>  

<span data-ttu-id="a4012-1067">; L'ISR ora può chiamare ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="a4012-1067">; The ISR can now call ThreadX SMP</span></span>  
<span data-ttu-id="a4012-1068">; Servizi e relative funzioni C</span><span class="sxs-lookup"><span data-stu-id="a4012-1068">; services and its own C functions</span></span>  

<span data-ttu-id="a4012-1069">; Al termine dell'ISR, contesto</span><span class="sxs-lookup"><span data-stu-id="a4012-1069">; When the ISR is finished, context</span></span>  
<span data-ttu-id="a4012-1070">; ripristinato (o precedenza di thread)</span><span class="sxs-lookup"><span data-stu-id="a4012-1070">; is restored (or thread preemption)</span></span>  
<span data-ttu-id="a4012-1071">; chiamando il ripristino del contesto</span><span class="sxs-lookup"><span data-stu-id="a4012-1071">; by calling the context restore</span></span>  
<span data-ttu-id="a4012-1072">; funzione.</span><span class="sxs-lookup"><span data-stu-id="a4012-1072">; function.</span></span> <span data-ttu-id="a4012-1073">Il controllo non restituisce.</span><span class="sxs-lookup"><span data-stu-id="a4012-1073">Control does not return!</span></span>  
<span data-ttu-id="a4012-1074">Vai **_tx_thread_context_restore**</span><span class="sxs-lookup"><span data-stu-id="a4012-1074">JUMP **_tx_thread_context_restore**</span></span>

### <a name="high-frequency-interrupts"></a><span data-ttu-id="a4012-1075">Interrupt ad alta frequenza</span><span class="sxs-lookup"><span data-stu-id="a4012-1075">High-frequency Interrupts</span></span>  
<span data-ttu-id="a4012-1076">Alcuni interrupt si verificano a una frequenza elevata che il salvataggio e il ripristino del contesto completo su ogni interrupt utilizzeranno una larghezza di banda di elaborazione eccessiva.</span><span class="sxs-lookup"><span data-stu-id="a4012-1076">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="a4012-1077">In questi casi, è normale che l'applicazione disponga di un linguaggio ISR (Small assembly language) che esegue una quantità limitata di elaborazione per la maggior parte degli interrupt highfrequency.</span><span class="sxs-lookup"><span data-stu-id="a4012-1077">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these highfrequency interrupts.</span></span> 

<span data-ttu-id="a4012-1078">Dopo un certo periodo di tempo, il piccolo ISR potrebbe dover interagire con ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="a4012-1078">After a certain point in time, the small ISR may need to interact with ThreadX SMP.</span></span> <span data-ttu-id="a4012-1079">Questa operazione viene eseguita chiamando le funzioni di ingresso e di uscita descritte nel modello precedente.</span><span class="sxs-lookup"><span data-stu-id="a4012-1079">This is accomplished by calling the entry and exit functions described in the above template.</span></span> 

### <a name="interrupt-latency"></a><span data-ttu-id="a4012-1080">Latenza interrupt</span><span class="sxs-lookup"><span data-stu-id="a4012-1080">Interrupt Latency</span></span>  
<span data-ttu-id="a4012-1081">ThreadX SMP blocca gli interrupt per brevi periodi di tempo.</span><span class="sxs-lookup"><span data-stu-id="a4012-1081">ThreadX SMP locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="a4012-1082">L'intervallo di tempo massimo di interrupt è disabilitato nell'ordine del tempo necessario per salvare o ripristinare il contesto di un thread.</span><span class="sxs-lookup"><span data-stu-id="a4012-1082">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread’s context.</span></span> 