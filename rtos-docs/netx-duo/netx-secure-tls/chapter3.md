---
title: Capitolo 3-Descrizione funzionale di Azure RTO NetX Secure
description: Questo capitolo contiene una descrizione funzionale di NetX Secure TLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104821590"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="a729a-103">Capitolo 3-Descrizione funzionale di Azure RTO NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a729a-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="a729a-104">Panoramica dell'esecuzione</span><span class="sxs-lookup"><span data-stu-id="a729a-104">Execution Overview</span></span>

<span data-ttu-id="a729a-105">Questo capitolo contiene una descrizione funzionale di Azure RTO NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="a729a-106">Esistono due tipi principali di esecuzione del programma in un'applicazione TLS sicura NetX: inizializzazione e chiamate dell'interfaccia dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="a729a-107">*NetX Secure presuppone l'esistenza di ThreadX e NetX/NetXDuo. Da ThreadX, sono necessari l'esecuzione di thread, la sospensione, i timer periodici e le strutture di esclusione reciproca. Da NetX/NetXDuo richiede le funzionalità di rete TCP/IP e i driver.*</span><span class="sxs-lookup"><span data-stu-id="a729a-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="a729a-108">Transport Layer Security (TLS) e Secure Sockets Layer (SSL)</span><span class="sxs-lookup"><span data-stu-id="a729a-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="a729a-109">Il componente Secure Network Protocol di NetX Secure è un'implementazione del protocollo Transport Layer Security (TLS), come descritto in RFC 2246 (versione 1,0), 4346 (versione 1,1), 5246 (versione 1,2) e 8446 (versione 1,3).</span><span class="sxs-lookup"><span data-stu-id="a729a-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="a729a-110">Sono incluse anche le routine di supporto per Basic X. 509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="a729a-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="a729a-111">NetX Secure TLS supporta le versioni TLS 1,2 e 1,3.</span><span class="sxs-lookup"><span data-stu-id="a729a-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="a729a-112">Le implementazioni vengono fornite per le funzionalità TLS 1,0 e TLS 1,1 ora deprecate, ma devono essere inizializzate in modo esplicito e non sono consigliate per l'uso nei nuovi prodotti.</span><span class="sxs-lookup"><span data-stu-id="a729a-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="a729a-113">*Secure Sockets Layer* (SSL) è il nome originale di TLS prima che diventi uno standard in RFC 2246 e "SSL" viene spesso usato come nome generico per i protocolli TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="a729a-114">L'ultima versione di SSL è 3,0 e TLS 1,0 viene a volte definito SSL versione 3,1.</span><span class="sxs-lookup"><span data-stu-id="a729a-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="a729a-115">Tutte le versioni del protocollo "SSL" ufficiale sono considerate obsolete e non sicure e attualmente NetX Secure non fornisce un'implementazione SSL.</span><span class="sxs-lookup"><span data-stu-id="a729a-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="a729a-116">TLS specifica un protocollo per generare *chiavi di sessione* create durante l' *handshake* TLS tra un client e un server TLS e tali chiavi vengono usate per crittografare i dati inviati dall'applicazione durante la *sessione TLS.*</span><span class="sxs-lookup"><span data-stu-id="a729a-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="a729a-117">I dati TLS sono divisi in *record* equivalenti al concetto di pacchetto TCP.</span><span class="sxs-lookup"><span data-stu-id="a729a-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="a729a-118">Ogni record TLS ha un'intestazione e i record TLS crittografati hanno anche un piè di pagina (hash di checksum).</span><span class="sxs-lookup"><span data-stu-id="a729a-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="a729a-119">I record di handshake TLS hanno un'intestazione aggiuntiva incapsulata all'interno del record TLS più grande.</span><span class="sxs-lookup"><span data-stu-id="a729a-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="a729a-120">Il record TLS è incapsulato dal protocollo di rete Transport Layer nello stesso modo in cui un pacchetto TCP viene incapsulato da un pacchetto IP.</span><span class="sxs-lookup"><span data-stu-id="a729a-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="a729a-121">TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="a729a-121">TLS 1.3</span></span>

<span data-ttu-id="a729a-122">Nel 2018 agosto la specifica TLS 1,3 è stata finalizzata.</span><span class="sxs-lookup"><span data-stu-id="a729a-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="a729a-123">La nuova versione del protocollo è un aggiornamento piuttosto significativo che modifica alcuni aspetti fondamentali della sicurezza e delle prestazioni sottostanti di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="a729a-124">Tuttavia, queste modifiche sono sostanzialmente invisibili per l'utente TLS tipico, perché si applicano principalmente alla macchina a stati di handshake TLS e alla generazione della chiave della sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="a729a-125">Sono state aggiunte anche numerose funzionalità e estensioni facoltative.</span><span class="sxs-lookup"><span data-stu-id="a729a-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="a729a-126">Di seguito è riportato un riepilogo delle modifiche e il modo in cui influiscano sulla funzionalità TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="a729a-127">La macchina a stati di handshake è stata ottimizzata rimuovendo un intero scambio di messaggi dal server.</span><span class="sxs-lookup"><span data-stu-id="a729a-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="a729a-128">La generazione delle chiavi è stata aggiornata in modo da usare una routine standardizzata denominata HKDF (funzione di derivazione della chiave basata su HMAC) e associa le chiavi della sessione a tutti i messaggi di handshake, anziché alcuni parametri SELECT.</span><span class="sxs-lookup"><span data-stu-id="a729a-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="a729a-129">Tutti i ciphersuites TLS 1,2 e precedenti sono deprecati e non sono compatibili con TLS 1,3.</span><span class="sxs-lookup"><span data-stu-id="a729a-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="a729a-130">Analogamente, tutte le ciphersuites di TLS 1,3 sono inutilizzabili con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a729a-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="a729a-131">Tutti i ciphersuites di TLS 1,3 forniscono la segretezza assoluta (PFS) usando chiavi effimere<sup>6</sup></span><span class="sxs-lookup"><span data-stu-id="a729a-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="a729a-132">TLS 1,3 rimuove il "codice di autenticazione del messaggio" (MAC) in ogni record a favore dell'uso di crittografie AEAD<sup>7</sup></span><span class="sxs-lookup"><span data-stu-id="a729a-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="a729a-133">Sono state aggiunte altre funzionalità facoltative, incluso 0-RTT (tempo di round trip zero) che consente l'invio dei dati dell'applicazione durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="a729a-134">0-RTT è esclusivamente facoltativo e non è attualmente supportato in Azure RTO TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="a729a-135">TLS 1,3 non influisce in modo significativo sulle applicazioni utente.</span><span class="sxs-lookup"><span data-stu-id="a729a-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="a729a-136">L'API rimane esattamente identica tra le versioni e ciphersuites sono contrassegnate in modo che sia possibile usare una singola tabella ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="a729a-137">Per usare TLS 1,3, è necessario definire globalmente la macro NX_SECURE_TLS_ENABLE_TLS_1_3.</span><span class="sxs-lookup"><span data-stu-id="a729a-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="a729a-138">TLS 1,3 è disabilitato per impostazione predefinita in Azure RTO TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="a729a-139">Le chiavi "effimere" sono coppie di chiavi asimmetriche generate durante l'handshake TLS e usate per lo scambio di segreti solo per tale sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="a729a-140">La coppia di chiavi viene eliminata dopo l'uso. in questo modo si impedisce a un utente malintenzionato di accedere ai dati crittografati in una sessione TLS registrata anche se una chiave privata del certificato viene compromessa in qualsiasi momento in futuro, quindi "segretezza in diretta perfetta".</span><span class="sxs-lookup"><span data-stu-id="a729a-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="a729a-141">Crittografia autenticata con dati associati: modalità per le crittografie come AES che combina la crittografia e il controllo dell'integrità in un'unica operazione, eliminando la necessità di un hash separato dei dati per il controllo dell'integrità.</span><span class="sxs-lookup"><span data-stu-id="a729a-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="a729a-142">Intestazione del record TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-142">TLS Record header</span></span>

<span data-ttu-id="a729a-143">Qualsiasi record TLS valido deve avere un'intestazione TLS, come illustrato in errore.</span><span class="sxs-lookup"><span data-stu-id="a729a-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="a729a-144">Origine riferimento non trovata.</span><span class="sxs-lookup"><span data-stu-id="a729a-144">Reference source not found.</span></span>

![Diagramma di un'intestazione di record TLS.](media/image2.png)

<span data-ttu-id="a729a-146">Figura 1-intestazione del record TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="a729a-147">I campi dell'intestazione del record TLS sono definiti come segue:</span><span class="sxs-lookup"><span data-stu-id="a729a-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="a729a-148">Campo di intestazione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-148">TLS Header Field</span></span> | <span data-ttu-id="a729a-149">Scopo</span><span class="sxs-lookup"><span data-stu-id="a729a-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="a729a-150">**Tipo di messaggio a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-150">**8-bit Message Type**</span></span> | <span data-ttu-id="a729a-151">Questo campo contiene il tipo di record TLS da inviare.</span><span class="sxs-lookup"><span data-stu-id="a729a-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="a729a-152">I tipi validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-152">Valid types are as follows:</span></span><br /><span data-ttu-id="a729a-153">-ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="a729a-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="a729a-154">-Avviso: 0x15</span><span class="sxs-lookup"><span data-stu-id="a729a-154">- Alert: 0x15</span></span><br /><span data-ttu-id="a729a-155">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="a729a-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="a729a-156">-Dati applicazione: 0x17</span><span class="sxs-lookup"><span data-stu-id="a729a-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="a729a-157">**Versione del protocollo a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="a729a-158">Questo campo contiene la versione del protocollo TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="a729a-159">I valori validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-159">Valid values are as follows:</span></span><br /><span data-ttu-id="a729a-160">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="a729a-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="a729a-161">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="a729a-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="a729a-162">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="a729a-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="a729a-163">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="a729a-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="a729a-164">- **TLS 1,3 <sup>9</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="a729a-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="a729a-165">**Lunghezza a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-165">**16-bit Length**</span></span> | <span data-ttu-id="a729a-166">Questo campo contiene la lunghezza dei dati incapsulati nel record TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="a729a-167">In TLS 1,3 il messaggio ChangeCipherSpec non viene più usato, sebbene sia comunque possibile inviarlo per motivi di compatibilità, nel qual caso il messaggio viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="a729a-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="a729a-168">TLS 1,3 avrebbe tecnicamente un valore di 0x0304 se questo schema è stato proseguito, ma il protocollo è stato modificato in modo da avere la versione del protocollo effettiva in un'estensione, quindi tutti i record di TLS 1,3 usano 0x0303 nei campi versione protocollo per la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a729a-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="a729a-169">Intestazione del record di handshake TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-169">TLS Handshake Record header</span></span>

<span data-ttu-id="a729a-170">Qualsiasi record di handshake TLS valido deve avere un'intestazione di handshake TLS, come illustrato nella figura 2.</span><span class="sxs-lookup"><span data-stu-id="a729a-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Diagramma di un'intestazione di record di handshake TLS.](media/image3.png)

<span data-ttu-id="a729a-172">Figura 2-intestazione del record di handshake TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="a729a-173">I campi dell'intestazione del record di handshake TLS sono definiti come segue:</span><span class="sxs-lookup"><span data-stu-id="a729a-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="a729a-174">Campo di intestazione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-174">TLS Header Field</span></span> | <span data-ttu-id="a729a-175">Scopo</span><span class="sxs-lookup"><span data-stu-id="a729a-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="a729a-176">**Tipo di messaggio a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-176">**8-bit Message Type**</span></span> | <span data-ttu-id="a729a-177">Questo campo contiene il tipo di record TLS da inviare.</span><span class="sxs-lookup"><span data-stu-id="a729a-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="a729a-178">I tipi validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-178">Valid types are as follows:</span></span><br /><span data-ttu-id="a729a-179">-ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="a729a-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="a729a-180">-Avviso: 0x15</span><span class="sxs-lookup"><span data-stu-id="a729a-180">- Alert: 0x15</span></span><br /><span data-ttu-id="a729a-181">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="a729a-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="a729a-182">-Dati applicazione: 0x17</span><span class="sxs-lookup"><span data-stu-id="a729a-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="a729a-183">**Versione del protocollo a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="a729a-184">Questo campo contiene la versione del protocollo TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="a729a-185">I valori validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-185">Valid values are as follows:</span></span><br /><span data-ttu-id="a729a-186">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="a729a-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="a729a-187">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="a729a-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="a729a-188">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="a729a-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="a729a-189">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="a729a-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="a729a-190">- **TLS 1,3 <sup>11</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="a729a-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="a729a-191">**Lunghezza a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-191">**16-bit Length**</span></span>    | <span data-ttu-id="a729a-192">Questo campo contiene la lunghezza dei dati incapsulati nel record TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="a729a-193">**Tipo di handshake a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="a729a-194">Questo campo contiene il tipo di messaggio di handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-194">This field contains the handshake message type.</span></span> <span data-ttu-id="a729a-195">I valori validi sono i seguenti (\* i messaggi in **grassetto** sono stati aggiunti in TLS 1,3):</span><span class="sxs-lookup"><span data-stu-id="a729a-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="a729a-196">-HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="a729a-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="a729a-197">-ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="a729a-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="a729a-198">-ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="a729a-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="a729a-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="a729a-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="a729a-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="a729a-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="a729a-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="a729a-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="a729a-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="a729a-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="a729a-203">-Certificato: 0x0B</span><span class="sxs-lookup"><span data-stu-id="a729a-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="a729a-204">-ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="a729a-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="a729a-205">-CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="a729a-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="a729a-206">-ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="a729a-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="a729a-207">-CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="a729a-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="a729a-208">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="a729a-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="a729a-209">-Operazione completata: 0x14</span><span class="sxs-lookup"><span data-stu-id="a729a-209">- Finished: 0x14</span></span><br /><span data-ttu-id="a729a-210">- **Aggiornamento** della pagina: **0x18**</span><span class="sxs-lookup"><span data-stu-id="a729a-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="a729a-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="a729a-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="a729a-212">**Lunghezza a 24 bit**</span><span class="sxs-lookup"><span data-stu-id="a729a-212">**24-bit Length**</span></span>    | <span data-ttu-id="a729a-213">Questo campo contiene la lunghezza dei dati del messaggio di handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="a729a-214">In TLS 1,3 il messaggio ChangeCipherSpec non viene più usato, sebbene sia comunque possibile inviarlo per motivi di compatibilità, nel qual caso il messaggio viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="a729a-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="a729a-215">TLS 1,3 avrebbe tecnicamente un valore di 0x0304 se questo schema è stato proseguito, ma il protocollo è stato modificato in modo da avere la versione del protocollo effettiva in un'estensione, quindi tutti i record di TLS 1,3 usano 0x0303 nei campi versione protocollo per la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a729a-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="a729a-216">Handshake TLS e sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="a729a-217">Un handshake TLS tipico (versioni 1.0-1.2) è illustrato nella figura 3.</span><span class="sxs-lookup"><span data-stu-id="a729a-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="a729a-218">Un handshake TLS inizia quando il client TLS Invia un messaggio *ClientHello* a un server TLS, indicando il desiderio di avviare una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="a729a-219">Il messaggio contiene informazioni sulla crittografia che il client desidera utilizzare per la sessione, insieme alle informazioni utilizzate per generare le chiavi di sessione in un secondo momento nell'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="a729a-220">Fino a quando non vengono generate le chiavi della sessione, tutti i messaggi nell'handshake TLS non vengono crittografati.</span><span class="sxs-lookup"><span data-stu-id="a729a-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="a729a-221">TLS 1,3 modifica leggermente l'handshake: i dettagli vengono presentati nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="a729a-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="a729a-222">Il server TLS risponde a ClientHello con un messaggio ServerHello, che indica una selezione dalle opzioni di crittografia fornite dal client.</span><span class="sxs-lookup"><span data-stu-id="a729a-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="a729a-223">ServerHello è seguito da un messaggio di certificato, in cui il server fornisce un certificato digitale per autenticare l'identità nel client.</span><span class="sxs-lookup"><span data-stu-id="a729a-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="a729a-224">Infine, il server invia un messaggio ServerHelloDone per indicare che non sono presenti altri messaggi da inviare.</span><span class="sxs-lookup"><span data-stu-id="a729a-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="a729a-225">Il server può facoltativamente inviare altri messaggi dopo ServerHello e in alcuni casi potrebbe non inviare un messaggio di certificato, di conseguenza la necessità del messaggio ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="a729a-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="a729a-226">Una volta che il client ha ricevuto tutti i messaggi del server, dispone di informazioni sufficienti per generare le chiavi della sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="a729a-227">TLS esegue questa operazione creando un bit condiviso di dati casuali denominato *Master Secret*, che è a dimensione fissa e viene usato come valore di inizializzazione per generare tutte le chiavi necessarie una volta abilitata la crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="a729a-228">Il segreto pre-master viene crittografato usando l'algoritmo a chiave pubblica, ad esempio RSA, specificato nei messaggi Hello (vedere di seguito per informazioni sugli algoritmi a chiave pubblica) e la chiave pubblica fornita dal server nel certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="a729a-229">Una funzionalità TLS facoltativa denominata chiavi precondivise (PSK) consente a ciphersuites che non usano un certificato, ma usano invece un valore segreto condiviso tra gli host (in genere tramite trasferimento fisico o un altro metodo protetto).</span><span class="sxs-lookup"><span data-stu-id="a729a-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="a729a-230">Il segreto condiviso viene utilizzato per generare il segreto pre-master anziché utilizzare un messaggio crittografato per inviare il master secret.</span><span class="sxs-lookup"><span data-stu-id="a729a-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="a729a-231">Vedere la sezione relativa alle chiavi precondivise di seguito.</span><span class="sxs-lookup"><span data-stu-id="a729a-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="a729a-232">Il segreto pre-master crittografato viene inviato al server nel messaggio ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="a729a-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="a729a-233">Il server, al momento della ricezione del messaggio ClientKeyExchange, decrittografa il segreto pre-master usando la relativa chiave privata e continua a generare le chiavi della sessione in parallelo con il client TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="a729a-234">Una volta generate le chiavi della sessione, tutti gli altri messaggi possono essere crittografati usando l'algoritmo di chiave privata, ad esempio AES, selezionato nei messaggi Hello.</span><span class="sxs-lookup"><span data-stu-id="a729a-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="a729a-235">Un messaggio finale non crittografato denominato ChangeCipherSpec viene inviato sia dal client che dal server per indicare che tutti gli altri messaggi verranno crittografati.</span><span class="sxs-lookup"><span data-stu-id="a729a-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="a729a-236">Il primo messaggio crittografato inviato sia dal client che dal server è anche il messaggio di handshake TLS finale, denominato completato.</span><span class="sxs-lookup"><span data-stu-id="a729a-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="a729a-237">Questo messaggio contiene un hash di tutti i messaggi di handshake ricevuti e inviati.</span><span class="sxs-lookup"><span data-stu-id="a729a-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="a729a-238">Questo hash viene utilizzato per verificare che nessuno dei messaggi nell'handshake sia stato alterato o danneggiato (che indica una possibile violazione della sicurezza).</span><span class="sxs-lookup"><span data-stu-id="a729a-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="a729a-239">Dopo la ricezione dei messaggi finiti e la verifica degli hash di handshake, la sessione TLS viene avviata e l'applicazione inizia a inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="a729a-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="a729a-240">Per la prima volta viene eseguito l'hashing di tutti i dati inviati da entrambi i lati durante la sessione TLS utilizzando l'algoritmo hash scelto nei messaggi Hello (per fornire l'integrità del messaggio) e crittografato utilizzando l'algoritmo di chiave privata scelto con le chiavi di sessione generate.</span><span class="sxs-lookup"><span data-stu-id="a729a-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="a729a-241">Infine, una sessione TLS può essere conclusa correttamente solo se il client o il server sceglie di eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="a729a-242">Una sessione troncata è considerata una violazione della sicurezza (poiché un utente malintenzionato potrebbe tentare di impedire la ricezione di tutti i dati), quindi viene inviata una notifica speciale quando uno dei due lati desidera terminare la sessione, denominata avviso CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="a729a-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="a729a-243">Sia il client che il server devono inviare ed elaborare un avviso CloseNotify per un arresto corretto della sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagramma di un handshake TLS tipico.](media/image4.png)

<span data-ttu-id="a729a-245">Figura 3-handshake TLS tipico</span><span class="sxs-lookup"><span data-stu-id="a729a-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="a729a-246">Handshake TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="a729a-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="a729a-247">TLS 1,3 è una revisione piuttosto importante del protocollo TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="a729a-248">La maggior parte delle modifiche è stata apportata all'handshake per migliorare la sicurezza e le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="a729a-249">Un handshake TLS 1,3 tipico è illustrato nella figura 4.</span><span class="sxs-lookup"><span data-stu-id="a729a-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="a729a-250">La differenza principale si può notare nel numero di scambi tra il server e il client.</span><span class="sxs-lookup"><span data-stu-id="a729a-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="a729a-251">In TLS 1,2 e versioni precedenti, il server invia due voli<sup>12</sup> di messaggi, prima ServerHello e poi un messaggio ChangeCipherSpec prima di inviare il messaggio crittografato terminato che termina l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="a729a-252">In TLS 1,3 il server invia tutti gli elementi del primo volo, ovvero ServerHello, Extensions, certificate e fine.</span><span class="sxs-lookup"><span data-stu-id="a729a-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="a729a-253">Il messaggio ChangeCipherSpec è stato eliminato e il server genera le chiavi di sessione e avvia la crittografia dei messaggi di handshake immediatamente dopo ServerHello.</span><span class="sxs-lookup"><span data-stu-id="a729a-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="a729a-254">La nuova disposizione significa che l'handshake TLS è protetto dalla crittografia, limitando la quantità di dati di testo non crittografato a cui un utente malintenzionato può accedere.</span><span class="sxs-lookup"><span data-stu-id="a729a-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="a729a-255">Inoltre, la rimozione del secondo volo del server (che era solo un ChangeCipherSpec seguito da un termine) significa che un client TLS non deve più attendere per iniziare a trasmettere i dati dell'applicazione: non appena il client invia il proprio messaggio terminato, la sessione viene avviata.</span><span class="sxs-lookup"><span data-stu-id="a729a-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="a729a-256">Un volo è semplicemente una raccolta di messaggi TLS inviati simultaneamente in un gruppo.</span><span class="sxs-lookup"><span data-stu-id="a729a-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Diagramma di un handshake TLS 1,3.](media/image5.png)

<span data-ttu-id="a729a-258">Figura 4: handshake TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="a729a-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="a729a-259">*In TLS 1,3 è stata introdotta anche la nozione di "dati anticipati" e 0-RTT (tempo di round trip zero), il che significa che alcuni dati dell'applicazione possono essere inviati nel primo volo di messaggi. Questa funzionalità facoltativa è stata aggiunta principalmente come ottimizzazione per la velocità di risposta del Web browser, ad esempio per inviare intestazioni HTTP iniziali per avviare il rendering di una pagina. A partire da Azure RTO 6,0 questa funzionalità non è supportata.*</span><span class="sxs-lookup"><span data-stu-id="a729a-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="a729a-260">Inizializzazione</span><span class="sxs-lookup"><span data-stu-id="a729a-260">Initialization</span></span>

<span data-ttu-id="a729a-261">Lo stack TCP/IP NetX o NetXDuo deve essere inizializzato prima di usare NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="a729a-262">Per informazioni su come inizializzare correttamente lo stack TCP/IP, vedere la guida dell'utente di NetX o NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="a729a-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="a729a-263">Una volta inizializzato lo stack TCP/IP di NetX, è possibile abilitare TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="a729a-264">Internamente, tutto il traffico di rete TLS e l'elaborazione vengono gestiti dallo stack NetX/NetXDuo senza richiedere l'intervento dell'utente.</span><span class="sxs-lookup"><span data-stu-id="a729a-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="a729a-265">Tuttavia, TLS prevede alcuni requisiti specifici che devono essere gestiti separatamente dallo stack di rete sottostante.</span><span class="sxs-lookup"><span data-stu-id="a729a-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="a729a-266">Questi parametri vengono assegnati al blocco di controllo TLS denominato \***NX_SECURE_TLS_SESSION** _ utilizzando il servizio _ \*_nx_secure_tls_session_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="a729a-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="a729a-267">In TLS sono disponibili due modalità, ovvero server e client, che possono essere abilitate in un'applicazione (ma solo una modalità per socket NetX), ognuna delle quali presenta requisiti specifici, descritti di seguito.</span><span class="sxs-lookup"><span data-stu-id="a729a-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="a729a-268">In entrambe le modalità, NetX Secure TLS richiede la creazione e la configurazione di un socket TCP (\***NX_TCP_SOCKET** _) per le comunicazioni TCP con l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="a729a-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="a729a-269">Il socket TCP viene assegnato a un'istanza della sessione TLS con il servizio _ \*_nx_secure_tls_session_start_\*\*, descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="a729a-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="a729a-270">Inizializzazione-server TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-270">Initialization – TLS Server</span></span>

<span data-ttu-id="a729a-271">Oltre a un socket TCP, la modalità server TLS sicuro NetX richiede un *certificato digitale*, ovvero un documento usato per identificare il server TLS per il client TLS connesso e la *chiave privata* corrispondente dei certificati, in genere per l'algoritmo di crittografia RSA.</span><span class="sxs-lookup"><span data-stu-id="a729a-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="a729a-272">Lo standard International Telecommunications Union X. 509 specifica il formato del certificato usato da TLS e sono disponibili numerose utilità per la creazione di certificati digitali X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="a729a-273">Per NetX Secure TLS, il certificato X. 509 deve essere codificato in formato binario usando il formato Distinguished Encoding Rules (DER) di ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="a729a-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="a729a-274">DER è il formato binario standard TLS in transito per i certificati.</span><span class="sxs-lookup"><span data-stu-id="a729a-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="a729a-275">La chiave privata associata al certificato specificato deve essere in formato DER-Encoded PKCS # 1.</span><span class="sxs-lookup"><span data-stu-id="a729a-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="a729a-276">La chiave privata viene usata solo sul dispositivo e non verrà mai trasmessa in rete.</span><span class="sxs-lookup"><span data-stu-id="a729a-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="a729a-277">Mantieni le chiavi private sicure perché forniscono la sicurezza per le comunicazioni TLS!</span><span class="sxs-lookup"><span data-stu-id="a729a-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="a729a-278">Per inizializzare il certificato del server TLS, l'applicazione deve fornire un puntatore a un buffer che contiene il certificato X. 509 con codifica der e i dati facoltativi della chiave privata RSA con codifica DER PKCS # 1 usando il servizio ***nx_secure_x509_certificate_intialize** _, che popola la struttura _ *NX_SECURE_X509_CERT** con i dati del certificato appropriati per l'uso da parte di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="a729a-279">Una volta inizializzato, il certificato del server deve essere aggiunto al blocco di controllo TLS utilizzando il servizio ***nx_secure_tls_local_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="a729a-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="a729a-280">Una volta che il certificato del server è stato aggiunto al blocco di controllo TLS, il socket può essere usato per stabilire una connessione al server TLS sicura.</span><span class="sxs-lookup"><span data-stu-id="a729a-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="a729a-281">Inizializzazione-client TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-281">Initialization – TLS Client</span></span>

<span data-ttu-id="a729a-282">La modalità client TLS sicura di NetX richiede un *archivio certificati attendibile*, ovvero una raccolta di certificati digitali con codifica X. 509 provenienti da autorità di certificazione attendibili (CA).</span><span class="sxs-lookup"><span data-stu-id="a729a-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="a729a-283">Questi certificati vengono considerati attendibili dal protocollo TLS e vengono usati come base per l'autenticazione dei certificati forniti dalle entità server TLS per il client TLS sicuro NetX.</span><span class="sxs-lookup"><span data-stu-id="a729a-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="a729a-284">Un certificato CA attendibile può essere *autofirmato* o firmato da un'altra CA, nel qual caso il certificato viene definito *CA intermedia* (ICA).</span><span class="sxs-lookup"><span data-stu-id="a729a-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="a729a-285">In una tipica applicazione TLS, il server fornisce i certificati ICA insieme al certificato del server, ma l'unico requisito per la corretta autenticazione è che una catena di autorità emittenti (certificati usati per firmare altri certificati) può essere ritracciata dal certificato del server a un certificato CA attendibile nell'archivio certificati attendibili.</span><span class="sxs-lookup"><span data-stu-id="a729a-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="a729a-286">Questa catena è nota come  *catena di attendibilità* o *catena di certificati*.</span><span class="sxs-lookup"><span data-stu-id="a729a-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="a729a-287">Per inizializzare una CA attendibile o un certificato ICA, l'applicazione deve fornire un puntatore a un buffer contenente il certificato X. 509 con codifica DER usando il servizio ***nx_secure_x509_certificate_intialize** _, che popola la struttura _ *NX_SECURE_X509_CERT** con i dati del certificato appropriati per l'uso da parte di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="a729a-288">I certificati attendibili che sono stati inizializzati vengono quindi aggiunti al blocco di controllo TLS utilizzando il servizio ***nx_secure_tls_trusted_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="a729a-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="a729a-289">Se non si aggiunge un certificato, la sessione client TLS non riuscirà perché il protocollo TLS non potrà autenticare gli host server TLS remoti.</span><span class="sxs-lookup"><span data-stu-id="a729a-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="a729a-290">Il client TLS necessita inoltre di spazio per l'allocazione del certificato del server in ingresso (presupponendo che non venga utilizzata una modalità di chiave pre-condivisa).</span><span class="sxs-lookup"><span data-stu-id="a729a-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="a729a-291">A partire da NetX Secure TLS 5,12, non è più necessario che l'applicazione allochi spazio per il certificato remoto.</span><span class="sxs-lookup"><span data-stu-id="a729a-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="a729a-292">Tuttavia, l'opzione legacy per allocare spazio per un certificato del server è ancora disponibile e i certificati allocati dall'utente verranno utilizzati prima dell'ottimizzazione del buffer del certificato interno <sup>13</sup> . per ulteriori informazioni, vedere il servizio ***nx_secure_tls_remote_certificate_allocate*** .</span><span class="sxs-lookup"><span data-stu-id="a729a-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="a729a-293">Una volta che l'archivio certificati attendibile è stato creato e lo spazio per il certificato server è stato allocato, il socket può essere usato per stabilire una connessione client TLS sicura.</span><span class="sxs-lookup"><span data-stu-id="a729a-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="a729a-294">L'ottimizzazione utilizza il "buffer di pacchetti" fornito dall'applicazione utente alla sessione TLS utilizzando *nx_secure_tls_session_packet_buffer_set* per allocare le strutture di analisi X. 509 anziché utilizzare le strutture fornite dall'utente utilizzate nelle versioni precedenti di NETX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="a729a-295">È probabile che si verifichi una catena di certificati che supera la dimensione del buffer di pacchetti, in questo caso è possibile che le dimensioni del buffer dei pacchetti siano aumentate oppure che sia possibile utilizzare *nx_secure_tls _remote_certificate_allocate* per allocare più spazio per la catena di certificati.</span><span class="sxs-lookup"><span data-stu-id="a729a-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="a729a-296">Chiamate dell'interfaccia dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="a729a-296">Application Interface Calls</span></span>

<span data-ttu-id="a729a-297">Le applicazioni TLS protette NetX in genere eseguono chiamate di funzione dall'interno dei thread dell'applicazione in esecuzione in ThreadX RTO.</span><span class="sxs-lookup"><span data-stu-id="a729a-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="a729a-298">Alcune inizializzazioni, in particolare per i protocolli di comunicazione di rete sottostanti (ad esempio TCP e IP), possono essere chiamate da \*\**tx_application_define *.**</span><span class="sxs-lookup"><span data-stu-id="a729a-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="a729a-299">Per ulteriori informazioni sull'inizializzazione delle comunicazioni di rete, vedere il manuale dell'utente di NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="a729a-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="a729a-300">TLS usa in modo intensivo le routine di crittografia che sono operazioni che richiedono un utilizzo intensivo del processore.</span><span class="sxs-lookup"><span data-stu-id="a729a-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="a729a-301">In genere, queste operazioni verranno eseguite nel contesto del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="a729a-302">Avvio sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-302">TLS Session Start</span></span>

<span data-ttu-id="a729a-303">Per il funzionamento di TLS è necessario un protocollo di rete a livello di trasporto sottostante.</span><span class="sxs-lookup"><span data-stu-id="a729a-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="a729a-304">Il protocollo usato in genere è TCP.</span><span class="sxs-lookup"><span data-stu-id="a729a-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="a729a-305">Per stabilire una sessione TLS sicura NetX, è necessario stabilire una connessione TCP usando l'API TCP NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="a729a-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="a729a-306">È necessario creare un **NX_TCP_SOCKET** e una connessione stabilita usando i **_Servizi nx_tcp_server_socket_listen_*_ e _*_nx_tcp_server_socket_accept_*_ (per il server TLS) o il servizio _*_nx_tcp_client_socket_connect_** (per il client TLS).</span><span class="sxs-lookup"><span data-stu-id="a729a-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="a729a-307">Una volta stabilita una connessione TCP, il socket TCP viene quindi passato al servizio ***nx_secure_tls_session_start*** .</span><span class="sxs-lookup"><span data-stu-id="a729a-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="a729a-308">Allocazione pacchetti TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-308">TLS Packet Allocation</span></span>

<span data-ttu-id="a729a-309">NetX Secure TLS usa la stessa struttura di pacchetti di NetX/NetXDuo TCP (***NX_PACKET** _) ad eccezione del fatto che anziché chiamare il servizio _*_nx_packet_allocate_*_ , è necessario chiamare il servizio _ *_nx_secure_tls_packet_allocate_** in modo che lo spazio per l'intestazione TLS possa essere allocato correttamente.</span><span class="sxs-lookup"><span data-stu-id="a729a-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="a729a-310">Invio sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-310">TLS Session Send</span></span>

<span data-ttu-id="a729a-311">Una volta avviata la sessione TLS, l'applicazione può inviare dati utilizzando il servizio \***nx_secure_tls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="a729a-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="a729a-312">Il servizio di invio è identico in uso con il servizio _*_nx_tcp_socket_send_*_ , accettando una struttura di dati _*_NX_PACKET_*_ contenente i dati inviati, solo i dati verranno crittografati dallo stack di TLS sicuro NX prima di essere inviati e il pacchetto deve essere allocato usando _ *_nx_secure_tls_packet_allocate_* \*.</span><span class="sxs-lookup"><span data-stu-id="a729a-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="a729a-313">Ricezione sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-313">TLS Session Receive</span></span>

<span data-ttu-id="a729a-314">Una volta avviata la sessione TLS, l'applicazione può iniziare a ricevere dati utilizzando il servizio \***nx_secure_tls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="a729a-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="a729a-315">Analogamente all'invio della sessione TLS, questo servizio è identico a _ *_nx_tcp_socket_receive_* \*, ad eccezione del fatto che i dati in ingresso vengono decrittografati e verificati dallo stack TLS prima di essere restituiti nella struttura del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="a729a-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="a729a-316">Chiusura sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-316">TLS Session Close</span></span>

<span data-ttu-id="a729a-317">Una volta completata la sessione TLS, sia il client che il server TLS devono inviare un avviso CloseNotify all'altro lato per arrestare la sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="a729a-318">Entrambi i lati devono ricevere ed elaborare l'avviso per garantire una corretta chiusura della sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="a729a-319">Se l'host remoto invia un avviso CloseNotify, tutte le chiamate al servizio \***nx_secure_tls_session_receive** _ elaborerà l'avviso, invierà l'avviso corrispondente all'host remoto e restituirà il valore _ *_NX_SECURE_TLS_SESSION_CLOSED_* \*.</span><span class="sxs-lookup"><span data-stu-id="a729a-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="a729a-320">Una volta chiusa la sessione, eventuali ulteriori tentativi di inviare o ricevere dati con tale sessione TLS avranno esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="a729a-321">Se l'applicazione desidera chiudere la sessione TLS, il servizio \***nx_secure_tls_session_end** _ deve essere chiamato.</span><span class="sxs-lookup"><span data-stu-id="a729a-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="a729a-322">Il servizio invierà l'avviso CloseNotify ed elaborerà la risposta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="a729a-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="a729a-323">Se la risposta non viene ricevuta, viene restituito un valore di errore _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, che indica che la sessione TLS non è stata arrestata in modo corretto, una possibile violazione della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="a729a-324">Avvisi TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-324">TLS Alerts</span></span>

<span data-ttu-id="a729a-325">TLS è progettato per garantire la massima sicurezza, quindi qualsiasi comportamento errato nel protocollo viene considerato una potenziale violazione della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="a729a-326">Per questo motivo, gli eventuali errori di elaborazione dei messaggi o di crittografia/decrittografia sono considerati errori irreversibili che terminano immediatamente l'handshake o la sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="a729a-327">Anche se la gestione degli errori in un'applicazione locale è relativamente semplice, l'host remoto deve essere in grado di rilevare che si è verificato un errore per gestire correttamente la situazione ed evitare ulteriori possibili violazioni della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="a729a-328">Per questo motivo, TLS invierà un messaggio di *avviso* all'host remoto su qualsiasi errore.</span><span class="sxs-lookup"><span data-stu-id="a729a-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="a729a-329">Gli avvisi vengono gestiti in modo analogo a qualsiasi altro messaggio TLS e vengono crittografati durante la sessione per impedire a un utente malintenzionato di raccogliere informazioni dal tipo di avviso fornito.</span><span class="sxs-lookup"><span data-stu-id="a729a-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="a729a-330">Durante l'handshake, gli avvisi inviati hanno un ambito limitato per limitare la quantità di informazioni che possono essere ottenute da un potenziale utente malintenzionato.</span><span class="sxs-lookup"><span data-stu-id="a729a-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="a729a-331">L'avviso CloseNotify, usato per chiudere la sessione TLS, è l'unico avviso non irreversibile.</span><span class="sxs-lookup"><span data-stu-id="a729a-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="a729a-332">Sebbene venga considerato un avviso e venga inviato come messaggio di avviso, un CloseNotify è diverso dagli altri avvisi in quanto non indica che si è verificato un errore.</span><span class="sxs-lookup"><span data-stu-id="a729a-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="a729a-333">Il valore di avviso e il "livello" (i livelli sono "avviso" e "irreversibile": la maggior parte degli avvisi TLS sono "irreversibili") sono definiti nelle RFC di TLS e indicano il tipo di errore che si è verificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="a729a-334">La maggior parte degli avvisi TLS diversi da CloseNotify può essere considerata un'indicazione di un potenziale problema di sicurezza e comporterà l'interruzione della sessione TLS o dell'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="a729a-335">Se una chiamata API TLS restituisce **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), il servizio API **_nx_secure_tls_session_alert_value_get_** (nuovo in NetX Secure TLS versione 5,12) può essere usato per recuperare il valore e il livello di avviso TLS per l'applicazione da usare per le decisioni relative alle risposte ai problemi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="a729a-336">Nella maggior parte dei casi, qualsiasi avviso ricevuto dall'host remoto diverso da CloseNotify deve essere considerato un errore irreversibile, sebbene esistano alcuni excptions: per altre informazioni, vedere le RFC di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="a729a-337">Rinegoziazione della sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="a729a-338">TLS supporta la nozione di "rinegoziazione", che è semplicemente una rinegoziazione dei parametri della sessione TLS all'interno del contesto di una sessione TLS esistente.</span><span class="sxs-lookup"><span data-stu-id="a729a-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="a729a-339">Ciò significa che, in pratica, i nuovi messaggi di handshake vengono crittografati e autenticati utilizzando la sessione esistente.</span><span class="sxs-lookup"><span data-stu-id="a729a-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="a729a-340">Il rinegoziazione viene usato quando un host TLS vuole generare nuovi parametri di sessione (ad esempio, generare nuove chiavi di sessione TLS) senza dover completare la sessione esistente.</span><span class="sxs-lookup"><span data-stu-id="a729a-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="a729a-341">Ad esempio, la rinegoziazione potrebbe essere auspicabile quando i criteri di sicurezza per un'applicazione stabiliscono che le chiavi di sessione vengono usate solo per un periodo di tempo limitato, ma una sessione TLS rimane attiva dopo tale periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="a729a-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="a729a-342">Un problema con la rinegoziazione della sessione è che rende TLS vulnerabile a un attacco man-in-the-Middle specifico in cui un utente malintenzionato può convincere un server ad avviare una rinegoziazione con nuovi parametri, consentendo così all'autore dell'attacco di eseguire il Hijack della sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="a729a-343">Per attenuare questo problema, è stata introdotta l'estensione dell'indicazione di rinegoziazione sicura (vedere la sezione **Error). Origine riferimento non trovata.**</span><span class="sxs-lookup"><span data-stu-id="a729a-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="a729a-344">sezione).</span><span class="sxs-lookup"><span data-stu-id="a729a-344">section).</span></span>

<span data-ttu-id="a729a-345">NetX Secure TLS supporta completamente il rinegoziazione delle sessioni e l'estensione per l'indicazione di rinegoziazione sicura.</span><span class="sxs-lookup"><span data-stu-id="a729a-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="a729a-346">Quando si ricevono dati da un host remoto, renegotations (e l'estensione) vengono gestiti automaticamente senza interazione tra le applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="a729a-347">Se si desidera una notifica sulle rinegoziazioni della sessione, è possibile fornire un callback di rinegoziazione con il servizio *nx_secure_tls_session_renegotiate_callback_set* .</span><span class="sxs-lookup"><span data-stu-id="a729a-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="a729a-348">Il callback verrà richiamato ogni volta che una rinegoziazione viene richiesta dall'host remoto, consentendo all'applicazione di eseguire l'azione, se necessario.</span><span class="sxs-lookup"><span data-stu-id="a729a-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="a729a-349">Per avviare una rinegoziazione da una sessione TLS attiva, è sufficiente richiamare il servizio *nx_secure_tls_session_renegotiate* nella sessione TLS desiderata.</span><span class="sxs-lookup"><span data-stu-id="a729a-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="a729a-350">Ripresa della sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-350">TLS Session Resumption</span></span>

<span data-ttu-id="a729a-351">La ripresa della sessione TLS non può essere confusa con la rinegoziazione della sessione, nonostante alcune analogie.</span><span class="sxs-lookup"><span data-stu-id="a729a-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="a729a-352">Quando la *rinegoziazione* della sessione comporta l'avvio di un nuovo handshake in una sessione TLS esistente, la *ripresa* della sessione è una funzionalità puramente facoltativa che prevede il riavvio di una sessione TLS chiusa senza eseguire un handshake TLS completo.</span><span class="sxs-lookup"><span data-stu-id="a729a-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="a729a-353">A tale scopo, un'implementazione di TLS può memorizzare nella cache i parametri e le chiavi della sessione, associando questi ultimi a un *ID di sessione,* un identificatore univoco fornito nell'handshake originale.</span><span class="sxs-lookup"><span data-stu-id="a729a-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="a729a-354">Fornendo un ID di sessione a un server TLS, un client indica che una sessione TLS precedente tra gli host esisteva e è stata completata in passato e che il client possiede ancora lo stato per ristabilire la sessione con un handshake ridotto.</span><span class="sxs-lookup"><span data-stu-id="a729a-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="a729a-355">Poiché le chiavi della sessione sono teoricamente ancora segrete e sono note solo dai due host che comunicano, il server può avviare una nuova sessione TLS e ignorare la maggior parte dell'handshake normale.</span><span class="sxs-lookup"><span data-stu-id="a729a-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="a729a-356">La ripresa della sessione può essere utile per evitare le operazioni di chiave pubblica potenzialmente costose usate per condividere la generazione di chiavi master secret e verificare le firme del certificato, ma richiede anche che i parametri della sessione, le chiavi e lo stato di crypotgraphic vengano mantenuti in memoria per tutte le sessioni possibili (almeno per un intervallo di tempo configurabile).</span><span class="sxs-lookup"><span data-stu-id="a729a-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="a729a-357">La versione corrente di NetX Secure TLS non supporta la ripresa della sessione: l'ID di sessione viene semplicemente ignorato dai server TLS e i client TLS forniscono sempre un ID di sessione NULL che richiede al server di eseguire un handshake completo.</span><span class="sxs-lookup"><span data-stu-id="a729a-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="a729a-358">La mancanza di ripresa della sessione non dovrebbe causare problemi di interoperabilità poiché si tratta di una funzionalità completamente facoltativa e tutte le implementazioni di TLS devono avere come valore predefinito un handshake completo se l'ID sessione è NULL o non riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="a729a-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="a729a-359">Layering del protocollo</span><span class="sxs-lookup"><span data-stu-id="a729a-359">Protocol Layering</span></span>

<span data-ttu-id="a729a-360">Il protocollo TLS si inserisce nello stack di rete tra il livello di trasporto (ad esempio TCP) e il livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="a729a-361">TLS viene a volte considerato un protocollo di livello trasporto, di conseguenza la sicurezza a *livello di trasporto* , ma poiché funge da applicazione per quanto riguarda i protocolli di rete sottostanti (ad esempio TCP), viene talvolta raggruppato nel livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="a729a-362">TLS richiede un protocollo di livello trasporto che supporta il recapito in ordine e senza perdita di contenuti, ad esempio TCP.</span><span class="sxs-lookup"><span data-stu-id="a729a-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="a729a-363">A causa di questo requisito, TLS non può essere eseguito su UDP Poiché UDP non garantisce il recapito di datagrammi.</span><span class="sxs-lookup"><span data-stu-id="a729a-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="a729a-364">Un protocollo separato denominato *DTLS,* che è una versione modificata di TLS, viene usato per le applicazioni che richiedono la sicurezza di TLS su un protocollo di datagramma come UDP.</span><span class="sxs-lookup"><span data-stu-id="a729a-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="a729a-365">NetX Secure supporta DTLS, ma la documentazione per DTLS è separata da questo documento.</span><span class="sxs-lookup"><span data-stu-id="a729a-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Diagramma dei livelli di protocollo TCP/IP e TLS.](media/image6.png)

<span data-ttu-id="a729a-367">Figura 5-livelli di protocollo TCP/IP e TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="a729a-368">Sicurezza delle comunicazioni di rete</span><span class="sxs-lookup"><span data-stu-id="a729a-368">Network Communications Security</span></span>

<span data-ttu-id="a729a-369">La protezione delle comunicazioni tramite reti pubbliche e Internet è un argomento di importanza critica e l'oggetto di un ampio numero di libri, articoli e soluzioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="a729a-370">Questo argomento è molto complesso, ma può essere ridotto a una semplice idea: invio di informazioni su una rete, in modo che solo la destinazione prevista possa accedere o modificare tali informazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="a729a-371">Questa operazione suddivide in tre concetti importanti: segretezza, integrità e autenticazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="a729a-372">Il protocollo TLS fornisce soluzioni per tutti e tre.</span><span class="sxs-lookup"><span data-stu-id="a729a-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="a729a-373">Secrecy</span><span class="sxs-lookup"><span data-stu-id="a729a-373">Secrecy</span></span>

<span data-ttu-id="a729a-374">Quando si inviano dati su una rete, è spesso importante che i dati non possano essere ottenuti da un'entità dannosa.</span><span class="sxs-lookup"><span data-stu-id="a729a-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="a729a-375">Se i dati vengono inviati tramite una connessione TCP/IP, tutti gli utenti con accesso alla rete saranno in grado di leggere i dati utilizzando gli strumenti di rete facilmente disponibili.</span><span class="sxs-lookup"><span data-stu-id="a729a-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="a729a-376">Per impedire che i dati vengano ottenuti, devono essere codificati in modo che non possano essere letti, tranne che dalla destinazione prevista, ma si tratta di un *segreto.*</span><span class="sxs-lookup"><span data-stu-id="a729a-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="a729a-377">In TLS gli algoritmi di crittografia, ad esempio RSA e AES, forniscono la riservatezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="a729a-378">Integrità</span><span class="sxs-lookup"><span data-stu-id="a729a-378">Integrity</span></span>

<span data-ttu-id="a729a-379">In alcuni casi, la segretezza non è sufficiente per proteggere i dati in transito in una rete.</span><span class="sxs-lookup"><span data-stu-id="a729a-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="a729a-380">In alcuni casi, potrebbe essere possibile che un'entità dannosa modifichi il contenuto di un pacchetto TCP senza che sia necessario sapere cosa contiene il pacchetto.</span><span class="sxs-lookup"><span data-stu-id="a729a-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="a729a-381">I dati crittografati possono essere modificati, il rendering della decrittografia non è valido o la modifica dei parametri del messaggio che portano a qualsiasi risultato che l'utente malintenzionato potrebbe essere interessato al raggiungimento.</span><span class="sxs-lookup"><span data-stu-id="a729a-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="a729a-382">In rete non è possibile impedire a un utente malintenzionato di modificare i dati in transito, ma è possibile fornire un meccanismo per sapere se i dati sono stati modificati o meno.</span><span class="sxs-lookup"><span data-stu-id="a729a-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="a729a-383">Quando i dati vengono modificati durante il transito, saranno noti e i dati possono essere rifiutati.</span><span class="sxs-lookup"><span data-stu-id="a729a-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="a729a-384">Questo concetto è l' *integrità*.</span><span class="sxs-lookup"><span data-stu-id="a729a-384">This concept is *integrity*.</span></span> <span data-ttu-id="a729a-385">In TLS, l'integrità viene fornita da una classe di routine di crittografia note come *funzioni hash*.</span><span class="sxs-lookup"><span data-stu-id="a729a-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="a729a-386">Alcuni esempi di funzioni hash sono MD5 e SHA-1.</span><span class="sxs-lookup"><span data-stu-id="a729a-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="a729a-387">Authentication</span><span class="sxs-lookup"><span data-stu-id="a729a-387">Authentication</span></span>

<span data-ttu-id="a729a-388">Il terzo concetto importante nella sicurezza delle comunicazioni di rete è l'idea che i dati devono essere comunicati solo alla destinazione prevista.</span><span class="sxs-lookup"><span data-stu-id="a729a-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="a729a-389">Un utente malintenzionato può provare a rappresentare un'entità legittima per ricevere i dati destinati a un altro host.</span><span class="sxs-lookup"><span data-stu-id="a729a-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="a729a-390">Anche se i dati vengono inviati con meccanismi di riservatezza e integrità, l'utente malintenzionato potrebbe ancora essere in grado di ottenere il risultato desiderato (un compromesso di comunicazioni sicure) attraverso questa operazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="a729a-391">Per evitare questo problema, è necessario un meccanismo per dimostrare l'identità di un host remoto prima dell'invio di tutti i dati sensibili.</span><span class="sxs-lookup"><span data-stu-id="a729a-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="a729a-392">Il processo di dimostrazione dell'identità di un host remoto è l' *autenticazione.*</span><span class="sxs-lookup"><span data-stu-id="a729a-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="a729a-393">In TLS l'autenticazione viene fornita utilizzando certificati digitali, funzioni hash e un meccanismo denominato *firme digitali* che utilizza una proprietà della crittografia a chiave pubblica (descritta di seguito).</span><span class="sxs-lookup"><span data-stu-id="a729a-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="a729a-394">Con una *chiave precondivisa* (PSK) può essere fornita anche una forma di autenticazione limitata ma utile.</span><span class="sxs-lookup"><span data-stu-id="a729a-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="a729a-395">Crittografia TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-395">TLS Encryption</span></span>

<span data-ttu-id="a729a-396">Il protocollo TLS è un Framework per fornire comunicazioni di rete sicure su Internet usando la crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="a729a-397">La crittografia viene in genere definita come il processo di codifica dei dati in modo che il recupero dei dati originali (o informazioni sui dati) sia estremamente difficile senza una *chiave*.</span><span class="sxs-lookup"><span data-stu-id="a729a-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="a729a-398">Nella crittografia dei sistemi informatici si basa su una matematica complessa, ad esempio campi finiti, che può essere classificata in due tipi: *chiave privata* (o *crittografia simmetrica*) e *chiave pubblica* (o *crittografia asimmetrica*).</span><span class="sxs-lookup"><span data-stu-id="a729a-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="a729a-399">Esempi di crittografia a chiave privata sono AES (Advanced Encryption Standard) e RC4 (riveste Cipher 4).</span><span class="sxs-lookup"><span data-stu-id="a729a-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="a729a-400">Esempi di crittografia a chiave pubblica sono RSA (Rivet, Shamir, Adleson) e Diffie-Hellman crittografie.</span><span class="sxs-lookup"><span data-stu-id="a729a-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="a729a-401">Il protocollo TLS usa le routine di crittografia della chiave privata e della chiave pubblica per fornire un equilibrio tra prestazioni, sicurezza e flessibilità.</span><span class="sxs-lookup"><span data-stu-id="a729a-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="a729a-402">Crittografia Private-Key</span><span class="sxs-lookup"><span data-stu-id="a729a-402">Private-Key Encryption</span></span>

<span data-ttu-id="a729a-403">La crittografia a chiave privata è stata usata per migliaia di anni.</span><span class="sxs-lookup"><span data-stu-id="a729a-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="a729a-404">Le crittografie di sostituzione di base, in cui una lettera o una parola viene sostituita da un'altra lettera o parola non correlata, sono i primi esempi noti di crittografia, ma con l'avvento delle informazioni Age la crittografia della chiave privata è stata notevolmente migliorata.</span><span class="sxs-lookup"><span data-stu-id="a729a-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="a729a-405">Una crittografia a chiave privata usa una "chiave" che è semplicemente un valore (che potrebbe essere una parola, una frase o un numero nel caso generale) usato per codificare alcuni dati in modo che solo un'entità con accesso a tale chiave possa decodificare i dati in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="a729a-406">La chiave viene usata sia per la crittografia che per la decrittografia dei dati, di conseguenza l'altro nome della *crittografia simmetrica*.</span><span class="sxs-lookup"><span data-stu-id="a729a-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="a729a-407">La crittografia a chiave privata è in genere rapida e abbastanza semplice da implementare, anche se la matematica è molto complessa.</span><span class="sxs-lookup"><span data-stu-id="a729a-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="a729a-408">Per questo motivo, TLS usa la crittografia a chiave privata per la maggior parte delle comunicazioni protette.</span><span class="sxs-lookup"><span data-stu-id="a729a-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="a729a-409">Tuttavia, la crittografia a chiave privata presenta un problema quando si tenta di applicarla alle comunicazioni di rete del computer generale: la chiave deve essere condivisa tra entrambi i computer che tentano di comunicare.</span><span class="sxs-lookup"><span data-stu-id="a729a-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="a729a-410">In generale, non è pratico e spesso non è possibile comunicare una chiave privata in modo sicuro tra due computer su Internet, in quanto è possibile ipotizzare che il traffico di rete possa essere ottenuto da un numero qualsiasi di entità nei vari hop che i dati prendono quando vengono instradati attraverso Internet.</span><span class="sxs-lookup"><span data-stu-id="a729a-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="a729a-411">Se la chiave viene ottenuta da un'entità dannosa, tutti i dati crittografati con tale chiave vengono compromessi.</span><span class="sxs-lookup"><span data-stu-id="a729a-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="a729a-412">Poiché la maggior parte dei computer su Internet dispone solo di una connessione di rete e non di un altro canale sicuro per le comunicazioni, l'invio di chiavi sulla rete equivale a inviare i dati non crittografati, senza alcuna sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="a729a-413">Per questo motivo, la crittografia a chiave privata non è sufficiente per implementare un protocollo di sicurezza per le comunicazioni di rete di uso generale.</span><span class="sxs-lookup"><span data-stu-id="a729a-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="a729a-414">Questo è il punto in cui la crittografia a chiave pubblica può essere utile.</span><span class="sxs-lookup"><span data-stu-id="a729a-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="a729a-415">NetX Secure TLS supporta la crittografia a chiave privata AES.</span><span class="sxs-lookup"><span data-stu-id="a729a-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="a729a-416">Crittografia a chiave pubblica</span><span class="sxs-lookup"><span data-stu-id="a729a-416">Public-Key Encryption</span></span>

<span data-ttu-id="a729a-417">A differenza della crittografia a chiave privata, la crittografia a chiave pubblica è un concetto piuttosto nuovo, che è stato sviluppato nel 1970.</span><span class="sxs-lookup"><span data-stu-id="a729a-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="a729a-418">Usando un concetto noto come "funzioni trap-door" in matematica, è stato rilevato che era disponibile un modo per condividere una chiave in una rete senza compromettere la sicurezza dei dati crittografati.</span><span class="sxs-lookup"><span data-stu-id="a729a-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="a729a-419">Il modo in cui funziona la crittografia a chiave pubblica è che la chiave, nel senso della crittografia a chiave privata descritta in precedenza, è suddivisa in due parti, una *chiave privata* e una *chiave pubblica*, da cui la crittografia a chiave pubblica ne ottiene il nome.</span><span class="sxs-lookup"><span data-stu-id="a729a-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="a729a-420">Il concetto è che una di queste chiavi, in genere la chiave pubblica, viene utilizzata per la crittografia, mentre l'altra viene utilizzata per la decrittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="a729a-421">Questa asimmetria di chiavi è il motivo dell'altro nome della crittografia a chiave pubblica: *crittografia asimmetrica*.</span><span class="sxs-lookup"><span data-stu-id="a729a-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="a729a-422">La matematica dietro la crittografia a chiave pubblica è piuttosto complessa, ma l'idea è che la chiave pubblica può essere usata *solo* per la crittografia e il recupero di tale chiave non consente di ottenere i dati crittografati.</span><span class="sxs-lookup"><span data-stu-id="a729a-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="a729a-423">La chiave privata, a sua volta, è l'unico modo per decrittografare i dati crittografati con la chiave pubblica.</span><span class="sxs-lookup"><span data-stu-id="a729a-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="a729a-424">Quindi, mantenendo il segreto della chiave privata, chiunque voglia comunicare in modo sicuro con il proprietario della chiave privata deve solo crittografare i propri dati con la chiave pubblica corrispondente con la certezza che solo un utente che possiede la chiave privata possa ottenere i dati protetti.</span><span class="sxs-lookup"><span data-stu-id="a729a-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="a729a-425">NetX Secure TLS supporta la crittografia a chiave pubblica RSA.</span><span class="sxs-lookup"><span data-stu-id="a729a-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="a729a-426">*RSA è un'operazione che richiede un utilizzo intensivo del processore se viene utilizzata l'implementazione del software RSA. Dimensioni maggiori delle chiavi aumentano la potenza di elaborazione richiesta da un fattore quadrato-4X più lento per un aumento di 2X della dimensione della chiave.*</span><span class="sxs-lookup"><span data-stu-id="a729a-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="a729a-427">Autenticazione Public-Key</span><span class="sxs-lookup"><span data-stu-id="a729a-427">Public-Key Authentication</span></span>

<span data-ttu-id="a729a-428">Un effetto collaterale interessante del concetto di crittografia a chiave pubblica è che può essere usato per fornire l'autenticazione e la crittografia eseguendo l'operazione in ordine inverso: la crittografia con la chiave *privata* e la decrittografia tramite la chiave *pubblica* .</span><span class="sxs-lookup"><span data-stu-id="a729a-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="a729a-429">Il meccanismo effettivo per eseguire questa operazione dipende dall'algoritmo a chiave pubblica usato, ma il concetto è lo stesso.</span><span class="sxs-lookup"><span data-stu-id="a729a-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="a729a-430">Per eseguire l'autenticazione usando l'autenticazione con chiave pubblica, il proprietario di una chiave privata crittografa alcuni dati (in genere un hash crittografico dei dati da autenticare) usando tale chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="a729a-431">Quindi, un utente che desidera autenticare che i dati provenienti dal proprietario della chiave privata utilizza la chiave pubblica associata per decrittografare i dati, se la decrittografia ha esito positivo e supponendo che l'utente abbia considerato attendibile la validità della chiave pubblica, può essere certo che i dati provengono dal proprietario della chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="a729a-432">In TLS l'autenticazione con chiave pubblica viene usata per verificare la validità di un certificato digitale fornito da un server TLS (e, facoltativamente, del client TLS) usando le chiavi pubbliche dell'archivio certificati attendibili.</span><span class="sxs-lookup"><span data-stu-id="a729a-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="a729a-433">Il certificato viene verificato rispetto a una chiave pubblica nell'archivio e i dati del certificato vengono usati per controllare l'identità del server.</span><span class="sxs-lookup"><span data-stu-id="a729a-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="a729a-434">NetX Secure TLS supporta l'autenticazione RSA.</span><span class="sxs-lookup"><span data-stu-id="a729a-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="a729a-435">Hashing crittografico</span><span class="sxs-lookup"><span data-stu-id="a729a-435">Cryptographic Hashing</span></span>

<span data-ttu-id="a729a-436">La crittografia non è l'unica operazione di crittografia utilizzata in TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="a729a-437">Per garantire l'integrità dei messaggi durante una sessione TLS, è necessario un checksum per garantire che il contenuto del messaggio non sia stato alterato.</span><span class="sxs-lookup"><span data-stu-id="a729a-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="a729a-438">Un semplice checksum (usato in TCP), tuttavia, non è sufficiente per garantire un livello di integrità accettabile, in quanto può essere facilmente sovvertito da un utente malintenzionato esperto.</span><span class="sxs-lookup"><span data-stu-id="a729a-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="a729a-439">Il meccanismo utilizzato da TLS per fornire l'integrità dei messaggi è noto come *hash crittografico*.</span><span class="sxs-lookup"><span data-stu-id="a729a-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="a729a-440">La crittografia è una codifica 1:1, ovvero la completezza dei dati originali può essere ottenuta dai dati crittografati.</span><span class="sxs-lookup"><span data-stu-id="a729a-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="a729a-441">Tuttavia, un hash esegue il mapping di una quantità arbitraria di dati in un valore a dimensione fissa, proprio come un checksum.</span><span class="sxs-lookup"><span data-stu-id="a729a-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="a729a-442">A differenza di un semplice checksum, un hash è progettato specificamente per ridurre i *conflitti*, in cui i dati di input diversi hanno come risultato lo stesso output.</span><span class="sxs-lookup"><span data-stu-id="a729a-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="a729a-443">Con un semplice checksum, se un bit viene capovolto da 1 a 0 e un altro bit da 0 a 1, il checksum è lo stesso.</span><span class="sxs-lookup"><span data-stu-id="a729a-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="a729a-444">Con un hash crittografico, l'output potrebbe variare in modo significativo, rendendo difficile per un utente malintenzionato modificare i dati con hash e fare in modo che l'operazione hash sui dati modificati restituisca comunque lo stesso valore (e quindi verificando erroneamente l'integrità dei dati).</span><span class="sxs-lookup"><span data-stu-id="a729a-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="a729a-445">TLS usa una serie di algoritmi hash diversi per garantire l'integrità dei messaggi, sia messaggi dell'applicazione che messaggi di controllo TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="a729a-446">Sono inclusi MD5, SHA-1 e SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a729a-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="a729a-447">NetX Secure TLS supporta l'hashing MD5, SHA-1 e SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a729a-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="a729a-448">Estensioni TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-448">TLS Extensions</span></span>

<span data-ttu-id="a729a-449">TLS fornisce una serie di estensioni che forniscono funzionalità aggiuntive per alcune applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="a729a-450">Queste estensioni vengono in genere inviate come parte dei messaggi ClientHello o ServerHello, indicando a un host remoto il desiderio di usare un'estensione o fornire dettagli aggiuntivi da usare per stabilire la sessione TLS sicura.</span><span class="sxs-lookup"><span data-stu-id="a729a-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="a729a-451">In generale, le estensioni forniscono parametri facoltativi a TLS all'inizio dell'handshake che guidano le operazioni di continuazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="a729a-452">Alcune estensioni richiedono l'input dell'applicazione o il processo decisionale, mentre altre vengono gestite automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a729a-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="a729a-453">La tabella seguente descrive le estensioni TLS attualmente supportate da NetX Secure TLS:</span><span class="sxs-lookup"><span data-stu-id="a729a-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="a729a-454">**Extension Name**</span><span class="sxs-lookup"><span data-stu-id="a729a-454">**Extension Name**</span></span>              | <span data-ttu-id="a729a-455">**Descrizione**</span><span class="sxs-lookup"><span data-stu-id="a729a-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="a729a-456">Indicazione di rinegoziazione sicura</span><span class="sxs-lookup"><span data-stu-id="a729a-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="a729a-457">Questa estensione mitiga una vulnerabilità degli attacchi man-in-the-Middle che può verificarsi durante un handshake di rinegoziazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="a729a-458">Indicazione nome server</span><span class="sxs-lookup"><span data-stu-id="a729a-458">Server Name Indication</span></span>          | <span data-ttu-id="a729a-459">Questa estensione consente a un client TLS di fornire un nome DNS specifico a un server TLS, consentendo al server di selezionare le credenziali corrette (si presuppone che il server disponga di più certificati di identità e di rete entryPoints).</span><span class="sxs-lookup"><span data-stu-id="a729a-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="a729a-460">Algoritmi di firma</span><span class="sxs-lookup"><span data-stu-id="a729a-460">Signature Algorithms</span></span>            | <span data-ttu-id="a729a-461">Questa estensione consente a un client TLS di fornire un elenco di algoritmi di firma e hash accettabili a un server TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="a729a-462">Panoramica delle estensioni TLS supportate</span><span class="sxs-lookup"><span data-stu-id="a729a-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="a729a-463">Indicazione di rinegoziazione sicura</span><span class="sxs-lookup"><span data-stu-id="a729a-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="a729a-464">TLS supporta la nozione di esecuzione di un handshake all'interno di una sessione TLS esistente, usando quindi la sessione stabilita per crittografare i messaggi di handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="a729a-465">Questo processo consente di ristabilire le chiavi della sessione di crittografia senza terminare la sessione TLS (vedere la sezione "rinegoziazione della sessione TLS").</span><span class="sxs-lookup"><span data-stu-id="a729a-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="a729a-466">Sfortunatamente, dopo che TLS ha usato la rinegoziazione per un certo periodo di tempo, è stata individuata una vulnerabilità a un attacco man-in-the-Middle che sfruttava la funzionalità di rinegoziazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="a729a-467">Per chiudere la vulnerabilità, è stata introdotta l'estensione per l'indicazione di rinegoziazione sicura.</span><span class="sxs-lookup"><span data-stu-id="a729a-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="a729a-468">In sostanza, l'estensione di rinegoziazione sicura utilizza l'hash dei messaggi completato dalla connessione stabilita per verificare che gli host originali partecipino all'handshake di rinegoziazione, in sostanza l'hash viene utilizzato come token di verifica nel presupposto che un utente malintenzionato non sia in grado di creare l'hash (che richiede l'accesso alle chiavi della sessione).</span><span class="sxs-lookup"><span data-stu-id="a729a-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="a729a-469">NetX Secure TLS gestisce automaticamente la rinegoziazione e usa l'estensione di rinegoziazione sicura per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="a729a-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="a729a-470">Non è necessaria alcuna interazione con l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="a729a-471">Indicazione nome server</span><span class="sxs-lookup"><span data-stu-id="a729a-471">Server Name Indication</span></span>

<span data-ttu-id="a729a-472">Durante l'handshake TLS, un client TLS prevede che un server remoto fornisca un certificato di identità in modo che il client possa autenticare il server.</span><span class="sxs-lookup"><span data-stu-id="a729a-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="a729a-473">In alcuni casi, tuttavia, un server fornirà più servizi diversi con server "virtuali" diversi, ognuno con identità univoche.</span><span class="sxs-lookup"><span data-stu-id="a729a-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="a729a-474">Nel caso di un singolo server con più identità, un client TLS può fornire un nome DNS specifico che verrà usato dal server per selezionare le credenziali appropriate, il meccanismo per fornire questo nome è l'estensione Indicazione nome server (SNI).</span><span class="sxs-lookup"><span data-stu-id="a729a-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="a729a-475">Per un'applicazione che usa l'estensione SNI, è necessaria una certa interazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="a729a-476">Per i client TLS, l'applicazione deve fornire un nome DNS da inviare al server remoto.</span><span class="sxs-lookup"><span data-stu-id="a729a-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="a729a-477">Per i server TLS, l'applicazione deve leggere il nome DNS dall'estensione e selezionare un certificato appropriato da inviare di nuovo al client.</span><span class="sxs-lookup"><span data-stu-id="a729a-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="a729a-478">Le sezioni seguenti forniscono informazioni più dettagliate su come usare l'estensione SNI in NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="a729a-479">Estensione SNI-client TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="a729a-480">Un client TLS sicuro NetX che desidera usare l'estensione SNI deve fornire un nome DNS a TLS da fornire durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="a729a-481">Questo nome deve essere inizializzato e fornito prima di avviare una sessione TLS poiché l'estensione viene inviata nel messaggio ClientHello che avvia il processo di handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="a729a-482">Il frammento di codice seguente illustra l'uso dell'estensione.</span><span class="sxs-lookup"><span data-stu-id="a729a-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="a729a-483">Innanzitutto, un oggetto NX_SECURE_X509_DNS_NAME viene inizializzato con il nome del server desiderato.</span><span class="sxs-lookup"><span data-stu-id="a729a-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="a729a-484">Quindi, prima di avviare la sessione TLS, il nome viene fornito a TLS usando l'API dell'estensione SNI.</span><span class="sxs-lookup"><span data-stu-id="a729a-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="a729a-485">Una volta impostato il nome, non è richiesta alcuna azione aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="a729a-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="a729a-486">Vedere le informazioni di riferimento sulle API nel capitolo 4</span><span class="sxs-lookup"><span data-stu-id="a729a-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="a729a-487">Descrizione dei servizi NetX Secure per ulteriori informazioni sulle singole funzioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="a729a-488">Estensione SNI-server TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="a729a-489">Sul lato server TLS, l'estensione SNI può essere elaborata dall'applicazione per selezionare le credenziali appropriate (ad esempio, certificate) da fornire al client remoto durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="a729a-490">A tale scopo, l'applicazione deve fornire un callback di sessione che viene richiamato dopo la ricezione di un messaggio ClientHello.</span><span class="sxs-lookup"><span data-stu-id="a729a-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="a729a-491">Il codice di esempio per l'API nx_secure_tls_session_server_callback_set (vedere la pagina 122) illustra l'analisi di un'estensione SNI in ingresso usando un callback del server.</span><span class="sxs-lookup"><span data-stu-id="a729a-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="a729a-492">In sostanza, il server TLS riceve un ClientHello e richiama il callback.</span><span class="sxs-lookup"><span data-stu-id="a729a-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="a729a-493">Quindi, l'applicazione usa l'API *nx_secure_tls_session_sni_extension_parse* per analizzare i dati dell'estensione forniti al callback per trovare l'estensione SNI e restituire il nome DNS specificato (si noti che l'estensione supporta solo un singolo nome DNS).</span><span class="sxs-lookup"><span data-stu-id="a729a-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="a729a-494">Una volta ottenuto il nome, l'applicazione lo usa per trovare e inviare il certificato di identità server appropriato (e la catena dell'emittente se applicabile).</span><span class="sxs-lookup"><span data-stu-id="a729a-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="a729a-495">Estensione degli algoritmi di firma</span><span class="sxs-lookup"><span data-stu-id="a729a-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="a729a-496">Questa estensione è specifica di TLS 1,2 e consente a un client TLS di fornire un elenco di coppie di algoritmi di firma e hash accettabili che sono accettabili per la generazione e la verifica delle firme digitali.</span><span class="sxs-lookup"><span data-stu-id="a729a-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="a729a-497">L'elenco viene generato automaticamente da NetX Secure TLS per i client TLS usando la tabella di crittografia fornita per *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="a729a-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="a729a-498">Non è necessaria alcuna interazione con l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="a729a-499">Authentication Methods</span><span class="sxs-lookup"><span data-stu-id="a729a-499">Authentication Methods</span></span>

<span data-ttu-id="a729a-500">TLS fornisce il Framework per stabilire una connessione sicura tra due dispositivi su una rete non sicura, ma parte del problema sta conoscendo l'identità del dispositivo all'altra estremità della connessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="a729a-501">Senza un meccanismo per l'autenticazione dell'identità degli host remoti, diventa un'operazione semplice che un utente malintenzionato potrebbe rappresentare come un dispositivo attendibile.</span><span class="sxs-lookup"><span data-stu-id="a729a-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="a729a-502">Inizialmente, potrebbe sembrare che l'uso di indirizzi IP, gli indirizzi MAC hardware o DNS forniscono un livello di attendibilità relativamente elevato per l'identificazione degli host in una rete, ma con la natura della tecnologia TCP/IP e la facilità con cui gli indirizzi possono essere falsificati e le voci DNS danneggiate, ad esempio tramite l'avvelenamento della cache DNS, risulta evidente che TLS necessita di un ulteriore livello di protezione contro le identità fraudolente.</span><span class="sxs-lookup"><span data-stu-id="a729a-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="a729a-503">Esistono diversi meccanismi che possono fornire questo livello aggiuntivo di autenticazione per TLS, ma il più comune è il *certificato digitale.*</span><span class="sxs-lookup"><span data-stu-id="a729a-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="a729a-504">Altri meccanismi includono chiavi precondivise (PSK) e schemi di password.</span><span class="sxs-lookup"><span data-stu-id="a729a-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="a729a-505">Certificati digitali</span><span class="sxs-lookup"><span data-stu-id="a729a-505">Digital Cerificates</span></span>

<span data-ttu-id="a729a-506">I certificati digitali sono il metodo più comune per autenticare un host remoto in TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="a729a-507">In sostanza, un certificato digitale è un documento con una formattazione specifica che fornisce informazioni sull'identità per un dispositivo in una rete di computer.</span><span class="sxs-lookup"><span data-stu-id="a729a-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="a729a-508">TLS usa in genere un formato denominato X. 509, uno standard sviluppato dall'Unione di telecomunicazione internazionale, sebbene sia possibile usare altri formati di certificati se gli host TLS possono accettare il formato usato.</span><span class="sxs-lookup"><span data-stu-id="a729a-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="a729a-509">X. 509 definisce un formato specifico per i certificati e varie codifiche che possono essere utilizzate per produrre un documento digitale.</span><span class="sxs-lookup"><span data-stu-id="a729a-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="a729a-510">La maggior parte dei certificati X. 509 usati con TLS viene codificata usando una variante di ASN. 1, un altro standard di telecomunicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="a729a-511">All'interno di ASN. 1 sono disponibili diverse codifiche digitali, ma la codifica più comune per i certificati TLS è lo standard Distinguished Encoding Rules (DER).</span><span class="sxs-lookup"><span data-stu-id="a729a-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="a729a-512">DER è un subset semplificato delle regole di codifica di base ASN. 1 progettato per essere non ambiguo, semplificando l'analisi.</span><span class="sxs-lookup"><span data-stu-id="a729a-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="a729a-513">In transito, i certificati TLS vengono in genere codificati in DER binario e questo è il formato previsto da NetX Secure per i certificati X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="a729a-514">Sebbene i certificati binari in formato DER vengano usati nel protocollo TLS effettivo, possono essere generati e archiviati in una serie di codifiche diverse, con estensioni di file quali PEM, CRT e P12.</span><span class="sxs-lookup"><span data-stu-id="a729a-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="a729a-515">Le diverse varianti vengono utilizzate da diverse applicazioni di produttori diversi, ma in genere possono essere convertite in DER utilizzando strumenti ampiamente disponibili.</span><span class="sxs-lookup"><span data-stu-id="a729a-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="a729a-516">La più comune delle codifiche alternative dei certificati è PEM.</span><span class="sxs-lookup"><span data-stu-id="a729a-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="a729a-517">Il formato PEM (da Privacy-Enhanced mail) è una versione con codifica 64 della codifica DER utilizzata spesso in quanto la codifica produce testo stampabile che può essere facilmente inviato tramite posta elettronica o protocolli basati sul Web.</span><span class="sxs-lookup"><span data-stu-id="a729a-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="a729a-518">La generazione di un certificato per l'applicazione NetX Secure è generalmente al di fuori dell'ambito di questo manuale, ma lo strumento da riga di comando OpenSSL ([www.openssl.org](http://www.openssl.org)) è ampiamente disponibile ed è in grado di eseguire la conversione tra la maggior parte dei formati.</span><span class="sxs-lookup"><span data-stu-id="a729a-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="a729a-519">A seconda dell'applicazione, è possibile generare certificati, fornire certificati da un produttore o da un'organizzazione governativa oppure acquistare certificati da un'autorità di certificazione commerciale.</span><span class="sxs-lookup"><span data-stu-id="a729a-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="a729a-520">Per usare un certificato digitale nell'applicazione NetX Secure, è necessario innanzitutto convertire il certificato in un formato DER binario e, facoltativamente, convertire la chiave privata associata ("esponente privato" per RSA, ad esempio) in un formato binario, in genere una chiave RSA codificata der PKCS # 1 o una chiave ECC codificata DER.</span><span class="sxs-lookup"><span data-stu-id="a729a-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="a729a-521">Al termine della conversione, è possibile caricare il certificato e la chiave privata nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="a729a-522">Le opzioni possibili includono l'uso di un file system basato su Flash o la generazione di una matrice C dai dati (usando uno strumento come "XXD" da Linux) e la compilazione del certificato e della chiave nell'applicazione come dati costanti.</span><span class="sxs-lookup"><span data-stu-id="a729a-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="a729a-523">Una volta caricato il certificato nel dispositivo, è possibile usare l'API TLS per associare il certificato a una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="a729a-524">Per informazioni dettagliate ed esempi su come usare i certificati X. 509 con NetX Secure TLS, vedere la sezione "importazione di certificati X. 509 in NetX Secure".</span><span class="sxs-lookup"><span data-stu-id="a729a-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="a729a-525">Per ulteriori informazioni, fare riferimento ai seguenti servizi TLS nelle informazioni di riferimento sulle API:</span><span class="sxs-lookup"><span data-stu-id="a729a-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="a729a-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="a729a-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="a729a-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a729a-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="a729a-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a729a-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="a729a-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="a729a-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="a729a-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a729a-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="a729a-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a729a-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="a729a-532">Specifiche del certificato client TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="a729a-533">Le implementazioni client TLS in genere non richiedono il caricamento di un certificato "locale"<sup>14</sup> nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="a729a-534">L'eccezione è rappresentata dal caso in cui l'autenticazione del certificato client è abilitata, ma questo è molto meno comune.</span><span class="sxs-lookup"><span data-stu-id="a729a-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="a729a-535">Per il caricamento di un client TLS è necessario che sia presente almeno un certificato "Trusted"<sup>15</sup> (è possibile che ne venga caricato altri se necessario) e che venga allocato spazio per un certificato "remoto"<sup>16</sup> .</span><span class="sxs-lookup"><span data-stu-id="a729a-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="a729a-536">Per ulteriori informazioni sull'aggiunta di certificati attendibili e sull'allocazione dello spazio per i certificati remoti, vedere le informazioni di riferimento sulle API TLS per i servizi seguenti: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="a729a-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="a729a-537">Un certificato "locale" è un certificato che identifica il dispositivo locale, ovvero fornisce informazioni sull'identità per il dispositivo su cui è caricata l'applicazione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="a729a-538">Un certificato "attendibile" è un certificato che fornisce una base per l'attendibilità e l'autenticazione del dispositivo remoto, direttamente o tramite un'infrastruttura a chiave pubblica (PKI).</span><span class="sxs-lookup"><span data-stu-id="a729a-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="a729a-539">La radice della catena di trust è in genere denominata "autorità di certificazione" o certificato della CA.</span><span class="sxs-lookup"><span data-stu-id="a729a-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="a729a-540">Un certificato "remoto" si riferisce al certificato inviato dall'host remoto durante l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="a729a-541">Fornisce l'identità per quell'host remoto ed è autenticato confrontandolo con un certificato "attendibile" nel dispositivo locale.</span><span class="sxs-lookup"><span data-stu-id="a729a-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="a729a-542">Specifiche del certificato del server TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="a729a-543">Le implementazioni del server TLS in genere non richiedono il caricamento di certificati "Trusted" sul dispositivo o sui certificati remoti da allocare.</span><span class="sxs-lookup"><span data-stu-id="a729a-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="a729a-544">L'eccezione è rappresentata dal fatto che l'autenticazione del certificato client è abilitata (questo è meno comune).</span><span class="sxs-lookup"><span data-stu-id="a729a-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="a729a-545">Un server TLS richiede il caricamento di un certificato "locale" in modo che il server possa fornirlo al client remoto durante l'handshake TLS per autenticare il server nel client.</span><span class="sxs-lookup"><span data-stu-id="a729a-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="a729a-546">Per ulteriori informazioni sul caricamento dei certificati locali per l'utilizzo con le applicazioni server TLS NetX, vedere le informazioni di riferimento sulle API per i servizi seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="a729a-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="a729a-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="a729a-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="a729a-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="a729a-549">Chiavi precondivise (PSK)</span><span class="sxs-lookup"><span data-stu-id="a729a-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="a729a-550">Un meccanismo alternativo per fornire l'autenticazione di identificazione in TLS è il concetto di chiavi precondivise (PSK).</span><span class="sxs-lookup"><span data-stu-id="a729a-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="a729a-551">L'uso di un ciphersuite PSK Elimina la necessità di eseguire le operazioni di crittografia a chiave pubblica con utilizzo intensivo del processore, un vantaggio per i dispositivi embedded con vincoli di risorse.</span><span class="sxs-lookup"><span data-stu-id="a729a-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="a729a-552">La PSK sostituisce il certificato nell'handshake TLS e viene usato al posto del segreto pre-master crittografato per la generazione della chiave di sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="a729a-553">I ciphersuites di PSK sono limitati nel senso che un segreto condiviso deve essere presente in entrambi i dispositivi prima che sia possibile stabilire una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="a729a-554">Ciò significa che i dispositivi devono essere stati caricati con tale segreto usando un mezzo sicuro diverso da una connessione PSK TLS. precondivise può essere aggiornato tramite una connessione PSK TLS, ma il dispositivo deve necessariamente iniziare con una PSK che viene caricata tramite un altro meccanismo.</span><span class="sxs-lookup"><span data-stu-id="a729a-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="a729a-555">Ad esempio, un dispositivo sensore e il relativo dispositivo gateway potrebbero essere caricati con precondivise nella Factory prima della spedizione oppure è possibile usare una connessione TLS standard (con un certificato) per caricare la PSK.</span><span class="sxs-lookup"><span data-stu-id="a729a-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="a729a-556">Le ciphersuites PSK sono disponibili in un paio di forme, descritte in RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="a729a-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="a729a-557">Il primo usa le chiavi RSA o Diffie-Hellman utilizzate allo stesso modo delle chiavi pubbliche trasmesse nel certificato negli handshake TLS standard.</span><span class="sxs-lookup"><span data-stu-id="a729a-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="a729a-558">Il secondo formato, che è più usato in un ambiente con vincoli di risorse, usa un PSK usato per generare direttamente le chiavi della sessione (per l'uso da parte di AES, ad esempio), evitando l'uso delle operazioni RSA o Diffie-Hellman onerose.</span><span class="sxs-lookup"><span data-stu-id="a729a-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="a729a-559">NetX Secure supporta la seconda forma di PSK ciphersuites, consentendo alle applicazioni di rimuovere tutto il codice di crittografia a chiave pubblica e l'utilizzo della memoria.</span><span class="sxs-lookup"><span data-stu-id="a729a-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="a729a-560">La PSK stessa non è una chiave AES, ma può essere considerata come una password da cui vengono generate le chiavi effettive.</span><span class="sxs-lookup"><span data-stu-id="a729a-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="a729a-561">Esistono alcune restrizioni relative al valore di PSK, sebbene i valori più lunghi forniscano maggiore sicurezza (come per le password).</span><span class="sxs-lookup"><span data-stu-id="a729a-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="a729a-562">Per usare PSK con l'applicazione NetX Secure, è necessario innanzitutto definire la macro globale **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="a729a-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="a729a-563">Questa operazione viene in genere eseguita tramite le impostazioni del compilatore, ma la definizione può anche essere inserita nel file di intestazione nx_secure_tls. h.</span><span class="sxs-lookup"><span data-stu-id="a729a-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="a729a-564">Con la macro definita, il supporto di PSK ciphersuite verrà compilato nell'applicazione NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="a729a-565">Con il supporto di PSK abilitato, è possibile usare l'API TLS per configurare precondivise per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="a729a-566">Ogni PSK richiederà un valore PSK (il segreto effettivo "Key"-Mantieni questo valore safe), un valore "Identity" usato per identificare il PSK specifico e un "hint di identità" usato da un server TLS per scegliere un particolare valore PSK.</span><span class="sxs-lookup"><span data-stu-id="a729a-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="a729a-567">La PSK può essere qualsiasi valore binario perché non viene mai inviato tramite una connessione di rete.</span><span class="sxs-lookup"><span data-stu-id="a729a-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="a729a-568">La PSK può essere di qualsiasi valore fino a 64 byte di lunghezza.</span><span class="sxs-lookup"><span data-stu-id="a729a-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="a729a-569">L'identità e l'hint devono essere stringhe di caratteri stampabili formattate con UTF-8.</span><span class="sxs-lookup"><span data-stu-id="a729a-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="a729a-570">I valori Identity e hint possono avere una lunghezza fino a 128 byte.</span><span class="sxs-lookup"><span data-stu-id="a729a-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="a729a-571">Identity e PSK formano una coppia univoca che viene caricata in ogni dispositivo della rete che deve comunicare tra loro.</span><span class="sxs-lookup"><span data-stu-id="a729a-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="a729a-572">Il "suggerimento" viene usato principalmente per la definizione di profili applicazione specifici per raggruppare precondivise in base alla funzione o al servizio.</span><span class="sxs-lookup"><span data-stu-id="a729a-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="a729a-573">Questi valori devono essere concordati in anticipo e dipendono dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="a729a-574">Ad esempio, l'applicazione server della riga di comando OpenSSL (con la funzionalità PSK abilitata) usa la stringa predefinita "Client_identity", che deve essere fornita da un client TLS per continuare con l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="a729a-575">Per altre informazioni su precondivise, vedere le informazioni di riferimento sulle API NetX sicure per i servizi seguenti: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="a729a-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="a729a-576">Importazione di certificati X. 509 in NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a729a-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="a729a-577">Per la maggior parte delle connessioni TLS su Internet sono necessari certificati digitali.</span><span class="sxs-lookup"><span data-stu-id="a729a-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="a729a-578">I certificati forniscono un metodo per l'autenticazione di host sconosciuti in precedenza tramite Internet tramite l'utilizzo di intermediari attendibili, in genere detti *autorità di certificazione* o CA.</span><span class="sxs-lookup"><span data-stu-id="a729a-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="a729a-579">Per connettere il dispositivo NetX Secure a un servizio cloud commerciale, ad esempio Amazon Web Services, sarà necessario importare i certificati nell'applicazione eseguendone il caricamento nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="a729a-580">Insieme ai certificati, a volte è necessaria anche una *chiave privata* associata al certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="a729a-581">In alcune applicazioni, ad esempio client TLS quando non si usa l'autenticazione del certificato client, il certificato da solo sarà sufficiente, ma se il certificato viene usato per identificare il dispositivo, sarà necessaria una chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="a729a-582">Le chiavi private vengono in genere generate quando si crea il certificato e vengono archiviate in un file separato, spesso crittografate con una password.</span><span class="sxs-lookup"><span data-stu-id="a729a-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="a729a-583">Tipi di certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-583">Certificate Types</span></span>

<span data-ttu-id="a729a-584">I certificati digitali vengono in genere usati per identificare le entità in una rete, ma a seconda di quale applicazione avranno proprietà leggermente diverse.</span><span class="sxs-lookup"><span data-stu-id="a729a-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="a729a-585">Certificati locali</span><span class="sxs-lookup"><span data-stu-id="a729a-585">Local Certificates</span></span>

<span data-ttu-id="a729a-586">Ai fini di questa documentazione, si fa riferimento a "certificati locali" come i certificati che forniscono un'identità per il dispositivo locale (un altro nome possibile può essere "certificato dispositivo").</span><span class="sxs-lookup"><span data-stu-id="a729a-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="a729a-587">Questi certificati verranno forniti a un host remoto quando l'host remoto vuole autenticare il dispositivo locale.</span><span class="sxs-lookup"><span data-stu-id="a729a-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="a729a-588">Certificati remoti</span><span class="sxs-lookup"><span data-stu-id="a729a-588">Remote Certificates</span></span>

<span data-ttu-id="a729a-589">In questa documentazione, "certificati remoti" si riferisce ai certificati forniti da un host remoto durante l'handshake TLS quando applicabile.</span><span class="sxs-lookup"><span data-stu-id="a729a-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="a729a-590">È necessario allocare spazio per questi certificati oppure NetX Secure non sarà in grado di analizzarli e completare l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="a729a-591">Certificati di firma</span><span class="sxs-lookup"><span data-stu-id="a729a-591">Signing Certificates</span></span>

<span data-ttu-id="a729a-592">Un "certificato di firma" viene usato per firmare digitalmente altri certificati o dati ai fini dell'autenticazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="a729a-593">Questi certificati possono essere certificati intermedi o radice in un'infrastruttura a chiave pubblica (PKI) e in genere non vengono usati per identificare singoli dispositivi o host.</span><span class="sxs-lookup"><span data-stu-id="a729a-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="a729a-594">Certificati CA radice</span><span class="sxs-lookup"><span data-stu-id="a729a-594">Root CA Certificates</span></span>

<span data-ttu-id="a729a-595">"I certificati CA radice" sono certificati di firma che forniscono la base di un'infrastruttura a chiave pubblica e sono autofirmati, anziché essere firmati da un altro certificato di firma.</span><span class="sxs-lookup"><span data-stu-id="a729a-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="a729a-596">Almeno un certificato CA radice è in genere necessario per un client TLS per verificare i server remoti.</span><span class="sxs-lookup"><span data-stu-id="a729a-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="a729a-597">Formati dei certificati</span><span class="sxs-lookup"><span data-stu-id="a729a-597">Certificate formats</span></span>

<span data-ttu-id="a729a-598">I certificati digitali sono semplicemente file contenenti dati strutturati codificati utilizzando la sintassi ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="a729a-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="a729a-599">Esistono tuttavia diversi formati in cui è possibile archiviare i certificati ed è importante avere il formato corretto prima di caricare un certificato in un'applicazione NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a729a-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="a729a-600">I formati più comuni per i certificati sono DER e PEM.</span><span class="sxs-lookup"><span data-stu-id="a729a-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="a729a-601">DER (per *Distinguished Encoding Rules*, un formato ASN. 1) è il formato binario utilizzato da TLS durante l'esecuzione dell'handshake iniziale.</span><span class="sxs-lookup"><span data-stu-id="a729a-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="a729a-602">PEM (da *Privacy Enhanced Mail*) è una versione con codifica base 64 del formato der adatto per la posta elettronica o l'invio tramite HTTP sul Web.</span><span class="sxs-lookup"><span data-stu-id="a729a-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="a729a-603">Diversi fornitori utilizzano estensioni di nome file diverse per i certificati, ad esempio ". pem" o ". CRT" per i certificati PEM e ". der" per i certificati DER.</span><span class="sxs-lookup"><span data-stu-id="a729a-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="a729a-604">Se si dispone di un certificato che non è chiaro del formato utilizzato, l'apertura del file in un editor di testo consentirà di determinare il tipo poiché i file DER sono binari codificati e i file PEM sono testo ASCII normale che iniziano con l'intestazione "-----BEGIN CERTIFICAte-----".</span><span class="sxs-lookup"><span data-stu-id="a729a-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="a729a-605">NetX Secure richiede che il certificato sia in formato DER binario, quindi è necessario convertire il certificato in formato DER prima dell'importazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="a729a-606">Questa operazione può essere eseguita con strumenti prontamente disponibili, ad esempio OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="a729a-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="a729a-607">Se è necessaria una chiave privata per l'applicazione, il file di chiave verrà codificato usando PEM o DER in un formato specifico (PKCS # 1 per RSA, RFC 5915 per ECC).</span><span class="sxs-lookup"><span data-stu-id="a729a-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="a729a-608">Il file di chiave privata deve essere convertito in DER prima di essere importato.</span><span class="sxs-lookup"><span data-stu-id="a729a-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="a729a-609">I comandi OpenSSL seguenti sono forniti come esempio per la conversione di certificati e file di chiave RSA nel formato DER richiesto da NetX Secure (ECC è simile: fare riferimento alla documentazione di OpenSSL).</span><span class="sxs-lookup"><span data-stu-id="a729a-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="a729a-610">Chiavi private e certificati</span><span class="sxs-lookup"><span data-stu-id="a729a-610">Private Keys and Certificates</span></span>

<span data-ttu-id="a729a-611">Per i certificati che identificano un dispositivo, è necessario caricare la chiave privata associata insieme al certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="a729a-612">La chiave privata (che può essere per uno degli algoritmi a chiave pubblica, ad esempio RSA, Diffie-Hellman o Elliptic-Curve crittografia) viene usata da un server TLS per decrittografare il materiale della chiave in ingresso ("pre-master secret") da un client TLS, eseguendo quindi l'autenticazione al client.</span><span class="sxs-lookup"><span data-stu-id="a729a-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="a729a-613">Per un client TLS, se viene fornito un certificato di identità (un certificato con la chiave privata associata) e un server richiede un certificato client, la chiave privata viene usata per autenticare il client. nel caso di RSA, il client crittografa un token usando la chiave privata che il server decrittografa usando la chiave pubblica del client, fornita nel certificato client (Diffie-Hellman e l'autenticazione ECC avviene in modo simile, ma i dettagli sono leggermente diversi).</span><span class="sxs-lookup"><span data-stu-id="a729a-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="a729a-614">In NetX Secure il servizio *nx_secure_x509_certificate_initialize* viene usato per inizializzare un certificato X. 509 (vedere la sezione "caricamento di certificati nel dispositivo" per altre informazioni) e, facoltativamente, associare una chiave privata a tale certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="a729a-615">Se viene fornita una chiave privata, il certificato viene contrassegnato come certificato "Identity" usato per identificare il dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="a729a-616">La chiave viene passata come BLOB binario contiguo e come lunghezza, con un tipo di chiave associato.</span><span class="sxs-lookup"><span data-stu-id="a729a-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="a729a-617">Il tipo di chiave dipende dal tipo di chiave, ad esempio RSA, ECC e così via, e dal formato (ad esempio PKCS # 1 DER).</span><span class="sxs-lookup"><span data-stu-id="a729a-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="a729a-618">Se non viene fornita alcuna chiave, il valore NX_SECURE_X509_KEY_TYPE_NONE (valore 0x0) può essere passato a indicare che non è stata fornita alcuna chiave (una lunghezza pari a 0 e un puntatore NX_NULL per il parametro dati otterrà lo stesso effetto).</span><span class="sxs-lookup"><span data-stu-id="a729a-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="a729a-619">La tabella seguente illustra i tipi di chiave noti per NetX Secure e l'identificatore di tipo associato da passare in *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="a729a-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="a729a-620">Verranno aggiunti altri tipi di chiave perché vengono aggiunti altri algoritmi di crittografia a NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a729a-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="a729a-621">Identificatore</span><span class="sxs-lookup"><span data-stu-id="a729a-621">Identifier</span></span>                              | <span data-ttu-id="a729a-622">Algoritmo</span><span class="sxs-lookup"><span data-stu-id="a729a-622">Algorithm</span></span> | <span data-ttu-id="a729a-623">Formato</span><span class="sxs-lookup"><span data-stu-id="a729a-623">Format</span></span>   | <span data-ttu-id="a729a-624">Codifica</span><span class="sxs-lookup"><span data-stu-id="a729a-624">Encoding</span></span> | <span data-ttu-id="a729a-625">Valore</span><span class="sxs-lookup"><span data-stu-id="a729a-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="a729a-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="a729a-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="a729a-627">nessuno</span><span class="sxs-lookup"><span data-stu-id="a729a-627">None</span></span>      | <span data-ttu-id="a729a-628">N/D</span><span class="sxs-lookup"><span data-stu-id="a729a-628">N/A</span></span>      | <span data-ttu-id="a729a-629">N/D</span><span class="sxs-lookup"><span data-stu-id="a729a-629">N/A</span></span>      | <span data-ttu-id="a729a-630">0x0</span><span class="sxs-lookup"><span data-stu-id="a729a-630">0x0</span></span>   |
| <span data-ttu-id="a729a-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="a729a-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="a729a-632">RSA</span><span class="sxs-lookup"><span data-stu-id="a729a-632">RSA</span></span>       | <span data-ttu-id="a729a-633">PKCS # 1</span><span class="sxs-lookup"><span data-stu-id="a729a-633">PKCS#1</span></span>   | <span data-ttu-id="a729a-634">DER</span><span class="sxs-lookup"><span data-stu-id="a729a-634">DER</span></span>      | <span data-ttu-id="a729a-635">0x1</span><span class="sxs-lookup"><span data-stu-id="a729a-635">0x1</span></span>   |
| <span data-ttu-id="a729a-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="a729a-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="a729a-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="a729a-637">ECDSA</span></span>     | <span data-ttu-id="a729a-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="a729a-638">RFC 5915</span></span> | <span data-ttu-id="a729a-639">DER</span><span class="sxs-lookup"><span data-stu-id="a729a-639">DER</span></span>      | <span data-ttu-id="a729a-640">0x2</span><span class="sxs-lookup"><span data-stu-id="a729a-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="a729a-641">Tipi di chiave privata definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="a729a-641">User-defined private key types</span></span>

<span data-ttu-id="a729a-642">I valori degli identificatori del tipo di chiave per il servizio *nx_secure_x509_certificate_initialize* regolano le azioni intraprese quando viene fornita la chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="a729a-643">Per i tipi noti, i valori sono compresi nell'intervallo 0x0000 0000 – 0x0000 FFFF (ultimi 16 bit di un Unsigned Integer a 32 bit).</span><span class="sxs-lookup"><span data-stu-id="a729a-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="a729a-644">Per le piattaforme con tipi di chiave personalizzati<sup>17</sup> (come nel caso di alcuni motori di crittografia basati su hardware), un tipo di chiave definito dall'utente compreso nell'intervallo 0x0000 1000-0xFFFF FFFF (primi 16 bit diversi da zero) può essere passato come tipo di chiave.</span><span class="sxs-lookup"><span data-stu-id="a729a-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="a729a-645">Se viene impostato uno dei primi 16 bit del tipo di chiave, i dati della chiave privata vengono passati direttamente alla routine di crittografia appropriata, ad esempio RSA, fornita nella tabella TLS ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="a729a-646">I tipi di chiave definiti dall'utente non vengono analizzati o elaborati in altro modo prima di essere passati alla routine di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="a729a-647">Inoltre, il tipo di chiave definito dall'utente verrà passato alla routine di crittografia in modo che sia possibile gestire qualsiasi elaborazione appropriata a tale livello.</span><span class="sxs-lookup"><span data-stu-id="a729a-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="a729a-648">Si noti che i tipi di chiave definiti dall'utente vengono in genere usati per piattaforme hardware specifiche che usano dati di chiave personalizzati (probabilmente crittografati).</span><span class="sxs-lookup"><span data-stu-id="a729a-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="a729a-649">In genere ciò implica che i dati delle chiavi vengono generati o codificati usando un meccanismo specifico del fornitore dell'hardware (o nel caso di uno standard come PKCS # 11, uno standard specifico).</span><span class="sxs-lookup"><span data-stu-id="a729a-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="a729a-650">Per ulteriori informazioni, consultare la documentazione della piattaforma hardware.</span><span class="sxs-lookup"><span data-stu-id="a729a-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="a729a-651">I tipi di chiave definiti dall'utente richiedono una routine di crittografia personalizzata corrispondente per gestire il formato della chiave personalizzata.</span><span class="sxs-lookup"><span data-stu-id="a729a-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="a729a-652">La routine di crittografia deve avere un algoritmo corrispondente (ad esempio RSA) e essere passata in TLS nella tabella ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="a729a-653">Caricamento dei certificati nel dispositivo</span><span class="sxs-lookup"><span data-stu-id="a729a-653">Loading certificates onto your device</span></span>

<span data-ttu-id="a729a-654">Qualsiasi metodo per il caricamento di un file nel dispositivo sarà sufficiente per importare i certificati.</span><span class="sxs-lookup"><span data-stu-id="a729a-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="a729a-655">Il metodo più semplice per il caricamento di un certificato consiste nel convertire i dati binari con codifica DER in una matrice C e compilarli nell'applicazione come costante.</span><span class="sxs-lookup"><span data-stu-id="a729a-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="a729a-656">Questa operazione può essere eseguita facilmente con strumenti come "XXD" in Linux (con l'opzione "-i").</span><span class="sxs-lookup"><span data-stu-id="a729a-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="a729a-657">In alternativa, è possibile caricare il certificato in un filesystem flash o in altre opzioni di archiviazione, purché sia possibile passare un puntatore ai dati del certificato nell'API NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a729a-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="a729a-658">File di certificato necessari per NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a729a-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="a729a-659">I file di certificato che è necessario importare dipendono dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="a729a-660">In generale, i server TLS richiedono un certificato per identificare il dispositivo e i client TLS richiedono uno o più *certificati attendibili* per autenticare i server remoti.</span><span class="sxs-lookup"><span data-stu-id="a729a-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="a729a-661">La tabella seguente illustra i certificati necessari per alcune applicazioni TLS diverse.</span><span class="sxs-lookup"><span data-stu-id="a729a-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="a729a-662">**Opzioni/funzionalità TLS**</span><span class="sxs-lookup"><span data-stu-id="a729a-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="a729a-663">**Certificati/chiavi necessarie (minima)**</span><span class="sxs-lookup"><span data-stu-id="a729a-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="a729a-664">Client TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-664">TLS Client</span></span>                                        | <span data-ttu-id="a729a-665">Certificato CA radice</span><span class="sxs-lookup"><span data-stu-id="a729a-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="a729a-666">Server TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-666">TLS Server</span></span>                                        | <span data-ttu-id="a729a-667">Certificato locale, chiave privata per il certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="a729a-668">Server TLS con autenticazione del certificato client</span><span class="sxs-lookup"><span data-stu-id="a729a-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="a729a-669">Certificato locale, chiave privata, CA radice</span><span class="sxs-lookup"><span data-stu-id="a729a-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="a729a-670">Client TLS con autenticazione del certificato client</span><span class="sxs-lookup"><span data-stu-id="a729a-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="a729a-671">Certificato locale, chiave privata, CA radice</span><span class="sxs-lookup"><span data-stu-id="a729a-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="a729a-672">Client o server TLS con solo chiavi precondivise</span><span class="sxs-lookup"><span data-stu-id="a729a-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="a729a-673">None (PSK usato al posto dei certificati)</span><span class="sxs-lookup"><span data-stu-id="a729a-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="a729a-674">I servizi rilevanti per il caricamento dei certificati sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="a729a-675">**Nome API**</span><span class="sxs-lookup"><span data-stu-id="a729a-675">**API Name**</span></span>                                   | <span data-ttu-id="a729a-676">**Scopo**</span><span class="sxs-lookup"><span data-stu-id="a729a-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="a729a-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="a729a-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="a729a-678">Deve essere chiamato per tutti i certificati per popolare la struttura di NX_SECURE_X509_CERT con i dati del certificato e la chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="a729a-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a729a-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="a729a-680">Aggiungere un certificato locale a una sessione TLS per identificare il dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="a729a-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a729a-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="a729a-682">Rimuovere un certificato locale da una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="a729a-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="a729a-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="a729a-684">Allocare spazio per un certificato remoto (chiamato con una NX_SECURE_X509_CERT non inizializzata).</span><span class="sxs-lookup"><span data-stu-id="a729a-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="a729a-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a729a-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="a729a-686">Aggiungere un certificato a una sessione TLS come certificato attendibile per l'autenticazione di host remoti.</span><span class="sxs-lookup"><span data-stu-id="a729a-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="a729a-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a729a-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="a729a-688">Rimuovere un certificato attendibile da una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="a729a-689">Uso dei certificati di AWS</span><span class="sxs-lookup"><span data-stu-id="a729a-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="a729a-690">Nell'interfaccia Amazon Web Services Internet, selezionare "sicurezza" dal menu sidebar e selezionare "certificati".</span><span class="sxs-lookup"><span data-stu-id="a729a-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="a729a-691">Creare un nuovo certificato e seguire le istruzioni per scaricare il nuovo certificato del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="a729a-692">Una volta scaricati i certificati, sarà necessario convertirli in formato DER usando OpenSSL o un'utilità simile.</span><span class="sxs-lookup"><span data-stu-id="a729a-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="a729a-693">Nota: AWS fornirà anche un file di chiave pubblica.</span><span class="sxs-lookup"><span data-stu-id="a729a-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="a729a-694">La chiave pubblica è contenuta nel certificato del dispositivo locale, pertanto non è necessario importarla nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="a729a-695">Ad esempio, di seguito sono riportati i comandi per convertire il certificato del dispositivo locale e la relativa chiave privata nel formato DER da usare con NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="a729a-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="a729a-696">I file convertiti possono essere importati nell'applicazione seguendo le istruzioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a729a-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="a729a-697">Convalida del certificato X. 509 in NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a729a-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="a729a-698">Quando si usa TLS con certificati X. 509 per l'identificazione e la verifica dell'host, è importante comprendere il modo in cui tali certificati vengono effettivamente convalidati.</span><span class="sxs-lookup"><span data-stu-id="a729a-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="a729a-699">Sebbene la specifica TLS non fornisca istruzioni dettagliate su come convalidare un certificato, fa riferimento alla specifica X. 509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="a729a-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="a729a-700">In generale, si prevede che TLS eseguirà almeno la convalida di base sui certificati in ingresso (i certificati forniti dall'host remoto durante l'handshake TLS) e che NetX Secure TLS non sia diverso.</span><span class="sxs-lookup"><span data-stu-id="a729a-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="a729a-701">Convalida X. 509 di base</span><span class="sxs-lookup"><span data-stu-id="a729a-701">Basic X.509 Validation</span></span>

<span data-ttu-id="a729a-702">Per tutti i certificati in ingresso, NetX Secure TLS eseguirà la convalida di base del percorso X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="a729a-703">Il processo implica la verifica della firma digitale di ogni certificato rispetto al certificato dell'autorità emittente, che può essere fornito dall'host remoto o situato nell'archivio certificati attendibile (vedere la sezione "importazione di certificati X. 509 in NetX Secure" per altre informazioni sull'importazione di certificati attendibili).</span><span class="sxs-lookup"><span data-stu-id="a729a-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="a729a-704">Il processo di convalida viene ripetuto in modo ricorsivo sui certificati dell'autorità emittente fino a quando non viene raggiunto un certificato attendibile o termina la catena (con un certificato autofirmato o un certificato dell'autorità emittente mancante).</span><span class="sxs-lookup"><span data-stu-id="a729a-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="a729a-705">Se viene raggiunto un certificato attendibile, il certificato viene verificato; in caso contrario, viene rifiutato.</span><span class="sxs-lookup"><span data-stu-id="a729a-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="a729a-706">Inoltre, in ogni fase del processo di verifica, la data di scadenza di ogni certificato viene verificata rispetto al tempo fornito dalla funzione timestamp applicazione (vedere il servizio "nx_secure_tls_session_time_function_set" per altre informazioni).</span><span class="sxs-lookup"><span data-stu-id="a729a-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="a729a-707">La specifica X. 509 fornisce anche un algoritmo per supportare i "criteri", che sono identificatori presenti in un'estensione X. 509 che possono essere controllati durante la convalida del percorso.</span><span class="sxs-lookup"><span data-stu-id="a729a-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="a729a-708">NetX Secure considera attualmente i certificati X. 509 come se fosse definita l'opzione "anyPolicy", ovvero tutti i criteri sono accettabili e il controllo facoltativo dei criteri non viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="a729a-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="a729a-709">L'implementazione di NetX Secure X. 509 può essere aumentata con questa funzionalità in una versione futura.</span><span class="sxs-lookup"><span data-stu-id="a729a-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="a729a-710">Per il momento, è possibile ottenere l'estensione dei criteri da un certificato usando l'API *nx_secure_x509_extension_find* .</span><span class="sxs-lookup"><span data-stu-id="a729a-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="a729a-711">Una volta completata la convalida del percorso di base, TLS richiamerà il callback di verifica del certificato fornito dall'applicazione usando l'API *nx_secure_tls_session_certificate_callback_set* .</span><span class="sxs-lookup"><span data-stu-id="a729a-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="a729a-712">Se non viene fornito alcun callback, il certificato viene considerato attendibile dopo la convalida del percorso riuscito.</span><span class="sxs-lookup"><span data-stu-id="a729a-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="a729a-713">Se viene fornito un callback, il callback eseguirà qualsiasi convalida aggiuntiva del certificato richiesto dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="a729a-714">Il valore restituito dal callback viene usato per determinare se continuare con l'handshake TLS o per interrompere l'handshake a causa di un errore di convalida.</span><span class="sxs-lookup"><span data-stu-id="a729a-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="a729a-715">Il callback viene richiamato con un puntatore alla sessione TLS pertinente e un puntatore NX_SECURE_X509_CERT al certificato da convalidare.</span><span class="sxs-lookup"><span data-stu-id="a729a-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="a729a-716">Tra la sessione TLS e il certificato, l'applicazione dispone di tutti i dati necessari da TLS per eseguire verifiche di verifica aggiuntive.</span><span class="sxs-lookup"><span data-stu-id="a729a-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="a729a-717">Per semplificare la convalida aggiuntiva, NetX Secure fornisce routine X. 509 per alcune operazioni comuni di convalida, tra cui la convalida DNS e il controllo dell'elenco di revoche di certificati.</span><span class="sxs-lookup"><span data-stu-id="a729a-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="a729a-718">Tutte queste routine sono adatte per l'uso all'interno del callback di verifica del certificato, ma possono essere usate anche per eseguire il controllo non in linea dei certificati X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="a729a-719">Nella tabella seguente sono riepilogate le funzioni di supporto disponibili per l'elaborazione di certificati X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="a729a-720">Le spiegazioni più dettagliate per le operazioni sono disponibili nelle sezioni seguenti e nella Guida di riferimento alle API del capitolo 4</span><span class="sxs-lookup"><span data-stu-id="a729a-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="a729a-721">La descrizione di NetX Secure Services fornisce dettagli aggiuntivi sulle routine specifiche.</span><span class="sxs-lookup"><span data-stu-id="a729a-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="a729a-722">**Nome API**</span><span class="sxs-lookup"><span data-stu-id="a729a-722">**API Name**</span></span>                             | <span data-ttu-id="a729a-723">**Descrizione**</span><span class="sxs-lookup"><span data-stu-id="a729a-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="a729a-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="a729a-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="a729a-725">Verificare il nome comune del soggetto X. 509 e SubjectAltName rispetto a un nome DNS previsto</span><span class="sxs-lookup"><span data-stu-id="a729a-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="a729a-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="a729a-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="a729a-727">Verificare la presenza di un certificato revocato in un elenco di revoche di certificati X. 509 (CRL)</span><span class="sxs-lookup"><span data-stu-id="a729a-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="a729a-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a729a-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="a729a-729">Analizza e trova un OID di utilizzo chiave esteso specifico in un certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="a729a-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a729a-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="a729a-731">Analizzare e restituire l'utilizzo della chiave bit in un certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="a729a-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="a729a-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="a729a-733">Trovare e restituire i dati ASN. 1 con codifica DER non elaborati per un'estensione specifica.</span><span class="sxs-lookup"><span data-stu-id="a729a-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="a729a-734">Funzioni helper X. 509 da usare nel callback di verifica del certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="a729a-735">Estensioni X. 509</span><span class="sxs-lookup"><span data-stu-id="a729a-735">X.509 Extensions</span></span>

<span data-ttu-id="a729a-736">La specifica X. 509 descrive una serie di "estensioni" che possono essere utilizzate per fornire informazioni aggiuntive che possono essere utilizzate nella verifica dei certificati.</span><span class="sxs-lookup"><span data-stu-id="a729a-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="a729a-737">Nella maggior parte dei casi, queste estensioni sono facoltative e non sono necessarie per la convalida sicura di un certificato digitale rispetto a un certificato radice attendibile.</span><span class="sxs-lookup"><span data-stu-id="a729a-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="a729a-738">Tuttavia, NetX Secure supporta alcune estensioni di base.</span><span class="sxs-lookup"><span data-stu-id="a729a-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="a729a-739">Il supporto per estensioni aggiuntive può essere aggiunto nelle versioni future.</span><span class="sxs-lookup"><span data-stu-id="a729a-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="a729a-740">Le estensioni attualmente supportate sono elencate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="a729a-741">Nome estensione</span><span class="sxs-lookup"><span data-stu-id="a729a-741">Extension Name</span></span>           | <span data-ttu-id="a729a-742">Descrizione</span><span class="sxs-lookup"><span data-stu-id="a729a-742">Description</span></span>                                                                   | <span data-ttu-id="a729a-743">API pertinente</span><span class="sxs-lookup"><span data-stu-id="a729a-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="a729a-744">Utilizzo chiavi</span><span class="sxs-lookup"><span data-stu-id="a729a-744">Key Usage</span></span>                | <span data-ttu-id="a729a-745">Fornisce usi accettabili per la chiave pubblica di un certificato in un bit</span><span class="sxs-lookup"><span data-stu-id="a729a-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="a729a-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a729a-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="a729a-747">Utilizzo chiavi avanzato</span><span class="sxs-lookup"><span data-stu-id="a729a-747">Extended Key Usage</span></span>       | <span data-ttu-id="a729a-748">Fornisce altri usi accettabili per la chiave pubblica di un certificato tramite OID</span><span class="sxs-lookup"><span data-stu-id="a729a-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="a729a-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a729a-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="a729a-750">Nome alternativo soggetto</span><span class="sxs-lookup"><span data-stu-id="a729a-750">Subject Alternative Name</span></span> | <span data-ttu-id="a729a-751">Fornisce nomi DNS alternativi rappresentati anche dal certificato</span><span class="sxs-lookup"><span data-stu-id="a729a-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="a729a-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="a729a-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="a729a-753">Estensioni X. 509 non supportate</span><span class="sxs-lookup"><span data-stu-id="a729a-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="a729a-754">NetX Secure X. 509 implementazione fornisce un servizio per estrarre anche le estensioni non supportate: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="a729a-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="a729a-755">Questa API è destinata agli utenti avanzati perché richiede la conoscenza di ASN. 1 codificato DER per analizzare i dati restituiti.</span><span class="sxs-lookup"><span data-stu-id="a729a-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="a729a-756">Viene usato internamente per estrarre le estensioni supportate, ma viene fornito per praticità nello sviluppo di supporto personalizzato per le estensioni X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="a729a-757">Per utilizzare nx_secure_x509_extension_find, viene passato un NX_SECURE_X509_EXTENSION, insieme al certificato e a un ID estensione, ovvero una rappresentazione Integer della stringa OID a lunghezza variabile per un tipo di estensione noto.</span><span class="sxs-lookup"><span data-stu-id="a729a-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="a729a-758">Un elenco completo di OID supportate per le estensioni X. 509 è disponibile nella Guida di riferimento alle API per nx_secure_x509_extension_find nella pagina 178.</span><span class="sxs-lookup"><span data-stu-id="a729a-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="a729a-759">La struttura NX_SECURE_X509_EXTENSION viene definita nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="a729a-760">Quando il servizio viene restituito correttamente, la struttura viene popolata con i dati rilevanti del certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="a729a-761">Il campo nx_secure_x509_extension_id viene in genere usato per scopi interni, ma verrà popolato con la rappresentazione dell'intero OID pertinente.</span><span class="sxs-lookup"><span data-stu-id="a729a-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="a729a-762">Il campo nx_secure_x509_extension_critical espone il valore del flag di estensione critico X. 509 (booleano).</span><span class="sxs-lookup"><span data-stu-id="a729a-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="a729a-763">I campi nx_secure_x509_extension_data e nx_secure_x509_extension_data_length contengono un puntatore ai dati ASN. 1 con codifica DER per l'estensione e rispettivamente la lunghezza di tali dati.</span><span class="sxs-lookup"><span data-stu-id="a729a-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="a729a-764">L'analisi effettiva dei dati ASN. 1 dell'estensione esula dall'ambito di questo documento, ma se si ha accesso all'origine NetX Secure TLS è possibile vedere come viene eseguita l'analisi quando viene chiamato nx_secure_x509_extension_find per le estensioni supportate.</span><span class="sxs-lookup"><span data-stu-id="a729a-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="a729a-765">Convalida DNS X. 509</span><span class="sxs-lookup"><span data-stu-id="a729a-765">X.509 DNS Validation</span></span>

<span data-ttu-id="a729a-766">Un'operazione di convalida dei certificati comune in TLS prevede il controllo del nome del dominio di Top-Level di un host remoto rispetto al certificato X. 509 fornito da tale host durante l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="a729a-767">Questa operazione consente di verificare che il certificato corrisponda effettivamente al server host che lo ha fornito, presupponendo che la ricerca DNS possa essere considerata attendibile.</span><span class="sxs-lookup"><span data-stu-id="a729a-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="a729a-768">In NetX Secure TLS questa funzionalità viene fornita dal servizio **nx_secure_x509_common_name_dns_check**, che accetta il certificato e una stringa contenente la parte di TLD dell'URL usato per accedere all'host.</span><span class="sxs-lookup"><span data-stu-id="a729a-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="a729a-769">Il TLD viene confrontato con il campo del nome comune del certificato e, se corrisponde, viene restituito NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a729a-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="a729a-770">Se il nome comune non corrisponde, la routine verificherà anche l'esistenza dell'estensione del certificato X. 509 *SubjectAltName*.</span><span class="sxs-lookup"><span data-stu-id="a729a-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="a729a-771">Se è presente un subjectAltName, vengono controllate anche tutte le voci di DNSName nell'estensione rispetto al TLD fornito.</span><span class="sxs-lookup"><span data-stu-id="a729a-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="a729a-772">Anche in questo caso, se viene restituita una corrispondenza, viene restituito NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a729a-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="a729a-773">Se non viene trovata alcuna corrispondenza, viene restituito un errore adatto per restituire il callback di convalida del certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="a729a-774">Utilizzo chiavi X. 509 ed estensioni utilizzo chiavi avanzato</span><span class="sxs-lookup"><span data-stu-id="a729a-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="a729a-775">Le estensioni utilizzo chiavi X. 509 e utilizzo chiavi avanzato forniscono informazioni sulla modalità di utilizzo della chiave pubblica di un certificato durante l'autenticazione del certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="a729a-776">L'utilizzo della chiave viene fornito dall'autorità emittente del certificato quando il certificato viene firmato e emesso.</span><span class="sxs-lookup"><span data-stu-id="a729a-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="a729a-777">L'utilizzo della chiave può essere utilizzato da un host TLS per verificare che il certificato sia autorizzato a essere utilizzato per autenticare un host TLS remoto ed eseguire altre operazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="a729a-778">L'estensione utilizzo chiavi è costituita da un bit semplice in cui ognuno dei bit rappresenta un utilizzo chiave specifico.</span><span class="sxs-lookup"><span data-stu-id="a729a-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="a729a-779">Un elenco completo di questi valori è disponibile nella Guida di riferimento alle API per *nx_secure_x509_key_usage_extension_parse* nella pagina 183.</span><span class="sxs-lookup"><span data-stu-id="a729a-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="a729a-780">Per una descrizione più completa dei bit di utilizzo chiave e dei relativi significati, vedere la specifica RFC 5280, sezione 4.2.1.3.</span><span class="sxs-lookup"><span data-stu-id="a729a-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="a729a-781">L'estensione utilizzo chiavi avanzato, ad esempio l'estensione utilizzo chiave, fornisce informazioni di utilizzo chiave accettabile.</span><span class="sxs-lookup"><span data-stu-id="a729a-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="a729a-782">Tuttavia, per supportare utilizzi arbitrari, l'estensione utilizzo chiavi avanzato usa OID anziché bit.</span><span class="sxs-lookup"><span data-stu-id="a729a-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="a729a-783">Quando si analizza un'estensione per l'utilizzo delle chiavi estesa in NetX Secure X. 509, un numero intero che rappresenta l'OID viene fornito dall'applicazione. il servizio *nx_secure_x509_extended_key_usage_extension_parse* restituirà quindi se tale OID è presente.</span><span class="sxs-lookup"><span data-stu-id="a729a-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="a729a-784">Un elenco completo dei OID supportati per l'utilizzo chiavi avanzato è disponibile nella Guida di riferimento alle API per *nx_secure_x509_extended_key_usage_extension_parse* nella pagina 175.</span><span class="sxs-lookup"><span data-stu-id="a729a-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="a729a-785">Per una descrizione più completa di OID e dei relativi significati, vedere la RFC 5280, sezione 4.2.1.12.</span><span class="sxs-lookup"><span data-stu-id="a729a-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="a729a-786">Verifica dello stato di revoca CRL X. 509</span><span class="sxs-lookup"><span data-stu-id="a729a-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="a729a-787">X. 509 fornisce un meccanismo denominato *elenco di revoche di certificati* (CRL) che consente a un'autorità di firma digitale del certificato di revocare la validità dei certificati firmati.</span><span class="sxs-lookup"><span data-stu-id="a729a-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="a729a-788">Qualsiasi applicazione che deve verificare i certificati da un'autorità di firma può ottenere un CRL e confrontare eventuali certificati firmati da tale autorità (emittente) rispetto al CRL per verificare se il relativo stato è stato revocato per qualche motivo, ad esempio una chiave privata compromessa.</span><span class="sxs-lookup"><span data-stu-id="a729a-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="a729a-789">In questo modo, l'applicazione può evitare l'uso di certificati potenzialmente pericolosi che superano altri controlli di convalida del certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="a729a-790">Il recupero di un CRL viene eseguito da un'applicazione scaricando l'elenco con codifica DER da un server predefinito o con altri mezzi.</span><span class="sxs-lookup"><span data-stu-id="a729a-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="a729a-791">Il programma di installazione effettivo varia a seconda dell'autorità emittente, quindi NetX Secure non fornisce un meccanismo per ottenere i CRL, ma fornisce una routine per verificare un certificato in base a un CRL, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="a729a-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="a729a-792">L'API accetta un CRL con codifica DER, un archivio certificati, ad esempio quello in una sessione TLS, da controllare e il certificato da controllare.</span><span class="sxs-lookup"><span data-stu-id="a729a-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="a729a-793">La routine convalida innanzitutto l'elenco CRL rispetto all'archivio attendibile (parte dell'archivio certificati fornito dall'applicazione).</span><span class="sxs-lookup"><span data-stu-id="a729a-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="a729a-794">Questo è importante per la protezione da CRL fraudolenti usati per gli attacchi Denial of Service e stabilisce che l'elenco CRL è effettivamente dall'emittente appropriato.</span><span class="sxs-lookup"><span data-stu-id="a729a-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="a729a-795">Dopo la convalida CRL, l'autorità emittente viene controllata: se l'emittente del CRL non corrisponde all'emittente del certificato, il CRL non è valido per il certificato e viene restituito un errore.</span><span class="sxs-lookup"><span data-stu-id="a729a-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="a729a-796">L'applicazione deve determinare se l'handshake TLS può continuare a questo punto.</span><span class="sxs-lookup"><span data-stu-id="a729a-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="a729a-797">Se le autorità emittenti corrispondono, viene eseguita la ricerca del numero di serie del certificato da convalidare nel CRL.</span><span class="sxs-lookup"><span data-stu-id="a729a-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="a729a-798">Se il numero di serie è presente nell'elenco, viene restituito un errore che indica che il certificato è stato revocato.</span><span class="sxs-lookup"><span data-stu-id="a729a-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="a729a-799">Se non viene trovata alcuna corrispondenza, viene restituito NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a729a-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="a729a-800">Autenticazione del certificato client in NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="a729a-801">Quando si usa l'autenticazione del certificato X. 509, per il protocollo TLS è necessario che l'istanza del server TLS fornisca un certificato per l'identificazione, ma per impostazione predefinita non è necessario che l'istanza del client TLS fornisca un certificato per l'autenticazione, usando invece un'altra forma di autenticazione, ad esempio una combinazione di nome utente/password.</span><span class="sxs-lookup"><span data-stu-id="a729a-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="a729a-802">Questo corrisponde all'uso più comune di TLS in Internet per i siti Web.</span><span class="sxs-lookup"><span data-stu-id="a729a-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="a729a-803">Ad esempio, un sito di vendita al dettaglio online deve dimostrare a un potenziale cliente che utilizza un Web browser che il server è legittimo, ma l'utente utilizzerà un account di accesso/password per accedere a un account specifico.</span><span class="sxs-lookup"><span data-stu-id="a729a-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="a729a-804">Tuttavia, il caso predefinito non è sempre auspicabile, quindi TLS può facoltativamente consentire all'istanza del server TLS di richiedere un certificato dal client remoto.</span><span class="sxs-lookup"><span data-stu-id="a729a-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="a729a-805">Quando questa funzionalità è abilitata, il server TLS invierà un messaggio CertificateRequest al client TLS durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="a729a-806">Il client deve rispondere con un certificato autonomo e un messaggio CertificateVerify contenente un token crittografico per dimostrare che il client possiede la chiave privata corrispondente associata a tale certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="a729a-807">Se la verifica ha esito negativo o il certificato non è connesso a un certificato attendibile nel server, l'handshake TLS ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="a729a-808">Esistono due casi distinti per l'autenticazione del certificato client in TLS: le sezioni seguenti illustrano entrambi i casi.</span><span class="sxs-lookup"><span data-stu-id="a729a-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="a729a-809">Autenticazione del certificato client per client TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="a729a-810">Un client TLS può tentare una connessione a un server che richiede un certificato per l'autenticazione client.</span><span class="sxs-lookup"><span data-stu-id="a729a-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="a729a-811">In questo caso il client deve fornire un certificato al server e verificare che sia proprietario della chiave privata corrispondente o che il server interromperà l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="a729a-812">In NetX Secure TLS non esiste alcuna configurazione speciale per supportare questa funzionalità, ma l'applicazione dovrà fornire un certificato di identificazione locale per l'istanza del client TLS usando il servizio *nx_secure_tls_local_certificate_add* .</span><span class="sxs-lookup"><span data-stu-id="a729a-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="a729a-813">Se l'applicazione non fornisce alcun certificato ma il server remoto usa l'autenticazione del certificato client e richiede un certificato, l'handshake TLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="a729a-814">Il certificato fornito alla sessione TLS con *nx_secure_tls_local_certificate_add* deve essere riconosciuto dal server remoto per completare l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="a729a-815">Autenticazione del certificato client per i server TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="a729a-816">Il caso del server TLS per l'autenticazione del certificato client è leggermente più complesso rispetto al case client TLS perché la funzionalità è facoltativa.</span><span class="sxs-lookup"><span data-stu-id="a729a-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="a729a-817">In questo caso, il server TLS deve richiedere specificamente un certificato dal client TLS remoto, quindi elaborare il messaggio CertificateVerify per verificare che il client remoto sia proprietario della chiave privata corrispondente, quindi il server deve verificare che il certificato fornito dal client possa essere tracciato a un certificato nell'archivio certificati attendibili locale.</span><span class="sxs-lookup"><span data-stu-id="a729a-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="a729a-818">In NetX Secure TLS istanze del server, l'autenticazione del certificato client è controllata da</span><span class="sxs-lookup"><span data-stu-id="a729a-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="a729a-819">il *client della <span class="underline"> _</span> sessione <span class="underline">_</span>TLS <span class="underline"> _</span> Secure <span class="underline">_</span>TLS <span class="underline"> _</span> verifica <span class="underline">_</span>Abilita* e</span><span class="sxs-lookup"><span data-stu-id="a729a-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="a729a-820">*<span class="underline"> _</span> verifica <span class="underline">_</span>della disabilitazione dei servizi da client della <span class="underline"> _</span> sessione <span class="underline">_</span>TLS <span class="underline"> _</span> sicura <span class="underline">_</span>* .</span><span class="sxs-lookup"><span data-stu-id="a729a-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="a729a-821">Per abilitare l'autenticazione del certificato client, un'applicazione deve chiamare</span><span class="sxs-lookup"><span data-stu-id="a729a-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="a729a-822">*<span class="underline"> _</span> verificare <span class="underline">_</span>che il client della <span class="underline"> _</span> sessione <span class="underline">_</span>TLS <span class="underline"> _</span> <span class="underline">_ sicura</span>sia abilitato* con l'istanza della sessione del server TLS prima di chiamare *nx_secure_tls_session_start*.</span><span class="sxs-lookup"><span data-stu-id="a729a-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="a729a-823">Si noti che la chiamata a questo servizio in una sessione TLS utilizzata per le connessioni client TLS non avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="a729a-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="a729a-824">Quando è abilitata l'autenticazione del certificato client, il server TLS richiede un certificato dal client TLS remoto durante l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="a729a-825">In NetX Secure TLS server, il certificato client viene verificato rispetto all'archivio dei certificati attendibili creati con *nx <span class="underline"> _</span> <span class="underline">_ secure_tls</span><span class="underline"> _</span> certificato <span class="underline">_</span>attendibile aggiungere* dopo la catena dell'emittente X. 509.</span><span class="sxs-lookup"><span data-stu-id="a729a-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="a729a-826">Il client remoto deve fornire una catena che connette il certificato di identità a un certificato nell'archivio attendibile oppure l'handshake TLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="a729a-827">Inoltre, se l'elaborazione del messaggio CertificateVerify ha esito negativo, anche l'handshake TLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="a729a-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="a729a-828">I metodi di firma usati per il metodo CertificateVerify sono corretti per TLS versione 1,0 e TLS versione 1,1 e sono specificati dal server TLS in TLS versione 1,2.</span><span class="sxs-lookup"><span data-stu-id="a729a-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="a729a-829">Per TLS 1,2, i metodi di firma supportati in genere seguono i metodi pertinenti forniti nella tabella del metodo crittografico, ma in genere RSA con SHA-256 (vedere la sezione "crittografia in NetX Secure TLS" per altre informazioni sull'inizializzazione di TLS con i metodi di crittografia).</span><span class="sxs-lookup"><span data-stu-id="a729a-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="a729a-830">Crittografia in NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="a729a-831">TLS definisce un protocollo in cui è possibile usare la crittografia per proteggere le comunicazioni di rete.</span><span class="sxs-lookup"><span data-stu-id="a729a-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="a729a-832">Per questo motivo, lascia che la crittografia effettiva venga usata in modo abbastanza ampio per gli utenti TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="a729a-833">La specifica richiede l'implementazione di un solo ciphersuite: nel caso di TLS 1,2, ciphersuite è TLS_RSA_WITH_AES_128_CBC_SHA, che indica l'uso di RSA per le operazioni a chiave pubblica, AES in modalità CBC con chiavi a 128 bit per la crittografia della sessione e SHA-1 per gli hash di autenticazione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="a729a-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="a729a-834">Essendo conforme a TLS 1,2, NetX Secure Abilita il ciphersuite obbligatorio TLS_RSA_WITH_AES_128_CBC_SHA per impostazione predefinita, ma dato il numero di possibili implementazioni per ciascuno dei metodi crittografici a causa di funzionalità hardware e altre considerazioni, NetX Secure fornisce un'API di crittografia generica che consente a un utente di specificare i metodi crittografici da usare con TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="a729a-835">Nota: il meccanismo di API crittografico generico consente anche agli utenti di implementare il proprio ciphersuites, ma questa operazione è consigliata per gli utenti avanzati che hanno familiarità con le estensioni e ciphersuites di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="a729a-836">Se si è interessati a supportare il proprio ciphersuites, contattare il rappresentante della logica Express.</span><span class="sxs-lookup"><span data-stu-id="a729a-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="a729a-837">Metodi crittografici</span><span class="sxs-lookup"><span data-stu-id="a729a-837">Cryptographic Methods</span></span>

<span data-ttu-id="a729a-838">NetX Secure TLS implementa DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA e ECC (curve selezionate) nel software con driver hardware per alcune piattaforme hardware.</span><span class="sxs-lookup"><span data-stu-id="a729a-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="a729a-839">Un'applicazione può usare le routine di crittografia fornite con NetX Secure o usare routine personalizzate fornite dall'utente finale o da terze parti.</span><span class="sxs-lookup"><span data-stu-id="a729a-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="a729a-840">Il *NX_CRYPTO_METHOD* è un blocco di controllo progettato in modo che un'applicazione descriva una particolare implementazione di un algoritmo di crittografia da usare con NETX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="a729a-841">Con il *NX_CRYPTO_METHOD,* un'applicazione può integrare facilmente la propria implementazione della crittografia in NETX Secure.</span><span class="sxs-lookup"><span data-stu-id="a729a-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="a729a-842">La struttura *NX_CRYPTO_METHOD* viene dichiarata come:</span><span class="sxs-lookup"><span data-stu-id="a729a-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="a729a-843">Di seguito è riportata la descrizione di ogni elemento nella struttura *NX_CRYPTO_METHOD* :</span><span class="sxs-lookup"><span data-stu-id="a729a-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="a729a-844">nx_crypto_algorithm: questo campo identifica l'algoritmo descritto nel *Metodo* della variabile alcuni valori validi per NETX Secure TLS sono i seguenti (fare riferimento a nx_crypto_const. h per valori specifici):</span><span class="sxs-lookup"><span data-stu-id="a729a-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="a729a-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="a729a-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="a729a-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="a729a-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="a729a-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="a729a-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="a729a-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="a729a-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="a729a-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="a729a-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="a729a-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="a729a-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="a729a-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="a729a-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="a729a-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="a729a-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="a729a-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="a729a-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="a729a-854">nx_crypto_key_size_in_bits: questo campo specifica la dimensione della chiave privata usata dal metodo.</span><span class="sxs-lookup"><span data-stu-id="a729a-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="a729a-855">nx_crypto_IV_size_in_bits: questo campo specifica la dimensione del vettore di inizializzazione (IV).</span><span class="sxs-lookup"><span data-stu-id="a729a-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="a729a-856">Si noti che nella maggior parte dei casi il blocco IV viene usato solo per gli algoritmi di crittografia/decrittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="a729a-857">Gli algoritmi di autenticazione e di verifica utilizzano raramente questo campo.</span><span class="sxs-lookup"><span data-stu-id="a729a-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="a729a-858">nx_crypto_ICV_size_in_bits: questo campo specifica la dimensione del blocco del valore di controllo di integrità (ICV).</span><span class="sxs-lookup"><span data-stu-id="a729a-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="a729a-859">Nota: questo blocco è per l'utilizzo IPsec e non è usato in TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="a729a-860">Per ulteriori informazioni, vedere NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="a729a-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="a729a-861">nx_crypto_block_size_in_bytes: questo campo specifica le dimensioni in byte del blocco dell'algoritmo di crittografia per le crittografie basate su blocchi.</span><span class="sxs-lookup"><span data-stu-id="a729a-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="a729a-862">Nella maggior parte dei casi questo viene usato dalle routine di crittografia e raramente dalle routine di autenticazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="a729a-863">nx_crypto_metadata_area_size: questo campo specifica la dimensione dell'area dei metadati richiesta da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="a729a-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="a729a-864">Ogni implementazione può richiedere una certa memoria per archiviare le informazioni sullo stato o per archiviare i dati intermedi, ad esempio il materiale di trasformazione della chiave, o per utilizzare come area scratch.</span><span class="sxs-lookup"><span data-stu-id="a729a-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="a729a-865">La quantità di spazio richiesta da un'implementazione è specificata in questo campo.</span><span class="sxs-lookup"><span data-stu-id="a729a-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="a729a-866">L'applicazione fornisce lo spazio di memoria durante la creazione di una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="a729a-867">La funzione di crittografia è responsabile della gestione dell'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="a729a-868">nx_crypto_init: questa è la funzione di inizializzazione per l'algoritmo crittografico.</span><span class="sxs-lookup"><span data-stu-id="a729a-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="a729a-869">Per un'implementazione che non necessita di una routine di inizializzazione, questo campo può essere impostato su NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="a729a-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="a729a-870">Un utilizzo tipico di una funzione di inizializzazione consiste nell'inizializzare la struttura dei dati interni per l'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="a729a-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="a729a-871">NetX Secure TLS gestirà l'inizializzazione della routine di crittografia chiamando internamente questa funzione.</span><span class="sxs-lookup"><span data-stu-id="a729a-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="a729a-872">Il prototipo per la funzione di inizializzazione è:</span><span class="sxs-lookup"><span data-stu-id="a729a-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="a729a-873">il metodo è un puntatore al blocco di controllo del metodo Crypto.</span><span class="sxs-lookup"><span data-stu-id="a729a-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="a729a-874">Key è la stringa di chiave privata per l'elaborazione dei pacchetti di dati.</span><span class="sxs-lookup"><span data-stu-id="a729a-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="a729a-875">key_size_in_bits definisce la dimensione in bit della chiave privata.</span><span class="sxs-lookup"><span data-stu-id="a729a-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="a729a-876">handle è un elemento definito dall'implementazione che identifica una determinata sessione di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="a729a-877">Il valore viene generato dalla routine di inizializzazione e viene passato di nuovo al chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="a729a-878">L'operazione di crittografia successiva o la routine di pulizia usano questo handle per identificare la sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="a729a-879">crypto_metadata è un puntatore all'area dei metadati richiesta dall'implementazione di questo algoritmo.</span><span class="sxs-lookup"><span data-stu-id="a729a-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="a729a-880">Per gli algoritmi che non necessitano di un'area dei metadati questo campo è impostato su NX_NULL e la routine di inizializzazione non deve accedere all'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="a729a-881">crypto_metadata_size specifica la dimensione dell'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="a729a-882">Per SAs creato senza area dei metadati, questo campo è impostato su zero e la routine di inizializzazione non deve accedere all'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="a729a-883">Questa routine deve restituire *NX_SUCCESS* se il processo di inizializzazione ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="a729a-884">Il chiamante considera un errore qualsiasi altro valore restituito.</span><span class="sxs-lookup"><span data-stu-id="a729a-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="a729a-885">nx_crypto_cleanup: questa è la routine di pulizia definita per l'implementazione di un algoritmo di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="a729a-886">Viene richiamato quando una sessione TLS viene eliminata o riavviata.</span><span class="sxs-lookup"><span data-stu-id="a729a-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="a729a-887">Il prototipo per la funzione Cleanup è:</span><span class="sxs-lookup"><span data-stu-id="a729a-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="a729a-888">l'handle viene passato alla funzione CleanUp dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="a729a-889">L'handle viene inizializzato dalla routine di inizializzazione della crittografia e utilizzato per identificare lo stato dell'algoritmo crittografico.</span><span class="sxs-lookup"><span data-stu-id="a729a-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="a729a-890">Questa routine deve restituire *NX_SUCCESS* se il processo di pulizia ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="a729a-891">Il chiamante considera un errore qualsiasi altro valore restituito.</span><span class="sxs-lookup"><span data-stu-id="a729a-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="a729a-892">nx_crypto_operation: questa è la routine che esegue i servizi di crittografia, decrittografia e autenticazione effettivi.</span><span class="sxs-lookup"><span data-stu-id="a729a-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="a729a-893">Il prototipo di funzione della routine dell'operazione è:</span><span class="sxs-lookup"><span data-stu-id="a729a-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="a729a-894">op indica il tipo di operazione che questa routine prevede di eseguire. I valori validi sono:</span><span class="sxs-lookup"><span data-stu-id="a729a-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="a729a-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="a729a-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="a729a-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="a729a-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="a729a-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="a729a-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="a729a-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="a729a-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="a729a-899">l'handle viene passato alla funzione Operation dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="a729a-900">Viene generato dalla routine di inizializzazione della crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="a729a-901">il metodo punta al blocco di controllo del metodo Crypto</span><span class="sxs-lookup"><span data-stu-id="a729a-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="a729a-902">chiave che punta alla chiave privata usata per questa operazione</span><span class="sxs-lookup"><span data-stu-id="a729a-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="a729a-903">key_size_in_bits è la dimensione della chiave privata in bit</span><span class="sxs-lookup"><span data-stu-id="a729a-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="a729a-904">input è un puntatore all'inizio del messaggio da operare.</span><span class="sxs-lookup"><span data-stu-id="a729a-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="a729a-905">input_length_in_byte viene passato dal chiamante per indicare le dimensioni del messaggio da operare.</span><span class="sxs-lookup"><span data-stu-id="a729a-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="a729a-906">iv_ptr viene configurato dal chiamante in modo che punti all'inizio di un blocco IV.</span><span class="sxs-lookup"><span data-stu-id="a729a-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="a729a-907">Si noti che la memoria per il blocco IV viene fornita dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="a729a-908">Per la crittografia, la funzione Operation deve scrivere le informazioni IV in questo blocco di memoria; per la decrittografia, la funzione Operation deve recuperare le informazioni IV da questo blocco di memoria.</span><span class="sxs-lookup"><span data-stu-id="a729a-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="a729a-909">Gli algoritmi per l'autenticazione e l'operazione di verifica in genere non usano il vettore di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="a729a-910">l'output viene configurato dal chiamante per puntare a un buffer di output.</span><span class="sxs-lookup"><span data-stu-id="a729a-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="a729a-911">Si noti che la memoria per il buffer di output viene fornita dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="a729a-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="a729a-912">Per la crittografia, la funzione Operation deve scrivere il testo crittografato nel buffer di output. per la decrittografia, l'operazione deve scrivere il testo decifrato (testo non crittografato) nel buffer di output. per l'autenticazione, il valore hash deve essere scritto nel buffer di output.</span><span class="sxs-lookup"><span data-stu-id="a729a-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="a729a-913">Per la verifica, il buffer di output viene usato per archiviare le informazioni hash.</span><span class="sxs-lookup"><span data-stu-id="a729a-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="a729a-914">output_length_in_byte indica le dimensioni del buffer di output</span><span class="sxs-lookup"><span data-stu-id="a729a-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="a729a-915">crypto_metadata punta all'area dei metadati che deve essere utilizzata da questa operazione di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="a729a-916">L'area dei metadati di crittografia viene in genere inizializzata da crypto_init_function.</span><span class="sxs-lookup"><span data-stu-id="a729a-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="a729a-917">crypto_metadata_size indica le dimensioni dell'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="a729a-918">Questa routine deve restituire *NX_SUCCESS* se il processo dell'operazione ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="a729a-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="a729a-919">Il chiamante considera un errore qualsiasi altro valore restituito.</span><span class="sxs-lookup"><span data-stu-id="a729a-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="a729a-920">packet_ptr: pacchetto che contiene i dati in fase di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="a729a-921">Nota: questo parametro non è usato da TLS e deve essere impostato su NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="a729a-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="a729a-922">nx_crypto_hw_process_callback: funzione di callback fornita dal metodo di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="a729a-923">Viene usato se la funzione Crypto viene fornita dall'hardware e richiede una routine di callback.</span><span class="sxs-lookup"><span data-stu-id="a729a-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="a729a-924">NetX Secure TLS fornisce i metodi di crittografia seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="a729a-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="a729a-925">*AES*</span></span>  
- <span data-ttu-id="a729a-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="a729a-926">*RSA*</span></span>  
- <span data-ttu-id="a729a-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="a729a-927">*NULL*</span></span>

<span data-ttu-id="a729a-928">NetX Secure TLS fornisce i metodi di autenticazione seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="a729a-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="a729a-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="a729a-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="a729a-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="a729a-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="a729a-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="a729a-932">Negli esempi seguenti viene illustrato come configurare la struttura di *NX_CRYPTO_METHOD* per l'utilizzo dei metodi di crittografia e autenticazione forniti da NETX Duo IPSec.</span><span class="sxs-lookup"><span data-stu-id="a729a-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="a729a-933">***AES***</span><span class="sxs-lookup"><span data-stu-id="a729a-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="a729a-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="a729a-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="a729a-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="a729a-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="a729a-936">***NONE***</span><span class="sxs-lookup"><span data-stu-id="a729a-936">***NONE***</span></span>

<span data-ttu-id="a729a-937">Un metodo speciale **NX_CRYPTO_NONE** viene utilizzato per segnalare al modulo IPsec che la crittografia o il servizio di autenticazione non è necessario.</span><span class="sxs-lookup"><span data-stu-id="a729a-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="a729a-938">Viene configurato come segue:</span><span class="sxs-lookup"><span data-stu-id="a729a-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="a729a-939">Inizializzazione di TLS con i metodi di crittografia</span><span class="sxs-lookup"><span data-stu-id="a729a-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="a729a-940">Dopo aver creato le routine di crittografia conformi alle firme del metodo crittografico descritte nella sezione precedente, sarà necessario passarle in TLS quando si Inizializza un blocco di controllo NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="a729a-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="a729a-941">Questa operazione viene eseguita nel nx_secure_tls_session_create del servizio TLS:</span><span class="sxs-lookup"><span data-stu-id="a729a-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="a729a-942">session_pointer è un puntatore al blocco di controllo NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="a729a-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="a729a-943">tls_cipher_table è un puntatore a un blocco di controllo NX_SECURE_TLS_CRYPTO, descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="a729a-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="a729a-944">encryption_metadata_area punta allo spazio usato dalle routine di crittografia in TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="a729a-945">encryption_metadata_size è la dimensione in byte dell'area dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="a729a-946">Crittografia a curva ellittica (ECC) in NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="a729a-947">La crittografia a curva ellittica (ECC) fornisce uno schema di crittografia a chiave pubblica che può essere utilizzato al posto di RSA.</span><span class="sxs-lookup"><span data-stu-id="a729a-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="a729a-948">ECC è in genere più veloce e USA chiavi più piccole rispetto a RSA, quindi può essere un'opzione utile per il protocollo TLS incorporato.</span><span class="sxs-lookup"><span data-stu-id="a729a-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="a729a-949">Nelle versioni X-Ware precedenti ad Azure RTO 6,0, ECC è stato fornito come componente aggiuntivo, richiedendo l'installazione del codice sorgente ECC nel progetto.</span><span class="sxs-lookup"><span data-stu-id="a729a-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="a729a-950">Azure RTO 6,0 integrato ECC nella codebase principale, quindi l'installazione dei file ECC non è più necessaria.</span><span class="sxs-lookup"><span data-stu-id="a729a-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="a729a-951">Tuttavia, ECC richiede comunque la stessa inizializzazione delle versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a729a-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="a729a-952">Curve ECC supportate</span><span class="sxs-lookup"><span data-stu-id="a729a-952">Supported ECC curves</span></span>

<span data-ttu-id="a729a-953">NetX Secure implementa parti delle curve in base a <http://www.secg.org/sec2-v2.pdf> .</span><span class="sxs-lookup"><span data-stu-id="a729a-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="a729a-954">Le curve usufruire delle sono supportate<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="a729a-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="a729a-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="a729a-955">secp256r1</span></span> 
  - <span data-ttu-id="a729a-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="a729a-956">secp384r1</span></span> 
  - <span data-ttu-id="a729a-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="a729a-957">secp521r1</span></span> 

<span data-ttu-id="a729a-958">Se vengono utilizzate altre curve ECC, la routine *nx_secure_tls_session_start ()* restituirà l'errore NX_SECURE_TLS_NO_SUPPORTED_CIPHERS a indicare che sono state utilizzate curve non supportate.</span><span class="sxs-lookup"><span data-stu-id="a729a-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="a729a-959">Si noti che la catena di certificati TLS può essere crittografata anche con gli algoritmi ECC.</span><span class="sxs-lookup"><span data-stu-id="a729a-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="a729a-960">Anche se le curve fornite dal client TLS sono supportate, è possibile che la curva ECC usata nella catena di certificati non sia supportata.</span><span class="sxs-lookup"><span data-stu-id="a729a-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="a729a-961">In questo caso, *nx_secure_tls_session_start* routine restituisce NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="a729a-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="a729a-962">Un esempio di tabella ciphersuite predefinito per ECC viene fornito in nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="a729a-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="a729a-963">Per ulteriori informazioni sulle tabelle ciphersuite, vedere la sezione relativa alla tabella di crittografia TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="a729a-964">Si noti che le implementazioni per le curve secp192r1 e secp224r1are sono fornite anche per le applicazioni legacy.</span><span class="sxs-lookup"><span data-stu-id="a729a-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="a729a-965">Tuttavia, queste curve sono ora considerate vulnerabili e non devono essere usate per lo sviluppo di nuove applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="a729a-966">Metodi di crittografia per ECC</span><span class="sxs-lookup"><span data-stu-id="a729a-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="a729a-967">Metodi di crittografia per gruppi a curva ellittica:</span><span class="sxs-lookup"><span data-stu-id="a729a-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="a729a-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="a729a-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="a729a-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="a729a-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="a729a-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="a729a-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="a729a-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="a729a-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="a729a-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="a729a-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="a729a-973">I metodi di crittografia per le curve ECC sono definiti in nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="a729a-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="a729a-974">Metodo Crypto per ECDHE:</span><span class="sxs-lookup"><span data-stu-id="a729a-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="a729a-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="a729a-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="a729a-976">Metodo Crypto per ECDSA:</span><span class="sxs-lookup"><span data-stu-id="a729a-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="a729a-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="a729a-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="a729a-978">I metodi di crittografia ECDSA e ECDHE sono definiti in nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="a729a-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="a729a-979">Insieme ad altri metodi di crittografia, ad esempio RSA, SHA e AES, possono essere usati come blocchi predefiniti per la tabella di ricerca ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="a729a-980">Abilitazione del supporto ECC per TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="a729a-981">ECC è abilitato per impostazione predefinita per TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="a729a-982">Per disabilitare il supporto ECC, è necessario definire il simbolo NX_SECURE_DISABLE_ECC_CIPHERSUITE.</span><span class="sxs-lookup"><span data-stu-id="a729a-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="a729a-983">Per rendere effettive le modifiche, sarà necessario ricompilare la libreria protetta NetX e tutte le applicazioni che usano tale libreria.</span><span class="sxs-lookup"><span data-stu-id="a729a-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="a729a-984">Nel codice dell'applicazione, l'API n *x_secure_tls_ecc_initialize ()* deve essere chiamata dopo la creazione della sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="a729a-985">Questa API invia una notifica alla sessione TLS del tipo di curve da usare per le operazioni di scambio delle chiavi TLS e la verifica del certificato.</span><span class="sxs-lookup"><span data-stu-id="a729a-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="a729a-986">Durante la fase di handshake TLS, se viene selezionato un algoritmo ECC, i parametri correlati alla curva ECC del client e del server per decidere quale curva usare.</span><span class="sxs-lookup"><span data-stu-id="a729a-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="a729a-987">Il segmento di codice seguente illustra come usare l'API.</span><span class="sxs-lookup"><span data-stu-id="a729a-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="a729a-988">Si noti che gli argomenti (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size e nx_crypto_ecc_curves)* sono tutti definiti in *nx_crypto_generic_ciphersuites. c*.</span><span class="sxs-lookup"><span data-stu-id="a729a-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="a729a-989">Questi simboli possono pertanto essere usati direttamente.</span><span class="sxs-lookup"><span data-stu-id="a729a-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="a729a-990">La configurazione di esempio in nx_crypto_generic_ciphersuites. c contiene una tabella di ricerca ECC ciphersuite usata quando ECC è abilitato.</span><span class="sxs-lookup"><span data-stu-id="a729a-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="a729a-991">Per usare ECC, è sufficiente passare nx_crypto_tls_ciphers_ecc come parametro della tabella ciphersuite durante la creazione di sessioni TLS con nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="a729a-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="a729a-992">La tabella di esempio contiene ciphersuites ECC e non ECC.</span><span class="sxs-lookup"><span data-stu-id="a729a-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="a729a-993">Tabella di crittografia TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="a729a-994">La struttura NX_SECURE_TLS_CRYPTO è definita come segue:</span><span class="sxs-lookup"><span data-stu-id="a729a-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="a729a-995">La tabella viene creata compilando le voci per questa struttura in una costante statica che si trova all'interno del progetto TLS sicuro NetX, che in genere si trova con le routine e i moduli crittografici.</span><span class="sxs-lookup"><span data-stu-id="a729a-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="a729a-996">Ad esempio, la libreria di crittografia solo software ("generico") fornita con NetX Secure contiene la definizione di tabella seguente (per il supporto di ciphersuite non ECC<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="a729a-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="a729a-997">Nella struttura la prima voce è la tabella TLS ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="a729a-998">La struttura NX_SECURE_TLS_CIPHERSUITE_INFO esegue il mapping delle routine di crittografia (sotto forma di puntatori NX_CRYPTO_METHOD) a ciphersuites specifici come definito nelle specifiche TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="a729a-999">Il secondo valore è il numero di voci nella tabella a cui punta il primo campo.</span><span class="sxs-lookup"><span data-stu-id="a729a-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="a729a-1000">Il campo successivo punta a una tabella di routine utilizzata da X. 509 quando si elaborano i certificati digitali e la struttura NX_SECURE_X509_CRYPTO è simile al formato NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="a729a-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="a729a-1001">Il campo seguente indica il numero di voci nella tabella.</span><span class="sxs-lookup"><span data-stu-id="a729a-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="a729a-1002">Le tabelle di ricerca seguenti sono diverse routine necessarie per versioni specifiche di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="a729a-1003">Ad esempio, prima della versione di TLS 1,2, le routine di generazione delle chiavi e di hash di handshake sono state corrette per l'uso di una combinazione di SHA-1 e MD5. i metodi per queste routine sono denominati in modo specifico nella struttura di crittografia poiché non sono collegati a ciphersuites specifici.</span><span class="sxs-lookup"><span data-stu-id="a729a-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="a729a-1004">In TLS versione 1,2, le routine di generazione e hashing delle chiavi vengono scelte da ciphersuite, ma per ciphersuites che non specificano le routine da usare, viene usato il metodo hash SHA-256 e la struttura di crittografia chiama tale routine in modo specifico.</span><span class="sxs-lookup"><span data-stu-id="a729a-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="a729a-1005">TLS 1,3 richiede alcune crittografie specifiche aggiuntive per le varie operazioni.</span><span class="sxs-lookup"><span data-stu-id="a729a-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="a729a-1006">Si noti che il supporto di TLS 1,3 richiede ECC: usare nx_crypto_tls_ciphers_ecc se TLS 1,3 è abilitato.</span><span class="sxs-lookup"><span data-stu-id="a729a-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="a729a-1007">Tabella di ricerca TLS CipherSuite</span><span class="sxs-lookup"><span data-stu-id="a729a-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="a729a-1008">Per compilare la tabella di crittografia per TLS, sarà anche necessario creare una tabella di ricerca ciphersuite che esegue il mapping delle routine di crittografia a identificatori ciphersuite specifici.</span><span class="sxs-lookup"><span data-stu-id="a729a-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="a729a-1009">Gli identificatori sono valori registrati da IANA universali.</span><span class="sxs-lookup"><span data-stu-id="a729a-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="a729a-1010">Per ulteriori informazioni, vedere le RFC di TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="a729a-1011">Le routine rappresentano i 5 metodi distinti usati in ogni ciphersuite (alcuni ciphersuites potrebbero non usare tutti i 5): crittografia pubblica, autenticazione a chiave pubblica, crittografia della sessione, routine hash della sessione e funzione di Pseudo-Random TLS (PRF).</span><span class="sxs-lookup"><span data-stu-id="a729a-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="a729a-1012">Nella tabella seguente vengono illustrati i 5 metodi seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="a729a-1013">**Categoria routine**</span><span class="sxs-lookup"><span data-stu-id="a729a-1013">**Routine category**</span></span>      | <span data-ttu-id="a729a-1014">**Descrizione**</span><span class="sxs-lookup"><span data-stu-id="a729a-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="a729a-1015">**Algoritmi di esempio**</span><span class="sxs-lookup"><span data-stu-id="a729a-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="a729a-1016">Crittografia pubblica</span><span class="sxs-lookup"><span data-stu-id="a729a-1016">Public cipher</span></span>             | <span data-ttu-id="a729a-1017">Usato per scambiare chiavi durante l'handshake TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="a729a-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="a729a-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="a729a-1019">Autenticazione a chiave pubblica</span><span class="sxs-lookup"><span data-stu-id="a729a-1019">Public-key authentication</span></span> | <span data-ttu-id="a729a-1020">Usato per autenticare o firmare i dati durante l'handshake TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="a729a-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="a729a-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="a729a-1022">Crittografia della sessione</span><span class="sxs-lookup"><span data-stu-id="a729a-1022">Session cipher</span></span>            | <span data-ttu-id="a729a-1023">Algoritmo a chiave simmetrica usato per crittografare i dati dell'applicazione durante la sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="a729a-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="a729a-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="a729a-1025">Hash della sessione</span><span class="sxs-lookup"><span data-stu-id="a729a-1025">Session hash</span></span>              | <span data-ttu-id="a729a-1026">Utilizzato per mantenere l'integrità dei messaggi durante la sessione TLS (garantisce che i dati non siano stati modificati)</span><span class="sxs-lookup"><span data-stu-id="a729a-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="a729a-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="a729a-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="a729a-1028">PRF TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1028">TLS PRF</span></span>                   | <span data-ttu-id="a729a-1029">Utilizzato per generare il materiale della chiave e nell'hash di handshake nell'handshake TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="a729a-1030">PRF si basa su routine hash – SHA-1 + MD5, SHA-256, SHA-512</span><span class="sxs-lookup"><span data-stu-id="a729a-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="a729a-1031">La struttura NX_SECURE_TLS_CIPHERSUITE_INFO viene definita nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="a729a-1032">Il campo nx_secure_tls_ciphersuite contiene il valore IANA ciphersuite e i puntatori NX_CRYPTO_METHOD rappresentano i 5 metodi usati da tale ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="a729a-1033">I valori scalari (nx_secure_tls_iv_size, nx_secure_tls_key_size e nx_secure_tls_hash_size) sono informativi e forniscono informazioni che potrebbero non essere disponibili nelle voci NX_CRYPTO_METHOD.</span><span class="sxs-lookup"><span data-stu-id="a729a-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="a729a-1034">Si esaminerà ad esempio il valore predefinito di ciphersuite per TLS, TLS_RSA_WITH_AES_128_CBC_SHA, che specifica l'uso di RSA, AES-CBC con chiavi a 128 bit e SHA-1 per l'hashing della sessione.</span><span class="sxs-lookup"><span data-stu-id="a729a-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="a729a-1035">Per questo ciphersuite non è specificata alcuna PRF TLS, quindi in modalità TLSv 1.2 verrà usata la PRF predefinita SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a729a-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="a729a-1036">Si noti che tutti i ciphersuites utilizzano la PRF SHA-1 + MD5 in TLS 1,0 e 1,1, indipendentemente dalla PRF specificata nella tabella.</span><span class="sxs-lookup"><span data-stu-id="a729a-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="a729a-1037">La voce nella tabella NX_SECURE_TLS_CIPHERSUITE_INFO nella libreria di crittografia generica è definita nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="a729a-1038">Si noti che per la crittografia della sessione la dimensione della chiave è determinata da ciphersuite, ma per i metodi a chiave pubblica la dimensione della chiave non è nota fino a quando l'handshake TLS non è in corso poiché le chiavi pubbliche sono contenute nei certificati digitali scambiati durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="a729a-1039">Tabella di ricerca crittografica X. 509</span><span class="sxs-lookup"><span data-stu-id="a729a-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="a729a-1040">Analogamente alla tabella NX_SECURE_TLS_CIPHERSUITE_INFO, la struttura NX_SECURE_X509_CRYPTO esegue il mapping delle routine di crittografia ai valori noti.</span><span class="sxs-lookup"><span data-stu-id="a729a-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="a729a-1041">Nel caso di X. 509, gli identificatori sono effettivamente OID definiti da X. 509 e registrati con i corpi degli standard ISO e ITU.</span><span class="sxs-lookup"><span data-stu-id="a729a-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="a729a-1042">OID sono valori multibyte a lunghezza variabile progettati per identificare in modo univoco le varie informazioni in diversi standard di telecomunicazione, incluse le routine crittografiche usate nei certificati digitali.</span><span class="sxs-lookup"><span data-stu-id="a729a-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="a729a-1043">A causa del fatto che OID sono a lunghezza variabile, NetX Secure TLS esegue il mapping dei valori OID ufficiali alle costanti a lunghezza fissa utilizzate internamente (vedere nx_secure_x509. h).</span><span class="sxs-lookup"><span data-stu-id="a729a-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="a729a-1044">Queste costanti vengono utilizzate nella struttura di NX_SECURE_X509_CRYPTO, definita nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="a729a-1045">Il primo campo, *nx_secure_x509_crypto_identifier*, è la rappresentazione OID interna utilizzata da NETX Secure.</span><span class="sxs-lookup"><span data-stu-id="a729a-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="a729a-1046">Il secondo e il terzo campo puntano a NX_CRYPTO_METHOD oggetti che rappresentano i metodi crittografici identificati dall'OID, un'operazione a chiave pubblica abbinata a una routine hash.</span><span class="sxs-lookup"><span data-stu-id="a729a-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="a729a-1047">Si noti che ogni certificato digitale può avere più di un OID per le routine crittografiche.</span><span class="sxs-lookup"><span data-stu-id="a729a-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="a729a-1048">La tabella dei metodi per X. 509 viene costruita in modo analogo alla tabella di ricerca ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="a729a-1049">Si esaminerà ad esempio l'OID per RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="a729a-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="a729a-1050">L'OID effettivo per RSA_SHA1 è il seguente:</span><span class="sxs-lookup"><span data-stu-id="a729a-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="a729a-1051">L'OID è rappresentato nella sintassi ASN. 1 e ha un valore numerico pari a 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="a729a-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="a729a-1052">Questo valore viene quindi codificato in formato binario, creando i byte seguenti:</span><span class="sxs-lookup"><span data-stu-id="a729a-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="a729a-1053">La conversione effettiva da ASN. 1 al formato binario esula dall'ambito di questo documento.</span><span class="sxs-lookup"><span data-stu-id="a729a-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="a729a-1054">Per ulteriori informazioni, cercare le codifiche ASN. 1 per OID.</span><span class="sxs-lookup"><span data-stu-id="a729a-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="a729a-1055">La rappresentazione binaria di OID supportata da NetX Secure si trova nel file *nx_secure_x509. c*.</span><span class="sxs-lookup"><span data-stu-id="a729a-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="a729a-1056">Una volta ottenuto un mapping dell'OID effettivo a una costante riconosciuta internamente, è possibile creare una voce per RSA_SHA1 nella tabella NX_SECURE_X509_CRYPTO:</span><span class="sxs-lookup"><span data-stu-id="a729a-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="a729a-1057">Routine TLS predefinite</span><span class="sxs-lookup"><span data-stu-id="a729a-1057">Default TLS Routines</span></span>

<span data-ttu-id="a729a-1058">Come indicato in precedenza, TLS richiede alcune routine predefinite per la generazione delle chiavi e la verifica dei messaggi durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="a729a-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="a729a-1059">La routine primaria è la funzione TLS Pseudo-Random o PRF.</span><span class="sxs-lookup"><span data-stu-id="a729a-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="a729a-1060">PRF è basato su routine hash e può essere usato per generare una quantità arbitraria di dati pseudo-casuali<sup>20</sup> per la generazione di chiavi o altri scopi.</span><span class="sxs-lookup"><span data-stu-id="a729a-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="a729a-1061">Oltre a PRF, ogni versione di TLS usa le routine hash predefinite che devono essere fornite anche.</span><span class="sxs-lookup"><span data-stu-id="a729a-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="a729a-1062">Per le versioni TLS 1,0 e 1,1, le routine hash sono MD5 e SHA-1.</span><span class="sxs-lookup"><span data-stu-id="a729a-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="a729a-1063">Per la versione 1,2 di TLS è necessario solo SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a729a-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="a729a-1064">Nella struttura di NX_SECURE_TLS_CRYPTO sono presenti puntatori NX_CRYPTO_METHOD per MD5, SHA-1, SHA-256, TLS versione 1.0/1.1 PRF e il valore predefinito di TLS 1,2 PRF.</span><span class="sxs-lookup"><span data-stu-id="a729a-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="a729a-1065">Il supporto di TLS 1,3 aggiunge campi per HKDF (generazione di chiavi), HMAC (per operazioni di hashing specifiche usate durante l'handshake) e ECDHE (obbligatorio per la funzionalità TLS 1,3).</span><span class="sxs-lookup"><span data-stu-id="a729a-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="a729a-1066">In Generic software Cryptography Library sono disponibili versioni software di TLS PRF.</span><span class="sxs-lookup"><span data-stu-id="a729a-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="a729a-1067">Per TLS 1.0/1.1 questa funzione viene chiamata *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="a729a-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="a729a-1068">Per TLS 1,2, la funzione viene chiamata *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="a729a-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="a729a-1069">Il suffisso "1" rappresenta la PRF TLS 1,0 legacy e il suffisso "SHA256" si riferisce al fatto che la PRF predefinita TLS 1,2 è basata su SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a729a-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="a729a-1070">Quando è necessario il supporto per altre routine PRF, il suffisso per tali routine rifletterà il metodo hash utilizzato.</span><span class="sxs-lookup"><span data-stu-id="a729a-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="a729a-1071">Poiché le routine PRF sono basate su metodi hash, le routine hash sottostanti possono essere accelerate in modo indipendente su diverse piattaforme di destinazione.</span><span class="sxs-lookup"><span data-stu-id="a729a-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="a729a-1072">Oltre alle tabelle di ricerca TLS ciphersuite e X. 509, con le routine PRF e hash predefinite compilate nella struttura NX_SECURE_TLS_CRYPTO possono essere popolate e usate per inizializzare una sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="a729a-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="a729a-1073">"Pseudo-casuale" si riferisce al fatto che la PRF è deterministica, vale a dire che produrrà sempre lo stesso output in base allo stesso input, ma casuale nel fatto che l'output non è stimabile.</span><span class="sxs-lookup"><span data-stu-id="a729a-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="a729a-1074">TLS usa questa proprietà di PRF per generare le chiavi della sessione da diversi dati pubblici combinati con la master secret scambiata durante l'handshake usando una crittografia a chiave pubblica, ad esempio RSA.</span><span class="sxs-lookup"><span data-stu-id="a729a-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="a729a-1075">Metadati crittografici</span><span class="sxs-lookup"><span data-stu-id="a729a-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="a729a-1076">Prima di poter inizializzare la sessione TLS con la tabella NX_SECURE_TLS_CRYPTO, è necessario allocare spazio nel buffer per i metadati della routine di crittografia.</span><span class="sxs-lookup"><span data-stu-id="a729a-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="a729a-1077">I metadati vengono usati per archiviare tutti gli Stati associati a una routine specifica, rappresentati dal relativo blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="a729a-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="a729a-1078">Il campo *nx_crypto_metadata_area_size* di ogni NX_CRYPTO_METHOD deve essere impostato sulla dimensione della struttura di controllo associata a tale routine o l'inizializzazione TLS non riuscirà a tenere conto dello spazio necessario, causando probabilmente problemi di sovraccarico del buffer.</span><span class="sxs-lookup"><span data-stu-id="a729a-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="a729a-1079">Prima della creazione della sessione TLS, è necessario allocare il buffer dei metadati.</span><span class="sxs-lookup"><span data-stu-id="a729a-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="a729a-1080">Il buffer viene diviso automaticamente per nx_secure_tls_session_create e lo spazio viene riservato per ogni routine fornita nella tabella del metodo crittografico.</span><span class="sxs-lookup"><span data-stu-id="a729a-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="a729a-1081">Si noti che poiché un solo ciphersuite è attivo alla volta in una sessione TLS, il numero di ciphersuites supportati non influisce sull'area dei metadati necessaria. lo spazio viene riservato per ognuna delle 5 routine ciphersuite usando la dimensione massima del blocco di controllo per tale categoria nella tabella di ricerca ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="a729a-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="a729a-1082">Per semplificare il calcolo delle dimensioni del buffer dei metadati, il *nx_secure_metadata_size_calculate* del servizio esegue gli stessi calcoli nx_secure_tls_session_create ma restituisce semplicemente la dimensione totale necessaria del buffer dei metadati in byte.</span><span class="sxs-lookup"><span data-stu-id="a729a-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="a729a-1083">Inizializzazione della sessione TLS</span><span class="sxs-lookup"><span data-stu-id="a729a-1083">Initializing the TLS session</span></span>

<span data-ttu-id="a729a-1084">Una volta creati gli oggetti NX_CRYPTO_METHOD e NX_SECURE_TLS_CRYPTO e l'area dei metadati riservata, è possibile inizializzare una sessione TLS come indicato di seguito (i valori ricavati dagli esempi precedenti):</span><span class="sxs-lookup"><span data-stu-id="a729a-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
