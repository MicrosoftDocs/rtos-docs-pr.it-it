---
title: Capitolo 3-Descrizione funzionale di Azure RTO NetX Secure DTLS
description: Questo capitolo contiene una descrizione funzionale di Azure RTO NetX Secure DTLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 468f1dc8a8334dc89064594b29dc8cfabd7d8fae
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822883"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="dfa3f-103">Capitolo 3: Descrizione funzionale di Azure RTO NetX Secure DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="dfa3f-104">Panoramica dell'esecuzione</span><span class="sxs-lookup"><span data-stu-id="dfa3f-104">Execution Overview</span></span>

<span data-ttu-id="dfa3f-105">Questo capitolo contiene una descrizione funzionale di Azure RTO NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="dfa3f-106">Esistono due tipi principali di esecuzione del programma in un'applicazione NetX Secure DTLS: inizializzazione e chiamate dell'interfaccia dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="dfa3f-107">NetX Secure presuppone l'esistenza di ThreadX e NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="dfa3f-108">Da ThreadX, sono necessari l'esecuzione di thread, la sospensione, i timer periodici e le strutture di esclusione reciproca.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="dfa3f-109">Da NetX/NetXDuo richiede le funzionalità di rete UDP e IP e i driver.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="dfa3f-110">Datagramma Transport Layer Security (DTLS) e Transport Layer Security (TLS)</span><span class="sxs-lookup"><span data-stu-id="dfa3f-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="dfa3f-111">NetX Secure DTLS implementa il datagramma Transport Layer Security protocollo versione 1,2 definito in RFC 6347.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="dfa3f-112">DTLS versione 1,0 è stata definita in RFC 4347 e corrisponde a TLS versione 1,1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="dfa3f-113">Poiché DTLS è essenzialmente un'estensione di TLS, è stato deciso che la versione successiva utilizzerebbe lo stesso numero di versione della versione TLS corrispondente.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="dfa3f-114">Quindi, non esiste alcuna versione di DTLS 1,1 perché DTLS versione 1,2 corrisponde a TLS versione 1,2.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="dfa3f-115">NetX Secure supporta DTLS versione 1,2.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="dfa3f-116">DTLS 1,0 (RFC 4347) **non** è attualmente supportato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="dfa3f-117">*Secure Sockets Layer* (SSL) è il nome originale di TLS prima che diventi uno standard in RFC 2246 e "SSL" viene spesso usato come nome generico per i protocolli TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="dfa3f-118">L'ultima versione di SSL è 3,0 e TLS 1,0 viene a volte definito SSL versione 3,1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="dfa3f-119">Tutte le versioni del protocollo "SSL" ufficiale sono considerate obsolete e non sicure e attualmente NetX Secure non fornisce un'implementazione SSL.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="dfa3f-120">TLS specifica un protocollo per generare *chiavi di sessione* create durante l' *handshake* TLS tra un client e un server TLS e tali chiavi vengono usate per crittografare i dati inviati dall'applicazione durante la *sessione TLS.*</span><span class="sxs-lookup"><span data-stu-id="dfa3f-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="dfa3f-121">DTLS è strettamente associato a TLS, perché i mechansims di sicurezza sottostanti sono condivisi tra i protocolli.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="dfa3f-122">Tuttavia, TLS è progettato per funzionare su un protocollo di livello trasporto che fornisce garanzie sul recapito e sull'ordine dei pacchetti (quasi sempre TCP in pratica) e non funzionerà su un protocollo non affidabile come UDP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="dfa3f-123">È proprio a causa di UDP che DTLS è stato introdotto: DTLS è stato progettato per gestire la natura inaffidabile di UDP e protocolli simili.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="dfa3f-124">Questa operazione viene eseguita includendo la logica di ordinamento e affidabilità (ad esempio la ritrasmissione dei dati eliminati) simile a protocolli affidabili come TCP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="dfa3f-125">Una descrizione completa di TLS è inclusa nel capitolo 3 del manuale dell'utente di NetX Secure TLS, quindi questo documento si focalizzerà sulle differenze tra TLS e DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="dfa3f-126">Intestazione del record DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-126">DTLS Record header</span></span>

<span data-ttu-id="dfa3f-127">Qualsiasi record DTLS valido deve avere un'intestazione DTLS, come illustrato nella figura 1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="dfa3f-128">L'intestazione è uguale a TLS con l'aggiunta di due nuovi campi: l' *Epoch* a 16 bit e il *numero di sequenza* a 48 bit, descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![Diagramma di un'intestazione di record DTLS.](media/image2.png)

<span data-ttu-id="dfa3f-130">**Figura 1-intestazione del record DTLS**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="dfa3f-131">I campi dell'intestazione del record TLS sono definiti come segue:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="dfa3f-132">Campo di intestazione TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-132">TLS Header Field</span></span> | <span data-ttu-id="dfa3f-133">Scopo</span><span class="sxs-lookup"><span data-stu-id="dfa3f-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="dfa3f-134">**Tipo di messaggio a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-134">**8-bit Message Type**</span></span> | <span data-ttu-id="dfa3f-135">Questo campo contiene il tipo di record DTLS da inviare.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="dfa3f-136">I tipi validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-136">Valid types are as follows:</span></span><br /><span data-ttu-id="dfa3f-137">-ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="dfa3f-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="dfa3f-138">-Avviso: 0x15</span><span class="sxs-lookup"><span data-stu-id="dfa3f-138">- Alert: 0x15</span></span><br /><span data-ttu-id="dfa3f-139">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="dfa3f-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="dfa3f-140">-Dati applicazione: 0x17</span><span class="sxs-lookup"><span data-stu-id="dfa3f-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="dfa3f-141">**Versione del protocollo a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="dfa3f-142">Questo campo contiene la versione del protocollo DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="dfa3f-143">I valori validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-143">Valid values are as follows:</span></span><br /><span data-ttu-id="dfa3f-144">-DTLS 1,1:0xFEFD</span><span class="sxs-lookup"><span data-stu-id="dfa3f-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="dfa3f-145">**Epoch a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="dfa3f-146">Questo campo contiene il DTLS "Epoch", che è un contatore incrementato ogni volta che viene modificato lo stato di crittografia, ad esempio quando si generano nuove chiavi di sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="dfa3f-147">**Numero di sequenza a 48 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="dfa3f-148">Questo campo contiene un numero di sequenza che identifica questo record specifico.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="dfa3f-149">Viene usato da DTLS per gestire l'ordinamento dei record e verificare la necessità di ritrasmissione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="dfa3f-150">**Lunghezza a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-150">**16-bit Length**</span></span> |  <span data-ttu-id="dfa3f-151">Questo campo contiene la lunghezza dei dati incapsulati nel record DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="dfa3f-152">Intestazione del record di handshake DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="dfa3f-153">Qualsiasi record di handshake DTLS valido deve avere un'intestazione di handshake DTLS, come illustrato nella figura 2.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![Diagramma di un'intestazione di record di handshake DTLS.](media/image3.png)

<span data-ttu-id="dfa3f-155">**Figura 2-intestazione del record di handshake DTLS**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="dfa3f-156">I campi dell'intestazione del record di handshake DTLS sono definiti come segue:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="dfa3f-157">Campo di intestazione TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-157">TLS Header Field</span></span> | <span data-ttu-id="dfa3f-158">Scopo</span><span class="sxs-lookup"><span data-stu-id="dfa3f-158">Purpose</span></span> |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="dfa3f-159">**Tipo di messaggio a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-159">**8-bit Message Type**</span></span> | <span data-ttu-id="dfa3f-160">Questo campo contiene il tipo di record DTLS da inviare.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="dfa3f-161">I tipi validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-161">Valid types are as follows:</span></span><br /><span data-ttu-id="dfa3f-162">-ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="dfa3f-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="dfa3f-163">-Avviso: 0x15</span><span class="sxs-lookup"><span data-stu-id="dfa3f-163">- Alert: 0x15</span></span><br /><span data-ttu-id="dfa3f-164">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="dfa3f-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="dfa3f-165">-Dati applicazione: 0x17</span><span class="sxs-lookup"><span data-stu-id="dfa3f-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="dfa3f-166">**Epoch a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-166">**16-bit Epoch**</span></span> | <span data-ttu-id="dfa3f-167">Questo campo contiene il DTLS "Epoch", che è un contatore incrementato ogni volta che viene modificato lo stato di crittografia, ad esempio quando si generano nuove chiavi di sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="dfa3f-168">**Numero di sequenza a 48 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="dfa3f-169">Questo campo contiene un numero di sequenza che identifica questo record specifico.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="dfa3f-170">Viene usato da DTLS per gestire l'ordinamento dei record e verificare la necessità di ritrasmissione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="dfa3f-171">**Versione del protocollo a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="dfa3f-172">Questo campo contiene la versione del protocollo DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="dfa3f-173">I valori validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-173">Valid values are as follows:</span></span><br /><span data-ttu-id="dfa3f-174">-DTLS 1,1:0xFEFD</span><span class="sxs-lookup"><span data-stu-id="dfa3f-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="dfa3f-175">**Lunghezza a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-175">**16-bit Length**</span></span> | <span data-ttu-id="dfa3f-176">Questo campo contiene la lunghezza dei dati incapsulati nel record DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="dfa3f-177">**Tipo di handshake a 8 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="dfa3f-178">Questo campo contiene il tipo di messaggio di handshake.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-178">This field contains the handshake message type.</span></span> <span data-ttu-id="dfa3f-179">I valori validi sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-179">Valid values are as follows:</span></span><br /><span data-ttu-id="dfa3f-180">-HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="dfa3f-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="dfa3f-181">-ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="dfa3f-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="dfa3f-182">-ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="dfa3f-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="dfa3f-183">-Certificato: 0x0B</span><span class="sxs-lookup"><span data-stu-id="dfa3f-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="dfa3f-184">-ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="dfa3f-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="dfa3f-185">-CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="dfa3f-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="dfa3f-186">-ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="dfa3f-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="dfa3f-187">-CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="dfa3f-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="dfa3f-188">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="dfa3f-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="dfa3f-189">- Operazione terminata</span><span class="sxs-lookup"><span data-stu-id="dfa3f-189">- Finished</span></span> | <span data-ttu-id="dfa3f-190">0x14</span><span class="sxs-lookup"><span data-stu-id="dfa3f-190">0x14</span></span> |
| <span data-ttu-id="dfa3f-191">**Lunghezza a 24 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-191">**24-bit Length**</span></span> | <span data-ttu-id="dfa3f-192">Questo campo contiene la lunghezza dei dati del messaggio di handshake.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-192">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="dfa3f-193">**Numero di sequenza a 16 bit**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-193">**16-bit Sequence Number**</span></span> | <span data-ttu-id="dfa3f-194">Questo campo contiene un numero di sequenza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-194">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="dfa3f-195">DTLS handshake e DTLS Session</span><span class="sxs-lookup"><span data-stu-id="dfa3f-195">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="dfa3f-196">Nella figura 3 è illustrato un handshake DTLS tipico.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-196">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="dfa3f-197">È quasi identico al tipico handshake TLS con una differenza importante: quando il messaggio ClientHello viene inviato per la prima volta, il server risponde con un nuovo messaggio specifico di DTLS, *HelloVerifyRequest* che contiene un "cookie".</span><span class="sxs-lookup"><span data-stu-id="dfa3f-197">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="dfa3f-198">Il client DTLS deve rispondere con un secondo messaggio ClientHello contenente tale cookie prima che l'handshake possa proseguire.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-198">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="dfa3f-199">Questo meccanismo è stato aggiunto a DTLS per impedire determinati attacchi Denial of Service (DoS) Poiché UDP è un protocollo senza connessione (TCP richiede una connessione/porta dedicata in modo che TLS non soffra dello stesso problema).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-199">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="dfa3f-200">Un handshake DTLS inizia quando il client invia un messaggio *ClientHello* a un server DTLS, indicando il desiderio di avviare una sessione DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-200">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="dfa3f-201">Il messaggio contiene informazioni sulla crittografia che il client desidera utilizzare per la sessione, insieme alle informazioni utilizzate per generare le chiavi di sessione in un secondo momento nell'handshake.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-201">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="dfa3f-202">Fino a quando non vengono generate le chiavi della sessione, tutti i messaggi nell'handshake DTLS non vengono crittografati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-202">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="dfa3f-203">Come indicato in precedenza, il server DTLS può inviare un HelloVerifyRequest in risposta a ClientHello, forzando il client a rispondere con un secondo ClientHello aggiornato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-203">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="dfa3f-204">Quando riceve il secondo messaggio ClientHello, il server DTLS verificherà il cookie e se la correzione risponderà con un messaggio ServerHello che indica una selezione dalle opzioni di crittografia fornite dal client.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-204">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="dfa3f-205">ServerHello è seguito da un messaggio di certificato, in cui il server fornisce un certificato digitale per autenticare la propria identità al client (se viene utilizzata la verifica X. 509).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-205">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="dfa3f-206">Infine, il server invia un messaggio ServerHelloDone per indicare che non sono presenti altri messaggi da inviare.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-206">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="dfa3f-207">Il server può facoltativamente inviare altri messaggi dopo ServerHello e in alcuni casi potrebbe non inviare un messaggio di certificato, ad esempio quando vengono usate chiavi precondivise, quindi la necessità del messaggio ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-207">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="dfa3f-208">Una volta che il client ha ricevuto tutti i messaggi del server, dispone di informazioni sufficienti per generare le chiavi della sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-208">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="dfa3f-209">Questa operazione viene eseguita da TLS/DTLS creando un bit condiviso di dati casuali denominato *Master Secret*, che è a dimensione fissa e viene utilizzato come valore di inizializzazione per generare tutte le chiavi necessarie quando la crittografia è abilitata.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-209">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="dfa3f-210">Il segreto pre-master viene crittografato usando l'algoritmo a chiave pubblica, ad esempio RSA, specificato nei messaggi Hello (vedere di seguito per informazioni sugli algoritmi a chiave pubblica) e la chiave pubblica fornita dal server nel certificato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-210">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="dfa3f-211">Una funzionalità facoltativa TLS/DTLS denominata chiavi precondivise (PSK) consente a ciphersuites che non usano un certificato, ma usano invece un valore segreto condiviso tra gli host (in genere tramite trasferimento fisico o un altro metodo protetto).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-211">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="dfa3f-212">Quando è abilitata la funzionalità PSK, la chiave privata precondivisa viene utilizzata per generare il segreto pre-master.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-212">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="dfa3f-213">Vedere la sezione relativa alle chiavi già condivise in "metodi di autenticazione" di seguito.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-213">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="dfa3f-214">In un handshake TLS/DTLS consueto, il segreto pre-master crittografato viene inviato al server nel messaggio ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-214">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="dfa3f-215">Il server, dopo la ricezione del messaggio ClientKeyExchange, decrittografa il segreto pre-master usando la relativa chiave privata e continua a generare le chiavi della sessione in parallelo con il client TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-215">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="dfa3f-216">Una volta generate le chiavi della sessione, tutti gli altri messaggi possono essere crittografati usando l'algoritmo di chiave privata, ad esempio AES, selezionato nei messaggi Hello.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-216">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="dfa3f-217">Un messaggio finale non crittografato denominato ChangeCipherSpec viene inviato sia dal client che dal server per indicare che tutti gli altri messaggi verranno crittografati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-217">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="dfa3f-218">Il primo messaggio crittografato inviato sia dal client che dal server è anche il messaggio di handshake TLS finale, denominato completato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-218">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="dfa3f-219">Questo messaggio contiene un hash di tutti i messaggi di handshake ricevuti e inviati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-219">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="dfa3f-220">Questo hash viene utilizzato per verificare che nessuno dei messaggi nell'handshake sia stato alterato o danneggiato (che indica una possibile violazione della sicurezza).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-220">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="dfa3f-221">Dopo la ricezione dei messaggi finiti e la verifica degli hash di handshake, viene avviata la sessione TLS/DTLS e l'applicazione inizia a inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-221">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="dfa3f-222">Per la prima volta viene eseguito l'hashing di tutti i dati inviati da entrambi i lati durante la sessione TLS/DTLS usando l'algoritmo hash scelto nei messaggi Hello (per fornire l'integrità del messaggio) e crittografati usando l'algoritmo di chiave privata scelto con le chiavi di sessione generate.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-222">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="dfa3f-223">Infine, una sessione TLS/DTLS può essere conclusa correttamente solo se il client o il server sceglie di eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-223">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="dfa3f-224">Una sessione troncata è considerata una violazione della sicurezza (poiché un utente malintenzionato potrebbe tentare di impedire la ricezione di tutti i dati), quindi viene inviata una notifica speciale quando uno dei due lati desidera terminare la sessione, denominata avviso CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-224">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="dfa3f-225">Sia il client che il server devono inviare ed elaborare un avviso CloseNotify per un arresto corretto della sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-225">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagramma di una tipica sessione di handshake DTLS.](media/image4.png)

<span data-ttu-id="dfa3f-227">**Figura 3: handshake DTLS tipico**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-227">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="dfa3f-228">Inizializzazione</span><span class="sxs-lookup"><span data-stu-id="dfa3f-228">Initialization</span></span>

<span data-ttu-id="dfa3f-229">Lo stack NetX o NetXDuo deve essere inizializzato prima di usare NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-229">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="dfa3f-230">Per informazioni su come inizializzare correttamente lo stack TCP/IP per l'operazione UDP, vedere la guida dell'utente di NetX o NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-230">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="dfa3f-231">Dopo l'inizializzazione di NetX UDP, è possibile abilitare DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-231">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="dfa3f-232">Internamente tutto il traffico di rete e l'elaborazione di DTLS vengono gestiti dallo stack NetX/NetXDuo senza richiedere l'intervento dell'utente.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-232">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="dfa3f-233">Tuttavia, DTLS presenta alcuni requisiti specifici che devono essere gestiti separatamente dallo stack di rete sottostante.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-233">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="dfa3f-234">Operazione client DTLS questi parametri sono assegnati al blocco di controllo DTLS denominato \***NX_SECURE_DTLS_SESSION** _.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-234">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="dfa3f-235">Per l'operazione del server DTLS, il blocco di controllo viene chiamato _ *_NX_SECURE_DTLS_SERVER_*\* e contiene l'infrastruttura necessaria per gestire più sessioni DTLS in una singola porta UDP. si noti che questo è diverso da TLS, in cui a ogni sessione TLS è associato a una singola porta TCP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-235">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="dfa3f-236">Le due modalità DTLS, server e client, possono essere abilitate in un'applicazione (ma solo una modalità per socket NetX) e ognuna hanno requisiti specifici, descritti di seguito.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-236">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="dfa3f-237">Inizializzazione-server DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-237">Initialization – DTLS Server</span></span>

<span data-ttu-id="dfa3f-238">La modalità server DTLS Secure NetX è diversa dalla modalità server TLS a causa dell'utilizzo di UDP per il protocollo di trasporto di rete sottostante.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-238">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="dfa3f-239">Con TCP, la porta è associata a un singolo host remoto per la durata della sessione TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-239">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="dfa3f-240">Il protocollo UDP non ha alcuna nozione di stato per quanto riguarda l'host remoto, quindi le richieste DTLS da host diversi verranno tutte ricevute nella stessa interfaccia UDP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-240">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="dfa3f-241">Di conseguenza, DTLS deve mantenere lo stato della sessione anziché basarsi sul socket come con TLS e TCP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-241">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="dfa3f-242">Per questo motivo, il blocco di controllo del server DTLS (NX_SECURE_DTLS_SERVER) mantiene un mapping delle informazioni sull'host remoto (indirizzo IP e porta) alle sessioni di DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-242">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="dfa3f-243">Tutti i dati in ingresso nel socket UDP assegnato a un server DTLS verranno mappati a una sessione DTLS nuova o esistente basata sull'host remoto.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-243">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="dfa3f-244">Per questo motivo, la creazione del server DTLS richiede diversi parametri oltre a quelli necessari per i client TLS e DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-244">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="dfa3f-245">Oltre al blocco di controllo server DTLS, a ciphersuites TLS e al buffer di area scratch/metadati di crittografia, i server DTLS richiedono un buffer per mantenere le sessioni DTLS e un buffer di riassemblaggio pacchetti usato per decrittografare i record DTLS in arrivo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-245">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="dfa3f-246">Oltre ai buffer della sessione, i server DTLS richiedono un *certificato digitale*, ovvero un documento usato per identificare il server TLS per il client TLS connesso e la *chiave privata* corrispondente dei certificati, in genere per l'algoritmo di crittografia RSA.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-246">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="dfa3f-247">Lo standard International Telecommunications Union X. 509 specifica il formato del certificato usato da TLS/DTLS e sono disponibili numerose utilità per la creazione di certificati digitali X. 509.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-247">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="dfa3f-248">Per NetX Secure DTLS, il certificato X. 509 deve essere codificato in formato binario usando il formato Distinguished Encoding Rules (DER) di ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-248">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="dfa3f-249">DER è il formato binario standard TLS in transito per i certificati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-249">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="dfa3f-250">La chiave privata associata al certificato specificato deve essere in formato DER-Encoded PKCS # 1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-250">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="dfa3f-251">La chiave privata viene usata solo sul dispositivo e non verrà mai trasmessa in rete.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-251">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="dfa3f-252">Mantieni sicure le chiavi private perché forniscono la sicurezza per le comunicazioni TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-252">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="dfa3f-253">Per inizializzare il certificato del server DTLS, è necessario che l'applicazione fornisca un puntatore a un buffer che contiene il certificato X. 509 con codifica der e i dati facoltativi della chiave privata PKCS # 1 RSA codificata con il servizio ***nx_secure_x509_certificate_intialize*** , che popola la struttura **NX_SECURE_X509_CERT** con i dati del certificato appropriati per l'uso da parte di TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-253">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="dfa3f-254">Una volta inizializzato, il certificato del server deve essere aggiunto al blocco di controllo TLS utilizzando il servizio ***nx_secure_dtls_server_local_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="dfa3f-254">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="dfa3f-255">Una volta che il certificato del server è stato aggiunto al blocco di controllo del server DTLS, il server può essere usato per le comunicazioni DTLS sicure (vedere l'esempio precedente).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-255">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="dfa3f-256">Inizializzazione-client DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-256">Initialization – DTLS Client</span></span>

<span data-ttu-id="dfa3f-257">NetX Secure DTLS Client Mode è un'operazione semplice rispetto al server DTLS poiché esiste una sola connessione in uscita all'host remoto sul socket UDP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-257">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="dfa3f-258">Per configurare un client DTLS, è necessario un *archivio certificati attendibile*, ovvero una raccolta di certificati digitali con codifica X. 509 provenienti da autorità di certificazione attendibili (CA).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-258">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="dfa3f-259">Questi certificati vengono considerati attendibili dal protocollo DTLS e vengono usati come base per l'autenticazione dei certificati forniti dalle entità del server DTLS all'applicazione client Secure DTLS di NetX.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-259">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="dfa3f-260">Un certificato CA attendibile può essere *autofirmato* o firmato da un'altra CA, nel qual caso il certificato viene definito *CA intermedia* (ICA).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-260">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="dfa3f-261">In una tipica applicazione TLS/DTLS il server fornisce i certificati ICA insieme al certificato del server, ma l'unico requisito per la corretta autenticazione è che una catena di autorità emittenti (certificati usati per firmare altri certificati) può essere ritracciata dal certificato del server a un certificato CA attendibile nell'archivio certificati attendibili.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-261">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="dfa3f-262">Questa catena è nota come *catena di attendibilità* o *catena di certificati*.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-262">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="dfa3f-263">Per inizializzare una CA attendibile o un certificato ICA, l'applicazione deve fornire un puntatore a un buffer contenente il certificato X. 509 con codifica DER usando il servizio ***nx_secure_x509_certificate_intialize** _, che popola la struttura _ *NX_SECURE_X509_CERT** con i dati del certificato appropriati per l'uso da parte di TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-263">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="dfa3f-264">Il client DTLS necessita inoltre di spazio per l'allocazione del certificato del server in ingresso (presupponendo che non venga utilizzata una modalità di chiave pre-condivisa) e un buffer per l'assemblaggio dei pacchetti nei record DTLS da decrittografare.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-264">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="dfa3f-265">Questi buffer vengono passati come parametri al servizio ***nx_secure_dtls_session_create*** . per altre informazioni, vedere riferimento all'API.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-265">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="dfa3f-266">I certificati attendibili che sono stati inizializzati vengono quindi aggiunti al blocco di controllo della sessione DTLS creato tramite il servizio ***nx_secure_dtls_session_trusted_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="dfa3f-266">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="dfa3f-267">Se non si aggiunge un certificato, la sessione client di DTLS non riuscirà perché il protocollo DTLS non sarà in grado di autenticare gli host server remoti.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-267">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="dfa3f-268">Una volta creata l'archivio certificati attendibili, la sessione può essere usata per stabilire una connessione client TLS sicura.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-268">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="dfa3f-269">Chiamate dell'interfaccia dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="dfa3f-269">Application Interface Calls</span></span>

<span data-ttu-id="dfa3f-270">Le applicazioni NetX sicure DTLS in genere eseguono chiamate di funzione dall'interno dei thread dell'applicazione in esecuzione con ThreadX RTO.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-270">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="dfa3f-271">Alcune inizializzazioni, in particolare per i protocolli di comunicazione di rete sottostanti (ad esempio UDP e IP), possono essere chiamate da \*\**tx_application_define *.**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-271">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="dfa3f-272">Per ulteriori informazioni sull'inizializzazione delle comunicazioni di rete, vedere il manuale dell'utente di NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-272">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="dfa3f-273">DTLS USA in modo intensivo le routine di crittografia che sono operazioni che richiedono un utilizzo intensivo del processore.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-273">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="dfa3f-274">In genere, queste operazioni verranno eseguite nel contesto del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-274">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="dfa3f-275">Avvio della sessione di DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-275">DTLS Session Start</span></span>

<span data-ttu-id="dfa3f-276">Per il funzionamento di DTLS è necessario un protocollo di rete a livello di trasporto sottostante.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-276">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="dfa3f-277">Il protocollo usato in genere è TCP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-277">The protocol typically used is TCP.</span></span> <span data-ttu-id="dfa3f-278">Per stabilire una sessione TLS sicura NetX, è necessario creare una **NX_UDP_SOCKET** e passarla al servizio **_Nx_secure_dtls_client_session_start_** per i client DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-278">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="dfa3f-279">I server DTLS funzionano in modo diverso.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-279">DTLS Servers operate differently.</span></span> <span data-ttu-id="dfa3f-280">Il socket UDP usato per le richieste client DTLS in ingresso è contenuto all'interno del blocco di controllo NX_SECURE_DTLS_SERVER e viene inizializzato nella chiamata a \***nx_secure_dtls_server_create** _, che accetta la porta UDP locale come parametro.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-280">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="dfa3f-281">Il _*_nx_secure_dtls_server_start_*_ del servizio viene quindi utilizzato per avviare il server DTLS per la gestione delle richieste in ingresso.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-281">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="dfa3f-282">Tutte le richieste in ingresso vengono gestite nelle routine di callback fornite per _nx_secure_dtls_server_create \*: una per le connessioni e una per le notifiche di ricezione. L'applicazione deve gestire l'avvio della sessione DTLS quando viene ricevuta una notifica di connessione (la chiamata a Connect Notify viene richiamata da DTLS) chiamando \***nx_secure_dtls_server_session_start**_.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-282">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="dfa3f-283">L'applicazione deve inoltre gestire i dati in ingresso quando viene richiamato il callback di notifica di ricezione (che segue un handshake DTLS completato) chiamando _ *_nx_secure_dtls_session_receive_* \*.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-283">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="dfa3f-284">I dettagli di questa operazione sono disponibili nell'esempio precedente e nella Guida di riferimento alle API per ognuno dei servizi menzionati in precedenza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-284">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="dfa3f-285">Allocazione pacchetti DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-285">DTLS Packet Allocation</span></span>

<span data-ttu-id="dfa3f-286">NetX Secure DTLS usa la stessa struttura di pacchetti di NetX/NetXDuo TCP (***NX_PACKET** _) ad eccezione del fatto che anziché chiamare il servizio _*_nx_packet_allocate_*_ , è necessario chiamare il servizio _ *_nx_secure_dtls_packet_allocate_** in modo che lo spazio per l'intestazione DTLS possa essere allocato correttamente.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-286">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="dfa3f-287">Invio sessione DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-287">DTLS Session Send</span></span>

<span data-ttu-id="dfa3f-288">Una volta avviata la sessione TLS, l'applicazione può inviare dati utilizzando il servizio ***nx_secure_dtls_session_send*** .</span><span class="sxs-lookup"><span data-stu-id="dfa3f-288">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="dfa3f-289">Il servizio di invio è identico in uso al servizio ***nx_udp_socket_send** _, accettando una struttura di dati _ *_NX_PACKET_** contenente i dati inviati, un indirizzo IP di destinazione e una porta UDP di destinazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-289">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="dfa3f-290">Quando si inviano dati con nx_secure_dtls_session_send, è importante usare lo stesso indirizzo IP e la stessa porta usati per stabilire la sessione DTLS, a meno che non esista un meccanismo per spostare la sessione in un nuovo indirizzo e una porta UDP in tempo reale (questo non è comune).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-290">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="dfa3f-291">Tutti i dati inviati tramite DTLS verranno crittografati dallo stack NX Secure DTLS e dalle routine di crittografia configurate prima di essere inviate.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-291">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="dfa3f-292">Ricezione sessione DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-292">DTLS Session Receive</span></span>

<span data-ttu-id="dfa3f-293">Una volta avviata la sessione DTLS, l'applicazione può iniziare a ricevere dati utilizzando il servizio \***nx_secure_Dtls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-293">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="dfa3f-294">Analogamente all'invio della sessione DTLS, questo servizio è identico a _ *_nx_udp_socket_receive_* \*, ad eccezione del fatto che i dati in ingresso vengono decrittografati e verificati dallo stack DTLS prima di essere restituiti nella struttura del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-294">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="dfa3f-295">Chiusura sessione TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-295">TLS Session Close</span></span>

<span data-ttu-id="dfa3f-296">Una volta completata la sessione DTLS, il client e il server DTLS devono inviare un avviso CloseNotify all'altro lato per arrestare la sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-296">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="dfa3f-297">Entrambi i lati devono ricevere ed elaborare l'avviso per garantire una corretta chiusura della sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-297">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="dfa3f-298">Se l'host remoto invia un avviso CloseNotify, tutte le chiamate al servizio \***nx_secure_dtls_session_receive** _ elaborerà l'avviso, invierà l'avviso corrispondente all'host remoto e restituirà il valore _ *_NX_SECURE_TLS_SESSION_CLOSED_* \*.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-298">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="dfa3f-299">Una volta chiusa la sessione, eventuali ulteriori tentativi di invio o ricezione di dati con la sessione DTLS avranno esito negativo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-299">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="dfa3f-300">Se l'applicazione desidera chiudere la sessione TLS, il servizio \***nx_secure_dtls_session_end** _ deve essere chiamato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-300">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="dfa3f-301">Il servizio invierà l'avviso CloseNotify ed elaborerà la risposta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-301">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="dfa3f-302">Se la risposta non viene ricevuta, viene restituito un valore di errore _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, che indica che la sessione DTLS non è stata arrestata in modo corretto, una possibile violazione della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-302">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="dfa3f-303">Avvisi TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-303">TLS/DTLS Alerts</span></span>

<span data-ttu-id="dfa3f-304">TLS/DTLS è progettato per garantire la massima sicurezza, quindi qualsiasi comportamento errato nel protocollo viene considerato una potenziale violazione della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-304">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="dfa3f-305">Per questo motivo, gli eventuali errori di elaborazione dei messaggi o di crittografia/decrittografia sono considerati errori irreversibili che terminano immediatamente l'handshake o la sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-305">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="dfa3f-306">Anche se la gestione degli errori in un'applicazione locale è relativamente semplice, l'host remoto deve essere in grado di rilevare che si è verificato un errore per gestire correttamente la situazione ed evitare ulteriori possibili violazioni della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-306">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="dfa3f-307">Per questo motivo, TLS/DTLS invierà un messaggio di *avviso* all'host remoto su qualsiasi errore.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-307">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="dfa3f-308">Gli avvisi vengono gestiti in modo analogo a qualsiasi altro messaggio TLS/DTLS e vengono crittografati durante la sessione per impedire a un utente malintenzionato di raccogliere informazioni dal tipo di avviso fornito.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-308">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="dfa3f-309">Durante l'handshake, gli avvisi inviati hanno un ambito limitato per limitare la quantità di informazioni che possono essere ottenute da un potenziale utente malintenzionato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-309">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="dfa3f-310">L'avviso CloseNotify, usato per chiudere la sessione TLS/DTLS, è l'unico avviso non irreversibile.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-310">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="dfa3f-311">Sebbene venga considerato un avviso e venga inviato come messaggio di avviso, un CloseNotify è diverso dagli altri avvisi in quanto non indica che si è verificato un errore.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-311">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="dfa3f-312">Rinegoziazione e ripresa della sessione TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-312">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="dfa3f-313">TLS supporta la nozione di "rinegoziazione", che è semplicemente una rinegoziazione dei parametri della sessione TLS all'interno del contesto di una sessione TLS esistente.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-313">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="dfa3f-314">La *ripresa* della sessione TLS non può essere confusa con la *rinegoziazione* della sessione, nonostante alcune analogie.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-314">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="dfa3f-315">Quando la *rinegoziazione* della sessione comporta l'avvio di un nuovo handshake in una sessione TLS esistente, la *ripresa* della sessione è una funzionalità puramente facoltativa che prevede il riavvio di una sessione TLS chiusa senza eseguire un handshake TLS completo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-315">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="dfa3f-316">NX Secure DTLS gestisce le richieste di rinegoziazione in ingresso dagli host remoti.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-316">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="dfa3f-317">**Non supporta la ripresa** della sessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-317">It does **not** support session resumption.</span></span> <span data-ttu-id="dfa3f-318">Una descrizione più completa di queste funzionalità è disponibile nel capitolo 3 della Guida dell'utente di NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-318">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="dfa3f-319">Layering del protocollo</span><span class="sxs-lookup"><span data-stu-id="dfa3f-319">Protocol Layering</span></span>

<span data-ttu-id="dfa3f-320">Il protocollo TLS (e quindi DTLS) si inserisce nello stack di rete tra il livello di trasporto (ad esempio TCP o UDP) e il livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-320">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="dfa3f-321">TLS viene a volte considerato un protocollo di livello trasporto, di conseguenza la sicurezza a *livello di trasporto* , ma poiché funge da applicazione per quanto riguarda i protocolli di rete sottostanti, viene talvolta raggruppato nel livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-321">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="dfa3f-322">TLS richiede un protocollo di livello trasporto che supporta il recapito in ordine e senza perdita di contenuti, ad esempio TCP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-322">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="dfa3f-323">A causa di questo requisito, TLS non può essere eseguito su UDP Poiché UDP non garantisce il recapito di datagrammi.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-323">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="dfa3f-324">*DTLS* è una versione modificata di TLS. viene usato per le applicazioni che richiedono la sicurezza di TLS su un protocollo di datagramma come UDP.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-324">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![Diagramma di un livello del protocollo TLS.](media/image6.png)

<span data-ttu-id="dfa3f-326">**Figura 4-livelli di protocollo TCP/IP, UDP e TLS/DTLS**</span><span class="sxs-lookup"><span data-stu-id="dfa3f-326">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="dfa3f-327">Sicurezza e crittografia delle comunicazioni di rete</span><span class="sxs-lookup"><span data-stu-id="dfa3f-327">Network Communications Security and Encryption</span></span>

<span data-ttu-id="dfa3f-328">La protezione delle comunicazioni tramite reti pubbliche e Internet è un argomento di importanza critica e l'oggetto di un ampio numero di libri, articoli e soluzioni.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-328">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="dfa3f-329">Questo argomento è molto complesso, ma può essere ridotto a una semplice idea: invio di informazioni su una rete, in modo che solo la destinazione prevista possa accedere o modificare tali informazioni.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-329">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="dfa3f-330">Questa operazione suddivide in tre concetti importanti: segretezza, integrità e autenticazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-330">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="dfa3f-331">Il protocollo TLS/DTLS fornisce soluzioni per tutti e tre.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-331">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="dfa3f-332">La crittografia viene usata in modi diversi per garantire segrete, integrità e autenticazione nei protocolli TLS e DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-332">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="dfa3f-333">La crittografia deve essere fornita a TLS o DTLS al momento della creazione di una sessione o di un'istanza del server, poiché TLS fornisce un framework flessibile per l'uso della crittografia e non la crittografia stessa.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-333">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="dfa3f-334">NetX Secure DTLS fornisce le routine di crittografia necessarie per la maggior parte delle applicazioni, pertanto non è necessario preoccuparsi di trovare la crittografia appropriata.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-334">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="dfa3f-335">Una descrizione più dettagliata di questi argomenti è disponibile nel capitolo 3 del manuale dell'utente di NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-335">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="dfa3f-336">Estensioni TLS e DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-336">TLS and DTLS Extensions</span></span>

<span data-ttu-id="dfa3f-337">TLS (e pertanto DTLS) fornisce una serie di estensioni che forniscono funzionalità aggiuntive per alcune applicazioni.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-337">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="dfa3f-338">Queste estensioni vengono in genere inviate come parte dei messaggi ClientHello o ServerHello, indicando a un host remoto il desiderio di usare un'estensione o fornire dettagli aggiuntivi da usare per stabilire la sessione TLS sicura.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-338">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="dfa3f-339">NetX Secure DTLS supporta tutte le estensioni disponibili in NetX Secure TLS e una descrizione completa di queste sono disponibili nella Guida per l'utente di NetX Secure TLS, capitolo 3.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-339">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="dfa3f-340">Authentication Methods</span><span class="sxs-lookup"><span data-stu-id="dfa3f-340">Authentication Methods</span></span>

<span data-ttu-id="dfa3f-341">TLS e DTLS forniscono il Framework per stabilire una connessione sicura tra due dispositivi su una rete non sicura, ma parte del problema sta conoscendo l'identità del dispositivo all'altra estremità della connessione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-341">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="dfa3f-342">Senza un meccanismo per l'autenticazione dell'identità degli host remoti, diventa un'operazione semplice che un utente malintenzionato potrebbe rappresentare come un dispositivo attendibile.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-342">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="dfa3f-343">Inizialmente, potrebbe sembrare che l'uso di indirizzi IP, gli indirizzi MAC hardware o DNS forniscono un livello di attendibilità relativamente elevato per l'identificazione degli host in una rete, ma con la natura della tecnologia TCP/IP e la facilità con cui gli indirizzi possono essere falsificati e le voci DNS danneggiate, ad esempio tramite l'avvelenamento della cache DNS, risulta evidente che TLS necessita di un ulteriore livello di protezione contro le identità fraudolente.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-343">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="dfa3f-344">Esistono diversi meccanismi che possono fornire questo livello aggiuntivo di autenticazione per TLS, ma il più comune è il *certificato digitale.*</span><span class="sxs-lookup"><span data-stu-id="dfa3f-344">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="dfa3f-345">Altri meccanismi includono chiavi precondivise (PSK) e schemi di password.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-345">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="dfa3f-346">Certificati digitali</span><span class="sxs-lookup"><span data-stu-id="dfa3f-346">Digital Cerificates</span></span>

<span data-ttu-id="dfa3f-347">I certificati digitali sono il metodo più comune per autenticare un host remoto in TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-347">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="dfa3f-348">In sostanza, un certificato digitale è un documento con una formattazione specifica che fornisce informazioni sull'identità per un dispositivo in una rete di computer.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-348">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="dfa3f-349">TLS usa in genere un formato denominato X. 509, uno standard sviluppato dall'Unione di telecomunicazione internazionale, sebbene sia possibile usare altri formati di certificati se gli host TLS possono accettare il formato usato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-349">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="dfa3f-350">X. 509 definisce un formato specifico per i certificati e varie codifiche che possono essere utilizzate per produrre un documento digitale.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-350">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="dfa3f-351">La maggior parte dei certificati X. 509 usati con TLS viene codificata usando una variante di ASN. 1, un altro standard di telecomunicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-351">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="dfa3f-352">All'interno di ASN. 1 sono disponibili diverse codifiche digitali, ma la codifica più comune per i certificati TLS è lo standard Distinguished Encoding Rules (DER).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-352">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="dfa3f-353">DER è un subset semplificato delle regole di codifica di base ASN. 1 progettato per essere non ambiguo, semplificando l'analisi.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-353">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="dfa3f-354">In transito, i certificati TLS vengono in genere codificati in DER binario e questo è il formato previsto da NetX Secure per i certificati X. 509.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-354">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="dfa3f-355">Sebbene i certificati binari in formato DER vengano usati nel protocollo TLS effettivo, possono essere generati e archiviati in una serie di codifiche diverse, con estensioni di file quali PEM, CRT e P12.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-355">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="dfa3f-356">Le diverse varianti vengono utilizzate da diverse applicazioni di produttori diversi, ma in genere possono essere convertite in DER utilizzando strumenti ampiamente disponibili.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-356">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="dfa3f-357">La più comune delle codifiche alternative dei certificati è PEM.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-357">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="dfa3f-358">Il formato PEM (da Privacy-Enhanced mail) è una versione con codifica 64 della codifica DER utilizzata spesso in quanto la codifica produce testo stampabile che può essere facilmente inviato tramite posta elettronica o protocolli basati sul Web.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-358">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="dfa3f-359">La generazione di un certificato per l'applicazione NetX Secure è generalmente al di fuori dell'ambito di questo manuale, ma lo strumento da riga di comando OpenSSL ([www.openssl.org](http://www.openssl.org)) è ampiamente disponibile ed è in grado di eseguire la conversione tra la maggior parte dei formati.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-359">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="dfa3f-360">A seconda dell'applicazione, è possibile generare certificati, fornire certificati da un produttore o da un'organizzazione governativa oppure acquistare certificati da un'autorità di certificazione commerciale.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-360">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="dfa3f-361">Per usare un certificato digitale nell'applicazione NetX Secure, è necessario innanzitutto convertire il certificato in un formato DER binario e, facoltativamente, convertire la chiave privata associata ("esponente privato" per RSA, ad esempio) in un formato binario, in genere una chiave RSA codificata in formato PKCS # 1.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-361">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="dfa3f-362">Al termine della conversione, è possibile caricare il certificato e la chiave privata nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-362">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="dfa3f-363">Le opzioni possibili includono l'uso di un file system basato su Flash o la generazione di una matrice C dai dati (usando uno strumento come "XXD" da Linux) e la compilazione del certificato e della chiave nell'applicazione come dati costanti.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-363">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="dfa3f-364">Una volta caricato il certificato nel dispositivo, è possibile usare l'API DTLS per associare il certificato a una sessione o a un server di DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-364">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="dfa3f-365">Per informazioni dettagliate ed esempi su come usare i certificati X. 509 con NetX Secure DTLS, vedere la sezione relativa all'importazione di certificati X. 509 in NetX Secure nel manuale dell'utente di NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-365">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="dfa3f-366">Per ulteriori informazioni, fare riferimento ai seguenti servizi DTLS nelle informazioni di riferimento sulle API:</span><span class="sxs-lookup"><span data-stu-id="dfa3f-366">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="dfa3f-367">nx_secure_x509_certificate_initialize,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-367">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="dfa3f-368">nx_secure_dtls_session_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-368">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="dfa3f-369">nx_secure_dtls_server_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-369">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="dfa3f-370">nx_secure_dtls_session_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-370">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="dfa3f-371">nx_secure_dtls_server_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-371">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="dfa3f-372">nx_secure_dtls_session_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-372">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="dfa3f-373">nx_secure_dtls_server_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="dfa3f-373">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="dfa3f-374">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="dfa3f-374">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="dfa3f-375">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="dfa3f-375">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="dfa3f-376">Specifiche del certificato client TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-376">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="dfa3f-377">Le implementazioni client di DTLS in genere non richiedono il caricamento di un certificato locale nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-377">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="dfa3f-378">Un certificato locale è un certificato che identifica il dispositivo locale.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-378">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="dfa3f-379">In particolare, un certificato locale fornisce informazioni sull'identità per il dispositivo su cui viene caricata l'applicazione TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-379">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="dfa3f-380">L'eccezione è rappresentata dal caso in cui l'autenticazione del certificato client è abilitata, ma è meno comune.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-380">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="dfa3f-381">Un client DTLS richiede che venga caricato almeno un certificato attendibile (è possibile che ne venga caricato altri se richiesto) e che sia disponibile spazio per l'allocazione di un certificato remoto.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-381">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="dfa3f-382">Un certificato attendibile è un certificato che fornisce una base per l'attendibilità e l'autenticazione del dispositivo remoto, direttamente o tramite un'infrastruttura a chiave pubblica (PKI).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-382">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="dfa3f-383">La radice della catena di trust è in genere denominata autorità di certificazione o certificato della CA.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-383">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="dfa3f-384">Un certificato remoto fa riferimento al certificato inviato dall'host remoto durante l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-384">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="dfa3f-385">Fornisce l'identità per quell'host remoto ed è autenticato confrontandolo con un certificato attendibile nel dispositivo locale.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-385">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="dfa3f-386">Per ulteriori informazioni sull'aggiunta di certificati attendibili e sull'allocazione dello spazio per i certificati remoti, vedere le informazioni di riferimento sulle API TLS per i servizi seguenti: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-386">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="dfa3f-387">Specifiche del certificato del server TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-387">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="dfa3f-388">Le implementazioni del server DTLS in genere non richiedono il caricamento di certificati "Trusted" sul dispositivo o sui certificati remoti da allocare.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-388">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="dfa3f-389">L'eccezione è rappresentata dal momento in cui è abilitata l'autenticazione del certificato client.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-389">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="dfa3f-390">Un server TLS richiede il caricamento di un certificato "locale" (o "identità"), in modo che il server possa fornirlo al client remoto durante l'handshake TLS per autenticare il server al client.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-390">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="dfa3f-391">Per altre informazioni sul caricamento dei certificati locali per l'uso con le applicazioni server TLS NetX, vedere le informazioni di riferimento sulle API per i servizi seguenti: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-391">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="dfa3f-392">Chiavi precondivise (PSK)</span><span class="sxs-lookup"><span data-stu-id="dfa3f-392">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="dfa3f-393">Un meccanismo alternativo per fornire l'autenticazione di identificazione in TLS è il concetto di chiavi precondivise (PSK).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-393">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="dfa3f-394">L'uso di un ciphersuite PSK Elimina la necessità di eseguire le operazioni di crittografia a chiave pubblica con utilizzo intensivo del processore, un vantaggio per i dispositivi embedded con vincoli di risorse.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-394">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="dfa3f-395">La PSK sostituisce il certificato nell'handshake TLS/DTLS e viene usato al posto del segreto pre-master crittografato per la generazione della chiave di sessione TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-395">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="dfa3f-396">I ciphersuites di PSK sono limitati nel senso che un segreto condiviso deve essere presente in entrambi i dispositivi prima che sia possibile stabilire una sessione TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-396">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="dfa3f-397">Ciò significa che i dispositivi devono essere stati caricati con tale segreto usando un mezzo sicuro diverso da una connessione PSK TLS. precondivise può essere aggiornato tramite una connessione PSK TLS, ma il dispositivo deve necessariamente iniziare con una PSK che viene caricata tramite un altro meccanismo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-397">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="dfa3f-398">Ad esempio, un dispositivo sensore e il relativo dispositivo gateway potrebbero essere caricati con precondivise nella Factory prima della spedizione oppure è possibile usare una connessione TLS standard (con un certificato) per caricare la PSK.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-398">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="dfa3f-399">Le ciphersuites PSK sono disponibili in un paio di forme, descritte in RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-399">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="dfa3f-400">Il primo usa le chiavi RSA o Diffie-Hellman utilizzate allo stesso modo delle chiavi pubbliche trasmesse nel certificato negli handshake TLS standard.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-400">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="dfa3f-401">Il secondo formato, che è più usato in un ambiente con vincoli di risorse, usa un PSK usato per generare direttamente le chiavi della sessione (per l'uso da parte di AES, ad esempio), evitando l'uso delle operazioni RSA o Diffie-Hellman onerose.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-401">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="dfa3f-402">NetX Secure supporta la seconda forma di PSK ciphersuites, consentendo alle applicazioni di rimuovere tutto il codice di crittografia a chiave pubblica e l'utilizzo della memoria.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-402">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="dfa3f-403">La PSK stessa non è una chiave AES, ma può essere considerata come una password da cui vengono generate le chiavi effettive.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-403">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="dfa3f-404">Esistono alcune restrizioni relative al valore di PSK, sebbene i valori più lunghi forniscano maggiore sicurezza (come per le password).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-404">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="dfa3f-405">Per usare PSK con l'applicazione NetX Secure, è necessario innanzitutto definire la macro globale **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-405">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="dfa3f-406">Questa operazione viene in genere eseguita tramite le impostazioni del compilatore, ma la definizione può anche essere inserita nel file di intestazione nx_secure_tls. h.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-406">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="dfa3f-407">Con la macro definita, il supporto di PSK ciphersuite verrà compilato nell'applicazione NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-407">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="dfa3f-408">Con il supporto di PSK abilitato, è possibile usare l'API DTLS per configurare precondivise per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-408">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="dfa3f-409">Ogni PSK richiederà un valore PSK (il segreto effettivo "Key"-Mantieni questo valore safe), un valore "Identity" usato per identificare il PSK specifico e un "hint di identità" usato da un server TLS per scegliere un particolare valore PSK.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-409">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="dfa3f-410">La PSK può essere qualsiasi valore binario perché non viene mai inviato tramite una connessione di rete.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-410">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="dfa3f-411">La PSK può essere di qualsiasi valore fino a 64 byte di lunghezza.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-411">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="dfa3f-412">L'identità e l'hint devono essere stringhe di caratteri stampabili formattate con UTF-8.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-412">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="dfa3f-413">I valori Identity e hint possono avere una lunghezza fino a 128 byte.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-413">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="dfa3f-414">Identity e PSK formano una coppia univoca che viene caricata in ogni dispositivo della rete che deve comunicare tra loro.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-414">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="dfa3f-415">Il "suggerimento" viene usato principalmente per la definizione di profili applicazione specifici per raggruppare precondivise in base alla funzione o al servizio.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-415">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="dfa3f-416">Questi valori devono essere concordati in anticipo e dipendono dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-416">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="dfa3f-417">Ad esempio, l'applicazione server della riga di comando OpenSSL (con la funzionalità PSK abilitata) usa la stringa predefinita "Client_identity", che deve essere fornita da un client TLS per continuare con l'handshake TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-417">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="dfa3f-418">Per altre informazioni su precondivise, vedere le informazioni di riferimento sulle API NetX sicure per i servizi seguenti: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-418">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="dfa3f-419">Importazione di certificati X. 509 in NetX Secure</span><span class="sxs-lookup"><span data-stu-id="dfa3f-419">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="dfa3f-420">Per la maggior parte delle connessioni TLS su Internet sono necessari certificati digitali.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-420">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="dfa3f-421">I certificati forniscono un metodo per l'autenticazione di host sconosciuti in precedenza tramite Internet tramite l'utilizzo di intermediari attendibili, in genere detti *autorità di certificazione* o CA.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-421">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="dfa3f-422">Per connettere il dispositivo NetX Secure a un servizio cloud commerciale, ad esempio Amazon Web Services, sarà necessario importare i certificati nell'applicazione eseguendone il caricamento nel dispositivo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-422">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="dfa3f-423">Insieme ai certificati, a volte è necessaria anche una *chiave privata* associata al certificato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-423">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="dfa3f-424">In alcune applicazioni, ad esempio client TLS quando non si usa l'autenticazione del certificato client, il certificato da solo sarà sufficiente, ma se il certificato viene usato per identificare il dispositivo, sarà necessaria una chiave privata.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-424">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="dfa3f-425">Le chiavi private vengono in genere generate quando si crea il certificato e vengono archiviate in un file separato, spesso crittografate con una password.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-425">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="dfa3f-426">Per una descrizione dettagliata dell'importazione di certificati in applicazioni NetX Secure, vedere il capitolo 3 del manuale dell'utente di NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-426">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="dfa3f-427">Autenticazione del certificato client in NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-427">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="dfa3f-428">Quando si usa l'autenticazione del certificato X. 509, il protocollo TLS/DTLS richiede che l'istanza del server DTLS fornisca un certificato per l'identificazione, ma per impostazione predefinita l'istanza del client DTLS non deve fornire un certificato per l'autenticazione, usando invece un'altra forma di autenticazione, ad esempio una combinazione di nome utente/password.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-428">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="dfa3f-429">Questo corrisponde all'uso più comune di TLS in Internet per i siti Web.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-429">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="dfa3f-430">Ad esempio, un sito di vendita al dettaglio online deve dimostrare a un potenziale cliente che utilizza un Web browser che il server è legittimo, ma l'utente utilizzerà un account di accesso/password per accedere a un account specifico.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-430">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="dfa3f-431">Tuttavia, il caso predefinito non è sempre auspicabile, quindi TLS/DTLS facoltativamente consente all'istanza del server DTLS di richiedere un certificato dal client remoto.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-431">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="dfa3f-432">Quando questa funzionalità è abilitata, il server DTLS invierà un messaggio CertificateRequest al client DTLS durante l'handshake.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-432">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="dfa3f-433">Il client deve rispondere con un certificato autonomo e un messaggio CertificateVerify contenente un token crittografico per dimostrare che il client possiede la chiave privata corrispondente associata a tale certificato.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-433">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="dfa3f-434">Se la verifica ha esito negativo o il certificato non è connesso a un certificato attendibile nel server, l'handshake TLS ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-434">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="dfa3f-435">Esistono due casi distinti per l'autenticazione del certificato client in TLS: le sezioni seguenti illustrano entrambi i casi.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-435">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="dfa3f-436">Autenticazione del certificato client per client DTLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-436">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="dfa3f-437">Un client DTLS può tentare una connessione a un server che richiede un certificato per l'autenticazione client.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-437">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="dfa3f-438">In questo caso il client deve fornire un certificato al server e verificare che sia proprietario della chiave privata corrispondente o che il server terminerà l'handshake DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-438">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="dfa3f-439">In NetX Secure DTLS non è disponibile alcuna configurazione speciale per supportare questa funzionalità, ma l'applicazione dovrà fornire un certificato di identificazione locale per l'istanza del client TLS usando il servizio *nx_secure_tls_session_local_certificate_add* .</span><span class="sxs-lookup"><span data-stu-id="dfa3f-439">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="dfa3f-440">Se l'applicazione non fornisce alcun certificato ma il server remoto usa l'autenticazione del certificato client e richiede un certificato, l'handshake DTLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-440">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="dfa3f-441">Il certificato fornito alla sessione DTLS con *nx_secure_dtls_session_local_certificate_add* deve essere riconosciuto dal server remoto per completare l'handshake DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-441">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="dfa3f-442">Autenticazione del certificato client per i server TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-442">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="dfa3f-443">Il caso del server DTLS per l'autenticazione del certificato client è leggermente più complesso rispetto al caso del client di DTLS perché la funzionalità è facoltativa.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-443">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="dfa3f-444">In questo caso, il server TLS deve richiedere specificamente un certificato dal client TLS remoto, quindi elaborare il messaggio CertificateVerify per verificare che il client remoto sia proprietario della chiave privata corrispondente, quindi il server deve verificare che il certificato fornito dal client possa essere tracciato a un certificato nell'archivio certificati attendibili locale.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-444">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="dfa3f-445">Nelle istanze del server TLS protette NetX, l'autenticazione del certificato client è controllata dai servizi *nx_secure_dtls_server_x509_client_verify_configure* e *nx_secure_dtls_server_x509_client_verify_disable* .</span><span class="sxs-lookup"><span data-stu-id="dfa3f-445">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="dfa3f-446">Per abilitare l'autenticazione del certificato client, un'applicazione deve chiamare *nx_secure_dtls_server_x509_client_verify_configure* con l'istanza della sessione del server DTLS prima di chiamare *nx_secure_dtls_server_start*.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-446">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="dfa3f-447">Per la verifica è necessario allocare spazio per i certificati client in ingresso forniti come parametro per *nx_secure_dtls_server_x509_client_verify_configure.*</span><span class="sxs-lookup"><span data-stu-id="dfa3f-447">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="dfa3f-448">Si noti che il buffer deve essere sufficientemente grande da contenere la catena di certificati a dimensione massima fornita da un client per *il numero di sessioni del server DTLS*.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-448">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="dfa3f-449">Ogni sessione del server richiede spazio che verrà allocato dal singolo buffer fornito.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-449">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="dfa3f-450">Verificare che il buffer sia sufficientemente grande o che si verifichi un errore se la catena di certificati client specificata è troppo grande.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-450">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="dfa3f-451">Quando è abilitata l'autenticazione del certificato client, il server DTLS richiederà un certificato dal client DTLS remoto durante l'handshake DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-451">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="dfa3f-452">In NetX Secure DTLS server, il certificato client viene verificato rispetto all'archivio dei certificati attendibili creati con *nx_secure_dtls_server_trusted_certificate_add* seguendo la catena di emittenti X. 509.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-452">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="dfa3f-453">Il client remoto deve fornire una catena che connette il certificato di identità a un certificato nell'archivio attendibile oppure l'handshake DTLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-453">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="dfa3f-454">Inoltre, se l'elaborazione del messaggio CertificateVerify ha esito negativo, anche l'handshake DTLS avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-454">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="dfa3f-455">I metodi di firma usati per il metodo CertificateVerify sono corretti per TLS versione 1,0 e TLS versione 1,1 e sono specificati dal server TLS in TLS versione 1,2, su cui si basa NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-455">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="dfa3f-456">Per DTLS 1,2, i metodi di firma supportati in genere seguono i metodi pertinenti forniti nella tabella del metodo crittografico, ma in genere RSA con SHA-256 (vedere la sezione "crittografia in NetX Secure TLS" per altre informazioni sull'inizializzazione di TLS con i metodi di crittografia).</span><span class="sxs-lookup"><span data-stu-id="dfa3f-456">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="dfa3f-457">Crittografia in NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="dfa3f-457">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="dfa3f-458">TLS definisce un protocollo in cui è possibile usare la crittografia per proteggere le comunicazioni di rete.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-458">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="dfa3f-459">Per questo motivo, lascia che la crittografia effettiva venga usata in modo abbastanza ampio per gli utenti TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-459">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="dfa3f-460">La specifica richiede l'implementazione di un solo ciphersuite: nel caso di TLS 1,2, ciphersuite è TLS_RSA_WITH_AES_128_CBC_SHA, che indica l'uso di RSA per le operazioni a chiave pubblica, AES in modalità CBC con chiavi a 128 bit per la crittografia della sessione e SHA-1 per gli hash di autenticazione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-460">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="dfa3f-461">Essendo conforme a TLS 1,2, NetX Secure Abilita il ciphersuite obbligatorio TLS_RSA_WITH_AES_128_CBC_SHA per impostazione predefinita, ma dato il numero di possibili implementazioni per ciascuno dei metodi crittografici a causa di funzionalità hardware e altre considerazioni, NetX Secure fornisce un'API di crittografia generica che consente a un utente di specificare i metodi crittografici da usare con TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-461">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="dfa3f-462">Il meccanismo di API crittografico generico consente inoltre agli utenti di implementare il proprio ciphersuites, ma questa opzione è consigliata per gli utenti avanzati che hanno familiarità con le estensioni e ciphersuites di TLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-462">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="dfa3f-463">Se si è interessati a supportare il proprio ciphersuites, contattare il rappresentante della logica Express.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-463">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="dfa3f-464">Per informazioni dettagliate su come configurare i metodi crittografici per DTLS, vedere il manuale dell'utente di NetX Secure TLS, capitolo 3.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-464">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="dfa3f-465">Lo stesso processo si applica sia a TLS che a DTLS.</span><span class="sxs-lookup"><span data-stu-id="dfa3f-465">The same process applies to both TLS and DTLS.</span></span>
