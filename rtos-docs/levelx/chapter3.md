---
title: Supporto per NAND LevelX di Azure RTO
description: La memoria flash NAND viene comunemente utilizzata all'interno di LevelX per l'archiviazione di dati di grandi dimensioni, che è tipica dei file System.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822172"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="4314c-103">Capitolo 3-supporto per NAND LevelX di Azure RTO</span><span class="sxs-lookup"><span data-stu-id="4314c-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="4314c-104">La memoria flash NAND viene in genere utilizzata per l'archiviazione di dati di grandi dimensioni, che è tipica dei file System.</span><span class="sxs-lookup"><span data-stu-id="4314c-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="4314c-105">La memoria NAND è costituita da *blocchi*.</span><span class="sxs-lookup"><span data-stu-id="4314c-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="4314c-106">All'interno di ogni blocco NAND è presente una serie di *pagine*.</span><span class="sxs-lookup"><span data-stu-id="4314c-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="4314c-107">I blocchi NAND sono cancellabili, il che significa che tutte le pagine all'interno del blocco NAND vengono cancellate (impostate su tutte).</span><span class="sxs-lookup"><span data-stu-id="4314c-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="4314c-108">Ogni pagina di blocco NAND ha un set di *byte di riserva* usati da Azure RTO LevelX per la contabilità, la gestione dei blocchi non corretti e il rilevamento degli errori.</span><span class="sxs-lookup"><span data-stu-id="4314c-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="4314c-109">Le pagine di blocco NAND sono disponibili in un'ampia gamma di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="4314c-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="4314c-110">Le dimensioni di pagina più comuni sono:</span><span class="sxs-lookup"><span data-stu-id="4314c-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="4314c-111">**Dimensioni pagina**</span><span class="sxs-lookup"><span data-stu-id="4314c-111">**Page Size**</span></span> | <span data-ttu-id="4314c-112">**Byte di riserva**</span><span class="sxs-lookup"><span data-stu-id="4314c-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="4314c-113">256</span><span class="sxs-lookup"><span data-stu-id="4314c-113">256</span></span>           | <span data-ttu-id="4314c-114">8</span><span class="sxs-lookup"><span data-stu-id="4314c-114">8</span></span>               |
| <span data-ttu-id="4314c-115">512</span><span class="sxs-lookup"><span data-stu-id="4314c-115">512</span></span>           | <span data-ttu-id="4314c-116">16</span><span class="sxs-lookup"><span data-stu-id="4314c-116">16</span></span>              |
| <span data-ttu-id="4314c-117">2048</span><span class="sxs-lookup"><span data-stu-id="4314c-117">2048</span></span>          | <span data-ttu-id="4314c-118">64</span><span class="sxs-lookup"><span data-stu-id="4314c-118">64</span></span>              |

<span data-ttu-id="4314c-119">La memoria NAND è diversa dalla memoria e non è presente alcun accesso diretto, ovvero non è possibile leggere la memoria NAND direttamente dal processore, ad esempio o memoria.</span><span class="sxs-lookup"><span data-stu-id="4314c-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="4314c-120">La memoria NAND può essere scritta solo dopo una cancellazione di un numero limitato di volte.</span><span class="sxs-lookup"><span data-stu-id="4314c-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="4314c-121">Anche in questo caso, questo comportamento è diverso da quello della memoria che può essere scritto per un numero illimitato di volte, purché la richiesta di scrittura stia cancellando i bit impostati.</span><span class="sxs-lookup"><span data-stu-id="4314c-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="4314c-122">Infine, i byte di riserva associati a ogni pagina sono univoci per NAND Flash.</span><span class="sxs-lookup"><span data-stu-id="4314c-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="4314c-123">Le configurazioni tipiche dei byte di riserva sono illustrate nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="4314c-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="4314c-124">**Byte di riserva**</span><span class="sxs-lookup"><span data-stu-id="4314c-124">**Spare Bytes**</span></span> | <span data-ttu-id="4314c-125">**Numeri di byte**</span><span class="sxs-lookup"><span data-stu-id="4314c-125">**Byte numbers**</span></span> | <span data-ttu-id="4314c-126">**Configuration**</span><span class="sxs-lookup"><span data-stu-id="4314c-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="4314c-127">8</span><span class="sxs-lookup"><span data-stu-id="4314c-127">8</span></span>                         | <span data-ttu-id="4314c-128">Byte 0-2:</span><span class="sxs-lookup"><span data-stu-id="4314c-128">Bytes 0-2:</span></span>     | <span data-ttu-id="4314c-129">Byte ECC</span><span class="sxs-lookup"><span data-stu-id="4314c-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="4314c-130">Byte 3, 4, 6, 7:</span><span class="sxs-lookup"><span data-stu-id="4314c-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="4314c-131">Mapping del settore LevelX</span><span class="sxs-lookup"><span data-stu-id="4314c-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="4314c-132">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="4314c-132">Byte 5:</span></span>        | <span data-ttu-id="4314c-133">Flag di blocco non valido</span><span class="sxs-lookup"><span data-stu-id="4314c-133">Bad block flag</span></span>        |
| <span data-ttu-id="4314c-134">16</span><span class="sxs-lookup"><span data-stu-id="4314c-134">16</span></span>                        | <span data-ttu-id="4314c-135">Byte 0-3, 6-7:</span><span class="sxs-lookup"><span data-stu-id="4314c-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="4314c-136">Byte ECC</span><span class="sxs-lookup"><span data-stu-id="4314c-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="4314c-137">Byte 8-11:</span><span class="sxs-lookup"><span data-stu-id="4314c-137">Bytes 8-11:</span></span>    | <span data-ttu-id="4314c-138">Mapping del settore LevelX</span><span class="sxs-lookup"><span data-stu-id="4314c-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="4314c-139">Byte 12-15:</span><span class="sxs-lookup"><span data-stu-id="4314c-139">Bytes 12-15:</span></span>   | <span data-ttu-id="4314c-140">Non utilizzato</span><span class="sxs-lookup"><span data-stu-id="4314c-140">Unused</span></span>                |
|                           | <span data-ttu-id="4314c-141">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="4314c-141">Byte 5:</span></span>        | <span data-ttu-id="4314c-142">Flag di blocco non valido</span><span class="sxs-lookup"><span data-stu-id="4314c-142">Bad block flag</span></span>        |
| <span data-ttu-id="4314c-143">64</span><span class="sxs-lookup"><span data-stu-id="4314c-143">64</span></span>                        | <span data-ttu-id="4314c-144">Byte 0:</span><span class="sxs-lookup"><span data-stu-id="4314c-144">Byte 0:</span></span>        | <span data-ttu-id="4314c-145">Flag di blocco non valido</span><span class="sxs-lookup"><span data-stu-id="4314c-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="4314c-146">Byte 2-5:</span><span class="sxs-lookup"><span data-stu-id="4314c-146">Bytes 2-5:</span></span>     | <span data-ttu-id="4314c-147">Mapping del settore LevelX</span><span class="sxs-lookup"><span data-stu-id="4314c-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="4314c-148">Byte 6-39:</span><span class="sxs-lookup"><span data-stu-id="4314c-148">Bytes 6-39:</span></span>    | <span data-ttu-id="4314c-149">Non utilizzato</span><span class="sxs-lookup"><span data-stu-id="4314c-149">Unused</span></span>                |
|                           | <span data-ttu-id="4314c-150">Byte 40-63:</span><span class="sxs-lookup"><span data-stu-id="4314c-150">Bytes 40-63:</span></span>   | <span data-ttu-id="4314c-151">Byte ECC</span><span class="sxs-lookup"><span data-stu-id="4314c-151">ECC bytes</span></span>             |

<span data-ttu-id="4314c-152">LevelX utilizza 4 dei byte di riserva di ogni pagina NAND per tenere traccia del settore logico mappato alla pagina NAND fisica.</span><span class="sxs-lookup"><span data-stu-id="4314c-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="4314c-153">Questi 4 byte vengono usati per implementare un Unsigned Integer a 32 bit con un formato proprietario di LevelX.</span><span class="sxs-lookup"><span data-stu-id="4314c-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="4314c-154">Il bit superiore del campo a 32 bit (bit 31) viene utilizzato per indicare che il mapping da settore a pagina logico è valido.</span><span class="sxs-lookup"><span data-stu-id="4314c-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="4314c-155">Se il bit è 0, le informazioni in questa pagina non sono più valide.</span><span class="sxs-lookup"><span data-stu-id="4314c-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="4314c-156">Il bit successivo, bit 30, viene usato per indicare che questa pagina è in corso di diventare obsoleta ed è in corso la scrittura di un nuovo settore.</span><span class="sxs-lookup"><span data-stu-id="4314c-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="4314c-157">Il bit 29 viene utilizzato per indicare il completamento della scrittura della voce di mapping.</span><span class="sxs-lookup"><span data-stu-id="4314c-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="4314c-158">Se il bit 29 è 0, la scrittura della voce di mapping è stata completata.</span><span class="sxs-lookup"><span data-stu-id="4314c-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="4314c-159">Se è impostato il bit 29, è in corso la scrittura della voce di mapping.</span><span class="sxs-lookup"><span data-stu-id="4314c-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="4314c-160">I bit 30 e 29 vengono usati per il ripristino da una potenziale perdita di energia durante l'aggiornamento di una nuova pagina Flash.</span><span class="sxs-lookup"><span data-stu-id="4314c-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="4314c-161">Infine, i 29 bit inferiori (28-0) contengono il numero di settore logico per la pagina.</span><span class="sxs-lookup"><span data-stu-id="4314c-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="4314c-162">**Voce di mapping di LevelX**</span><span class="sxs-lookup"><span data-stu-id="4314c-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="4314c-163">Bit/i</span><span class="sxs-lookup"><span data-stu-id="4314c-163">Bit(s)</span></span> | <span data-ttu-id="4314c-164">Significato</span><span class="sxs-lookup"><span data-stu-id="4314c-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="4314c-165">31</span><span class="sxs-lookup"><span data-stu-id="4314c-165">31</span></span>     | <span data-ttu-id="4314c-166">Flag valido.</span><span class="sxs-lookup"><span data-stu-id="4314c-166">Valid flag.</span></span> <span data-ttu-id="4314c-167">Quando l'impostazione e il settore logico non sono tutti quelli indicati, il mapping è valido</span><span class="sxs-lookup"><span data-stu-id="4314c-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="4314c-168">30</span><span class="sxs-lookup"><span data-stu-id="4314c-168">30</span></span>     | <span data-ttu-id="4314c-169">Flag obsoleto.</span><span class="sxs-lookup"><span data-stu-id="4314c-169">Obsolete flag.</span></span> <span data-ttu-id="4314c-170">Se chiaro, questo mapping è obsoleto o sta per diventare obsoleto.</span><span class="sxs-lookup"><span data-stu-id="4314c-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="4314c-171">29</span><span class="sxs-lookup"><span data-stu-id="4314c-171">29</span></span>     | <span data-ttu-id="4314c-172">La scrittura della voce di mapping è completa quando questo bit è 0</span><span class="sxs-lookup"><span data-stu-id="4314c-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="4314c-173">0-28</span><span class="sxs-lookup"><span data-stu-id="4314c-173">0-28</span></span>   | <span data-ttu-id="4314c-174">Settore logico mappato a questa pagina fisica, quando non tutti.</span><span class="sxs-lookup"><span data-stu-id="4314c-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="4314c-175">LevelX utilizza inoltre la prima pagina di ogni blocco NAND per il conteggio delle cancellazioni dei blocchi, nonché l'elenco delle pagine mappate quando il blocco è pieno.</span><span class="sxs-lookup"><span data-stu-id="4314c-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="4314c-176">Il formato della prima pagina di un blocco NAND in LevelX è illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4314c-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="4314c-177">Formato della pagina 0 del blocco LevelX</span><span class="sxs-lookup"><span data-stu-id="4314c-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="4314c-178">[Conteggio blocchi cancellati]</span><span class="sxs-lookup"><span data-stu-id="4314c-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="4314c-179">[Mapping di settore di pagina 1]</span><span class="sxs-lookup"><span data-stu-id="4314c-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="4314c-180">...</span><span class="sxs-lookup"><span data-stu-id="4314c-180">...</span></span>                        |
| <span data-ttu-id="4314c-181">[Mapping del settore di pagina "n"]</span><span class="sxs-lookup"><span data-stu-id="4314c-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="4314c-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="4314c-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="4314c-183">Le informazioni sul mapping della pagina vengono scritte solo quando il blocco è pieno, ovvero tutte le pagine del blocco sono state scritte in.</span><span class="sxs-lookup"><span data-stu-id="4314c-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="4314c-184">In questo modo è possibile cercare più velocemente le pagine gratuite e il mapping dei settori logici in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4314c-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="4314c-185">Supporto del blocco non valido NAND</span><span class="sxs-lookup"><span data-stu-id="4314c-185">NAND Bad Block Support</span></span>

<span data-ttu-id="4314c-186">È inoltre più probabile che la memoria NAND disponga di blocchi danneggiati e non di memoria.</span><span class="sxs-lookup"><span data-stu-id="4314c-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="4314c-187">Questa operazione è in gran parte dovuta al fatto che i produttori di NAND possono aumentare il rendimento consentendo blocchi danneggiati e richiedendo il software per aggirare tali blocchi danneggiati.</span><span class="sxs-lookup"><span data-stu-id="4314c-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="4314c-188">LevelX gestisce la gestione dei blocchi non validi di NAND semplicemente eseguendo il mapping intorno a blocchi danneggiati.</span><span class="sxs-lookup"><span data-stu-id="4314c-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="4314c-189">LevelX fornisce anche API per i codici di correzione degli errori di Hamming a 256 byte per il driver LevelX sottostante da utilizzare per il calcolo di nuovi codici ECC o per la correzione di errori a 1 bit nella lettura della pagina all'interno di ogni sezione 256 byte della pagina.</span><span class="sxs-lookup"><span data-stu-id="4314c-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="4314c-190">Requisiti del driver NAND</span><span class="sxs-lookup"><span data-stu-id="4314c-190">NAND Driver Requirements</span></span>

<span data-ttu-id="4314c-191">LevelX richiede un driver Flash NAND sottostante specifico per l'implementazione dell'hardware e della parte Flash sottostante.</span><span class="sxs-lookup"><span data-stu-id="4314c-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="4314c-192">Il driver viene specificato per LevelX durante l'inizializzazione tramite l'API ***lx_nand_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="4314c-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="4314c-193">Il prototipo del driver LevelX è il seguente.</span><span class="sxs-lookup"><span data-stu-id="4314c-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="4314c-194">Il parametro *instance* specifica il blocco di controllo NAND LevelX.</span><span class="sxs-lookup"><span data-stu-id="4314c-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="4314c-195">La funzione di inizializzazione driver è responsabile della configurazione di tutti gli altri servizi a livello di driver per l'istanza di LevelX associata.</span><span class="sxs-lookup"><span data-stu-id="4314c-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="4314c-196">I servizi richiesti per ogni istanza di LevelX NAND sono visualizzati nell'elenco seguente.</span><span class="sxs-lookup"><span data-stu-id="4314c-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="4314c-197">Leggi pagina</span><span class="sxs-lookup"><span data-stu-id="4314c-197">Read Page</span></span>
- <span data-ttu-id="4314c-198">Scrivi pagina</span><span class="sxs-lookup"><span data-stu-id="4314c-198">Write Page</span></span>
- <span data-ttu-id="4314c-199">Cancella blocco</span><span class="sxs-lookup"><span data-stu-id="4314c-199">Block Erase</span></span>
- <span data-ttu-id="4314c-200">Verifica cancellazione blocco</span><span class="sxs-lookup"><span data-stu-id="4314c-200">Block Erased Verify</span></span>
- <span data-ttu-id="4314c-201">Verifica cancellazione pagina</span><span class="sxs-lookup"><span data-stu-id="4314c-201">Page Erased Verify</span></span>
- <span data-ttu-id="4314c-202">Ottieni stato blocco</span><span class="sxs-lookup"><span data-stu-id="4314c-202">Block Status Get</span></span>
- <span data-ttu-id="4314c-203">Imposta stato blocco</span><span class="sxs-lookup"><span data-stu-id="4314c-203">Block Status Set</span></span>
- <span data-ttu-id="4314c-204">Blocca i byte aggiuntivi Get</span><span class="sxs-lookup"><span data-stu-id="4314c-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="4314c-205">Blocca i byte aggiuntivi impostati</span><span class="sxs-lookup"><span data-stu-id="4314c-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="4314c-206">Gestore errori di sistema</span><span class="sxs-lookup"><span data-stu-id="4314c-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="4314c-207">Inizializzazione driver</span><span class="sxs-lookup"><span data-stu-id="4314c-207">Driver Initialization</span></span>

<span data-ttu-id="4314c-208">Questi servizi vengono impostati tramite l'impostazione di puntatori a funzione nell'istanza **LX_NAND_FLASH** all'interno della funzione di inizializzazione del driver.</span><span class="sxs-lookup"><span data-stu-id="4314c-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="4314c-209">La funzione di inizializzazione del driver specifica anche il numero totale di blocchi, pagine per blocco, byte per pagina e un'area RAM sufficientemente grande da leggere una pagina in memoria.</span><span class="sxs-lookup"><span data-stu-id="4314c-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="4314c-210">La funzione di inizializzazione dei driver esegue probabilmente anche ulteriori attività di inizializzazione specifiche del dispositivo e/o dell'implementazione prima di restituire **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="4314c-211">Pagina lettura driver</span><span class="sxs-lookup"><span data-stu-id="4314c-211">Driver Read Page</span></span>

<span data-ttu-id="4314c-212">Il servizio "lettura pagina" del driver NAND LevelX è responsabile della lettura di una pagina specifica in un blocco specifico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="4314c-213">Tutte le verifiche degli errori e la logica di correzione sono responsabilità del servizio driver.</span><span class="sxs-lookup"><span data-stu-id="4314c-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="4314c-214">In caso di esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-215">Se l'operazione non riesce, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-216">Il prototipo del servizio "lettura pagina" del driver NAND LevelX è riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4314c-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="4314c-217">Dove *blocco* e *pagina* identificano la pagina da leggere e la *destinazione* e le *parole* specificano dove inserire il contenuto della pagina e il numero di parole a 32 bit da leggere.</span><span class="sxs-lookup"><span data-stu-id="4314c-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="4314c-218">Pagina scrittura driver</span><span class="sxs-lookup"><span data-stu-id="4314c-218">Driver Write Page</span></span>

<span data-ttu-id="4314c-219">Il servizio "scrittura pagina" del driver NAND LevelX è responsabile della scrittura di una pagina specifica nel blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="4314c-220">Il controllo degli errori e il calcolo ECC sono la responsabilità del servizio driver.</span><span class="sxs-lookup"><span data-stu-id="4314c-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="4314c-221">In caso di esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-222">Se l'operazione non riesce, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-223">Il prototipo del servizio "scrittura pagina" del driver NAND LevelX è illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4314c-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="4314c-224">Dove *blocco* e *pagina* identificano la pagina da scrivere e l' *origine* e le *parole* specificano l'origine della scrittura e il numero di parole a 32 bit da scrivere.</span><span class="sxs-lookup"><span data-stu-id="4314c-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="4314c-225">LevelX si basa sul driver per il rilevamento degli errori di basso livello durante la scrittura nella pagina Flash, che in genere comporta la lettura della pagina e il confronto con il buffer di scrittura per garantire la corretta scrittura.</span><span class="sxs-lookup"><span data-stu-id="4314c-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="4314c-226">Cancellazione blocco driver</span><span class="sxs-lookup"><span data-stu-id="4314c-226">Driver Block Erase</span></span>

<span data-ttu-id="4314c-227">Il servizio "blocco Erase" del driver NAND LevelX è responsabile della cancellazione del blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="4314c-228">In caso di esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-229">Se l'operazione non riesce, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-230">Il prototipo del servizio "blocco Erase" del driver NAND LevelX è il seguente.</span><span class="sxs-lookup"><span data-stu-id="4314c-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="4314c-231">Dove *Block* identifica il blocco da cancellare.</span><span class="sxs-lookup"><span data-stu-id="4314c-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="4314c-232">Il parametro *erase_count* viene fornito a scopo diagnostico.</span><span class="sxs-lookup"><span data-stu-id="4314c-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="4314c-233">Ad esempio, il driver potrebbe voler avvisare un'altra parte del software applicativo quando il numero di cancellazioni supera una soglia specifica.</span><span class="sxs-lookup"><span data-stu-id="4314c-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="4314c-234">LevelX si basa sul driver per il rilevamento degli errori di basso livello quando il blocco viene cancellato, che in genere comporta la verifica che tutte le pagine del blocco siano tutte quelle.</span><span class="sxs-lookup"><span data-stu-id="4314c-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="4314c-235">Verifica cancellazione blocco driver</span><span class="sxs-lookup"><span data-stu-id="4314c-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="4314c-236">Il servizio "Block eraseed Verify" del driver NAND LevelX è responsabile della verifica della cancellazione del blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="4314c-237">Se viene cancellato, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-238">Se il blocco non viene cancellato, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-239">Il prototipo del servizio "Block eraseed Verify" del driver NAND LevelX è:</span><span class="sxs-lookup"><span data-stu-id="4314c-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="4314c-240">Where *Block* specifica quale blocco verificare che venga cancellato.</span><span class="sxs-lookup"><span data-stu-id="4314c-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="4314c-241">LevelX si basa sul driver per esaminare tutte le pagine e tutti i byte di ogni pagina, inclusi i byte di riserva e di dati, per assicurarsi che vengano cancellati (contenere tutti).</span><span class="sxs-lookup"><span data-stu-id="4314c-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="4314c-242">Verifica cancellazione pagina driver</span><span class="sxs-lookup"><span data-stu-id="4314c-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="4314c-243">Il servizio del driver NAND LevelX "pagina di verifica cancellata" è responsabile della verifica della cancellazione della pagina specificata del blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="4314c-244">Se viene cancellato, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-245">Se la pagina non viene cancellata, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-246">Il prototipo del servizio del driver NAND LevelX "pagina di verifica cancellata" è:</span><span class="sxs-lookup"><span data-stu-id="4314c-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="4314c-247">Where *Block* specifica il blocco e la *pagina* che specificano la pagina per verificare che venga cancellata.</span><span class="sxs-lookup"><span data-stu-id="4314c-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="4314c-248">LevelX si basa sul driver per esaminare tutti i byte della pagina specificata, inclusi i byte di riserva e di dati, per assicurarsi che vengano cancellati (contenere tutti i byte).</span><span class="sxs-lookup"><span data-stu-id="4314c-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="4314c-249">Stato blocco driver Get</span><span class="sxs-lookup"><span data-stu-id="4314c-249">Driver Block Status Get</span></span>

<span data-ttu-id="4314c-250">Il servizio "stato blocco Get" del driver NAND LevelX è responsabile del recupero del flag di blocco errato del blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="4314c-251">Se l'operazione ha esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-252">Se l'operazione ha esito negativo, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-253">Il prototipo del servizio "blocco stato Get" del driver NAND LevelX è: illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4314c-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="4314c-254">Where *Block* specifica quale blocco e *bad_block_byte* specifica la destinazione per il flag di blocco errato.</span><span class="sxs-lookup"><span data-stu-id="4314c-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="4314c-255">Set di Stati del blocco driver</span><span class="sxs-lookup"><span data-stu-id="4314c-255">Driver Block Status Set</span></span>

<span data-ttu-id="4314c-256">Il servizio "set status Block" del driver NAND LevelX è responsabile dell'impostazione del flag di blocco errato del blocco specificato del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="4314c-257">Se l'operazione ha esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-258">Se l'operazione ha esito negativo, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-259">Il prototipo del servizio "Block status set" del driver NAND LevelX è:</span><span class="sxs-lookup"><span data-stu-id="4314c-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="4314c-260">Where *Block* specifica quale blocco e *bad_block_byte* specifica il valore del flag di blocco errato.</span><span class="sxs-lookup"><span data-stu-id="4314c-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="4314c-261">Blocco driver aggiuntivo Byte Get</span><span class="sxs-lookup"><span data-stu-id="4314c-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="4314c-262">Il servizio "blocca byte aggiuntivi Get" del driver NAND LevelX è responsabile del recupero di byte aggiuntivi associati a una pagina specifica di un blocco specifico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="4314c-263">Se l'operazione ha esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-264">Se l'operazione ha esito negativo, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-265">Il prototipo del servizio "blocca byte aggiuntivi Get" del driver NAND LevelX è:</span><span class="sxs-lookup"><span data-stu-id="4314c-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="4314c-266">Where *Block* specifica il blocco, la *pagina* specifica la pagina specifica e la *destinazione* specifica la destinazione per i byte aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="4314c-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="4314c-267">La *dimensione* del parametro specifica il numero di byte aggiuntivi da ottenere.</span><span class="sxs-lookup"><span data-stu-id="4314c-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="4314c-268">Set di byte aggiuntivi del blocco driver</span><span class="sxs-lookup"><span data-stu-id="4314c-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="4314c-269">Il servizio LevelX NAND driver "Block extra bytes set" è responsabile dell'impostazione di byte aggiuntivi in una pagina specifica di un blocco specifico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="4314c-270">Se l'operazione ha esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-271">Se l'operazione ha esito negativo, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-272">Il prototipo del servizio "blocco di byte aggiuntivi di LevelX" del driver NAND è:</span><span class="sxs-lookup"><span data-stu-id="4314c-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="4314c-273">Dove *Block* specifica il blocco, la *pagina* specifica la pagina e l' *origine* specifici che specificano l'origine dei byte aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="4314c-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="4314c-274">Le *dimensioni* del parametro specificano il numero di byte aggiuntivi da impostare.</span><span class="sxs-lookup"><span data-stu-id="4314c-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="4314c-275">Errore di sistema del driver</span><span class="sxs-lookup"><span data-stu-id="4314c-275">Driver System Error</span></span>

<span data-ttu-id="4314c-276">Il servizio "gestore errori di sistema" del driver LevelX NAND è responsabile dell'impostazione degli errori di sistema di gestione rilevati da LevelX.</span><span class="sxs-lookup"><span data-stu-id="4314c-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="4314c-277">L'elaborazione in questa routine dipende dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="4314c-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="4314c-278">Se l'operazione ha esito positivo, il driver LevelX NAND restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4314c-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4314c-279">Se l'operazione ha esito negativo, il driver LevelX NAND restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4314c-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4314c-280">Il prototipo del servizio "errore di sistema" del driver NAND LevelX è:</span><span class="sxs-lookup"><span data-stu-id="4314c-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="4314c-281">Dove *Block* specifica il blocco e la *pagina* specifica la pagina specifica in cui si è verificato l'errore rappresentato da *error_code* .</span><span class="sxs-lookup"><span data-stu-id="4314c-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="4314c-282">Driver simulato NAND</span><span class="sxs-lookup"><span data-stu-id="4314c-282">NAND Simulated Driver</span></span>

<span data-ttu-id="4314c-283">LevelX fornisce un driver Flash NAND simulato che usa semplicemente RAM per simulare il funzionamento di una parte Flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="4314c-284">Per impostazione predefinita, il driver simulato NAND fornisce 8 blocchi flash NAND con 16 pagine per blocco e 2048 byte per pagina.</span><span class="sxs-lookup"><span data-stu-id="4314c-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="4314c-285">La funzione di inizializzazione del driver Flash NAND simulato è \***lx_nand_flash_simulator_initialize** _ ed è definita in _ *_lx_nand_flash_simulator. c_* \*.</span><span class="sxs-lookup"><span data-stu-id="4314c-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="4314c-286">Questo driver fornisce anche un modello valido per la scrittura di driver Flash NAND specifici.</span><span class="sxs-lookup"><span data-stu-id="4314c-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="4314c-287">Integrazione di FileX NAND</span><span class="sxs-lookup"><span data-stu-id="4314c-287">NAND FileX Integration</span></span>

<span data-ttu-id="4314c-288">Come indicato in precedenza, LevelX non si basa su FileX per Operation.</span><span class="sxs-lookup"><span data-stu-id="4314c-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="4314c-289">Tutte le API di LevelX possono essere chiamate direttamente dal software dell'applicazione per archiviare o recuperare dati non elaborati nei settori logici forniti da LevelX.</span><span class="sxs-lookup"><span data-stu-id="4314c-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="4314c-290">Tuttavia, LevelX supporta anche FileX.</span><span class="sxs-lookup"><span data-stu-id="4314c-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="4314c-291">Il file ***fx_nand_flash_simulated_driver. c*** contiene un driver FILEX di esempio da usare con la simulazione Flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="4314c-292">Un aspetto interessante di questo driver è che combina settori logici a 512 byte usati in genere da FileX in singole richieste di lettura/scrittura nel settore logico per il simulatore LevelX usando pagine a 2048 byte.</span><span class="sxs-lookup"><span data-stu-id="4314c-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="4314c-293">Questo comporta un uso più efficiente della memoria flash NAND.</span><span class="sxs-lookup"><span data-stu-id="4314c-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="4314c-294">Il driver FileX NAND Flash per LevelX fornisce un valido punto di partenza per la scrittura di driver FileX personalizzati.</span><span class="sxs-lookup"><span data-stu-id="4314c-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4314c-295">Il formato Flash NAND di FileX deve essere costituito da una dimensione blocco completo dei settori minori rispetto a quelle fornite da NAND Flash.</span><span class="sxs-lookup"><span data-stu-id="4314c-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="4314c-296">Ciò consente di garantire prestazioni ottimali durante l'elaborazione del livello di usura.</span><span class="sxs-lookup"><span data-stu-id="4314c-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="4314c-297">Le tecniche aggiuntive per migliorare le prestazioni di scrittura nell'algoritmo di livellamento dell'uso di LevelX includono quanto segue.</span><span class="sxs-lookup"><span data-stu-id="4314c-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="4314c-298">Verificare che tutte le Scritture siano esattamente di uno o più cluster e che inizino con i limiti esatti del cluster.</span><span class="sxs-lookup"><span data-stu-id="4314c-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="4314c-299">Pre-allocare i cluster prima di eseguire operazioni di scrittura di file di grandi dimensioni tramite la classe FileX ***fx_file_allocate*** di API.</span><span class="sxs-lookup"><span data-stu-id="4314c-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="4314c-300">Verificare che il driver FileX sia abilitato per ricevere le informazioni sul settore di rilascio e le richieste effettuate al driver per rilasciare i settori vengono gestite nel driver chiamando ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="4314c-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="4314c-301">Uso periodico di ***lx_nand_flash_defragment*** per liberare il maggior numero possibile di blocchi NAND e migliorare quindi le prestazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="4314c-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="4314c-302">Usare l'API ***lx_nand_flash_extended_cache_enable*** per fornire una cache RAM di varie risorse del blocco NAND per ottenere prestazioni più veloci.</span><span class="sxs-lookup"><span data-stu-id="4314c-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
