---
title: Capitolo 5-Azure RTO LevelX e supporto
description: La memoria flash è costituita da blocchi generalmente divisibile in modo uniforme per 512 byte. Azure RTO LevelX divide ogni blocco Flash in settori logici a 512 byte.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822163"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="0adb2-104">Capitolo 5-Azure RTO LevelX e supporto</span><span class="sxs-lookup"><span data-stu-id="0adb2-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="0adb2-105">La memoria flash è costituita da *blocchi* generalmente divisibile in modo uniforme per 512 byte.</span><span class="sxs-lookup"><span data-stu-id="0adb2-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="0adb2-106">Non è previsto alcun concetto di *pagina* Flash in memoria o memoria flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="0adb2-107">Inoltre, non sono presenti byte di *riserva* nella memoria flash, di conseguenza Azure RTO LevelX deve usare la memoria di memoria flash per tutte le informazioni di gestione.</span><span class="sxs-lookup"><span data-stu-id="0adb2-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="0adb2-108">L'accesso in lettura diretto è possibile in o memoria flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="0adb2-109">L'accesso in scrittura richiede in genere una sequenza speciale di operazioni.</span><span class="sxs-lookup"><span data-stu-id="0adb2-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="0adb2-110">La memoria flash può essere scritta più volte, a condizione che i bit vengano cancellati.</span><span class="sxs-lookup"><span data-stu-id="0adb2-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="0adb2-111">I bit in o la memoria flash possono essere impostati solo una volta, tramite l'operazione di cancellazione del blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="0adb2-112">LevelX divide ogni blocco Flash in *settori* logici a 512 byte.</span><span class="sxs-lookup"><span data-stu-id="0adb2-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="0adb2-113">Inoltre, LevelX usa i primi "n" settori di ogni blocco Flash per archiviare le informazioni di gestione.</span><span class="sxs-lookup"><span data-stu-id="0adb2-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="0adb2-114">Il formato di LevelX o le informazioni di gestione della memoria flash sono:</span><span class="sxs-lookup"><span data-stu-id="0adb2-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="0adb2-115">**LevelX e formato di blocco**</span><span class="sxs-lookup"><span data-stu-id="0adb2-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="0adb2-116">Offset byte</span><span class="sxs-lookup"><span data-stu-id="0adb2-116">Byte Offset</span></span>  | <span data-ttu-id="0adb2-117">Contenuto</span><span class="sxs-lookup"><span data-stu-id="0adb2-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="0adb2-118">0</span><span class="sxs-lookup"><span data-stu-id="0adb2-118">0</span></span>            | <span data-ttu-id="0adb2-119">[Conteggio blocchi cancellati]</span><span class="sxs-lookup"><span data-stu-id="0adb2-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="0adb2-120">4</span><span class="sxs-lookup"><span data-stu-id="0adb2-120">4</span></span>            | <span data-ttu-id="0adb2-121">[Settore minimo mappato]</span><span class="sxs-lookup"><span data-stu-id="0adb2-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="0adb2-122">8</span><span class="sxs-lookup"><span data-stu-id="0adb2-122">8</span></span>            | <span data-ttu-id="0adb2-123">[Settore con mapping massimo]</span><span class="sxs-lookup"><span data-stu-id="0adb2-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="0adb2-124">12</span><span class="sxs-lookup"><span data-stu-id="0adb2-124">12</span></span>           | <span data-ttu-id="0adb2-125">[Mappa di bit per settore gratuito]</span><span class="sxs-lookup"><span data-stu-id="0adb2-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="0adb2-126">m</span><span class="sxs-lookup"><span data-stu-id="0adb2-126">m</span></span>            | <span data-ttu-id="0adb2-127">[Voce di mapping settore 0]</span><span class="sxs-lookup"><span data-stu-id="0adb2-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="0adb2-128">…</span><span class="sxs-lookup"><span data-stu-id="0adb2-128">…</span></span>                            |
| <span data-ttu-id="0adb2-129">m + 4 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="0adb2-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="0adb2-130">[Voce di mapping settore "n"]</span><span class="sxs-lookup"><span data-stu-id="0adb2-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="0adb2-131">…</span><span class="sxs-lookup"><span data-stu-id="0adb2-131">…</span></span>                            |
| <span data-ttu-id="0adb2-132">s</span><span class="sxs-lookup"><span data-stu-id="0adb2-132">s</span></span>            | <span data-ttu-id="0adb2-133">[Contenuto settore 0]</span><span class="sxs-lookup"><span data-stu-id="0adb2-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="0adb2-134">…</span><span class="sxs-lookup"><span data-stu-id="0adb2-134">…</span></span>                            |
| <span data-ttu-id="0adb2-135">s + 512 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="0adb2-135">s+512\*(n-1)</span></span> | <span data-ttu-id="0adb2-136">[Contenuto settore "n"]</span><span class="sxs-lookup"><span data-stu-id="0adb2-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="0adb2-137">Il *conteggio di cancellazione dei blocchi* a 32 bit contiene il numero di volte in cui il blocco è stato cancellato.</span><span class="sxs-lookup"><span data-stu-id="0adb2-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="0adb2-138">L'obiettivo principale di LevelX consiste nel limitare il numero di cancelli di tutti i blocchi relativamente vicini per evitare che un blocco venga esaurito in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="0adb2-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="0adb2-139">Il *settore con mapping minimo* a 32 bit e i campi di *settore con mapping massimo* vengono scritti solo quando tutti i settori logici del blocco sono stati mappati e scritti in.</span><span class="sxs-lookup"><span data-stu-id="0adb2-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="0adb2-140">Questi campi sono utili per l'ottimizzazione dell'operazione di lettura del settore.</span><span class="sxs-lookup"><span data-stu-id="0adb2-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="0adb2-141">La voce della *mappa di bit del settore gratuito* è una mappa di bit in cui ogni bit del set corrisponde a un settore non mappato nel blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="0adb2-142">Questo campo viene usato per rendere più efficiente la ricerca nel settore gratuito.</span><span class="sxs-lookup"><span data-stu-id="0adb2-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="0adb2-143">Si tratta di un campo a lunghezza variabile che richiede una parola per ogni settore 32 nel blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="0adb2-144">La matrice di *voci di mapping del settore* contiene informazioni di mapping per ogni settore nel blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="0adb2-145">Ogni voce ha il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="0adb2-145">Each entry has the following format:</span></span>

<span data-ttu-id="0adb2-146">**Voce mapping settore**</span><span class="sxs-lookup"><span data-stu-id="0adb2-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="0adb2-147">Bit/i</span><span class="sxs-lookup"><span data-stu-id="0adb2-147">Bit(s)</span></span> | <span data-ttu-id="0adb2-148">Significato</span><span class="sxs-lookup"><span data-stu-id="0adb2-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="0adb2-149">31</span><span class="sxs-lookup"><span data-stu-id="0adb2-149">31</span></span>     | <span data-ttu-id="0adb2-150">Flag valido.</span><span class="sxs-lookup"><span data-stu-id="0adb2-150">Valid flag.</span></span> <span data-ttu-id="0adb2-151">Quando l'impostazione e il settore logico non sono tutti quelli indicati, il mapping è valido</span><span class="sxs-lookup"><span data-stu-id="0adb2-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="0adb2-152">30</span><span class="sxs-lookup"><span data-stu-id="0adb2-152">30</span></span>     | <span data-ttu-id="0adb2-153">Flag obsoleto.</span><span class="sxs-lookup"><span data-stu-id="0adb2-153">Obsolete flag.</span></span> <span data-ttu-id="0adb2-154">Se chiaro, questo mapping è obsoleto o sta per diventare obsoleto.</span><span class="sxs-lookup"><span data-stu-id="0adb2-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="0adb2-155">29</span><span class="sxs-lookup"><span data-stu-id="0adb2-155">29</span></span>     | <span data-ttu-id="0adb2-156">La scrittura della voce di mapping è completa quando questo bit è 0</span><span class="sxs-lookup"><span data-stu-id="0adb2-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="0adb2-157">0-28</span><span class="sxs-lookup"><span data-stu-id="0adb2-157">0-28</span></span>   | <span data-ttu-id="0adb2-158">Settore logico mappato a questo settore fisico, quando non tutti gli altri.</span><span class="sxs-lookup"><span data-stu-id="0adb2-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="0adb2-159">Il bit superiore del campo a 32 bit (bit 31) viene utilizzato per indicare che il mapping del settore logico è valido.</span><span class="sxs-lookup"><span data-stu-id="0adb2-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="0adb2-160">Se il bit è 0, le informazioni in questa voce (e il relativo contenuto del settore) non sono più valide.</span><span class="sxs-lookup"><span data-stu-id="0adb2-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="0adb2-161">Il successivo bit bit 30 viene usato per indicare che questo settore è in corso di diventare obsoleto ed è in corso la scrittura di un nuovo settore.</span><span class="sxs-lookup"><span data-stu-id="0adb2-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="0adb2-162">Il bit 29 viene utilizzato per indicare il completamento della scrittura della voce di mapping.</span><span class="sxs-lookup"><span data-stu-id="0adb2-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="0adb2-163">Se il bit 29 è 0, la scrittura della voce di mapping è stata completata.</span><span class="sxs-lookup"><span data-stu-id="0adb2-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="0adb2-164">Se è impostato il bit 29, è in corso la scrittura della voce di mapping.</span><span class="sxs-lookup"><span data-stu-id="0adb2-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="0adb2-165">I bit 30 e 29 vengono usati per il ripristino da una potenziale perdita di energia durante l'aggiornamento di un nuovo mapping di settore.</span><span class="sxs-lookup"><span data-stu-id="0adb2-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="0adb2-166">Infine, i 29 bit inferiori (28-0) contengono il numero di settore logico per il settore.</span><span class="sxs-lookup"><span data-stu-id="0adb2-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="0adb2-167">Se non è stato eseguito il mapping di un settore, verranno impostati tutti i bit, vale a dire il valore 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="0adb2-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="0adb2-168">E requisiti dei driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-168">NOR Driver Requirements</span></span>

<span data-ttu-id="0adb2-169">LevelX richiede un driver sottostante o flash specifico per l'implementazione dell'hardware e della parte Flash sottostante.</span><span class="sxs-lookup"><span data-stu-id="0adb2-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="0adb2-170">Il driver viene specificato per LevelX durante l'inizializzazione tramite l'API ***lx_nor_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="0adb2-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="0adb2-171">Il prototipo del driver LevelX è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="0adb2-172">Il parametro "*instance*" specifica il LevelX e il blocco di controllo.</span><span class="sxs-lookup"><span data-stu-id="0adb2-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="0adb2-173">La funzione di inizializzazione driver è responsabile della configurazione di tutti gli altri servizi a livello di driver per l'istanza di LevelX associata.</span><span class="sxs-lookup"><span data-stu-id="0adb2-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="0adb2-174">I servizi richiesti per ogni LevelX o istanza sono:</span><span class="sxs-lookup"><span data-stu-id="0adb2-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="0adb2-175">Leggi settore</span><span class="sxs-lookup"><span data-stu-id="0adb2-175">Read Sector</span></span>
- <span data-ttu-id="0adb2-176">Settore di scrittura</span><span class="sxs-lookup"><span data-stu-id="0adb2-176">Write Sector</span></span>
- <span data-ttu-id="0adb2-177">Cancella blocco</span><span class="sxs-lookup"><span data-stu-id="0adb2-177">Block Erase</span></span>
- <span data-ttu-id="0adb2-178">Verifica cancellazione blocco</span><span class="sxs-lookup"><span data-stu-id="0adb2-178">Block Erased Verify</span></span>
- <span data-ttu-id="0adb2-179">Gestore errori di sistema</span><span class="sxs-lookup"><span data-stu-id="0adb2-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="0adb2-180">Inizializzazione driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-180">Driver Initialization</span></span>

<span data-ttu-id="0adb2-181">Questi servizi vengono impostati tramite l'impostazione di puntatori a funzione nell'istanza **LX_NOR_FLASH** all'interno della funzione di inizializzazione del driver.</span><span class="sxs-lookup"><span data-stu-id="0adb2-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="0adb2-182">La funzione di inizializzazione del driver è responsabile anche di:</span><span class="sxs-lookup"><span data-stu-id="0adb2-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="0adb2-183">Specificare l'indirizzo di base del flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="0adb2-184">Specifica del numero totale di blocchi e del numero di parole per blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="0adb2-185">Buffer RAM per la lettura di un settore di Flash (512 byte) e allineato per l'accesso ULONG.</span><span class="sxs-lookup"><span data-stu-id="0adb2-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="0adb2-186">La funzione di inizializzazione dei driver esegue probabilmente anche ulteriori attività di inizializzazione specifiche del dispositivo e/o dell'implementazione prima di restituire **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="0adb2-187">Settore di lettura driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-187">Driver Read Sector</span></span>

<span data-ttu-id="0adb2-188">Il servizio LevelX e il driver "Read Sector" è responsabile della lettura di un settore specifico in un blocco specifico di o Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="0adb2-189">Tutte le verifiche degli errori e la logica di correzione sono responsabilità del servizio driver.</span><span class="sxs-lookup"><span data-stu-id="0adb2-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="0adb2-190">In caso di esito positivo, il LevelX o il driver restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="0adb2-191">In caso di esito negativo, il LevelX o il driver restituisce *LX_ERROR*.</span><span class="sxs-lookup"><span data-stu-id="0adb2-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="0adb2-192">Il prototipo del servizio LevelX e del driver "Read Sector" è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="0adb2-193">Dove "*flash_address*" specifica l'indirizzo di un settore logico all'interno di un blocco di memoria, di memoria e di "*destinazione*" e "*parole*", che specificano la posizione in cui inserire il contenuto del settore e il numero di parole a 32 bit da leggere.</span><span class="sxs-lookup"><span data-stu-id="0adb2-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="0adb2-194">Settore scrittura driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-194">Driver Write Sector</span></span>

<span data-ttu-id="0adb2-195">Il servizio LevelX e il driver "Write Sector" è responsabile della scrittura di un settore specifico in un blocco di o Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="0adb2-196">Il controllo degli errori è responsabilità del servizio driver.</span><span class="sxs-lookup"><span data-stu-id="0adb2-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="0adb2-197">In caso di esito positivo, il LevelX o il driver restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="0adb2-198">In caso di esito negativo, il LevelX o il driver restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="0adb2-199">Il prototipo del servizio LevelX e del driver "scrittura settore" è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="0adb2-200">Dove "*flash_address*" specifica l'indirizzo di un settore logico all'interno di un blocco di memoria o di un blocco Flash e "*source*" e "*Words*" specificano l'origine della scrittura e il numero di parole a 32 bit da scrivere.</span><span class="sxs-lookup"><span data-stu-id="0adb2-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="0adb2-201">LevelX si basa sul driver per verificare che il settore di scrittura abbia avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="0adb2-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="0adb2-202">Questa operazione viene in genere eseguita leggendo indietro il valore programmato per assicurarsi che corrisponda al valore richiesto da scrivere.</span><span class="sxs-lookup"><span data-stu-id="0adb2-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="0adb2-203">Cancellazione blocco driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-203">Driver Block Erase</span></span>

<span data-ttu-id="0adb2-204">Il servizio LevelX e il driver "block erase" è responsabile della cancellazione del blocco specificato di o del flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="0adb2-205">In caso di esito positivo, il LevelX o il driver restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="0adb2-206">In caso di esito negativo, il LevelX o il driver restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="0adb2-207">Il prototipo del servizio LevelX e del driver "block erase" è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="0adb2-208">Dove "*Block*" identifica i blocchi da cancellare.</span><span class="sxs-lookup"><span data-stu-id="0adb2-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="0adb2-209">Il parametro "*erase_count*" viene fornito a scopo diagnostico.</span><span class="sxs-lookup"><span data-stu-id="0adb2-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="0adb2-210">Ad esempio, il driver potrebbe voler avvisare un'altra parte del software applicativo quando il numero di cancellazioni supera una soglia specifica.</span><span class="sxs-lookup"><span data-stu-id="0adb2-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="0adb2-211">LevelX si basa sul driver per esaminare tutti i byte del blocco per assicurarsi che vengano cancellati (contenere tutti).</span><span class="sxs-lookup"><span data-stu-id="0adb2-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="0adb2-212">Verifica cancellazione blocco driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="0adb2-213">Il servizio LevelX e il driver "Block Cancellated Verify" è responsabile della verifica della cancellazione del blocco specificato di o del flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="0adb2-214">Se viene cancellato, il LevelX o il driver restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="0adb2-215">Se il blocco non viene cancellato, il LevelX o il driver restituisce **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="0adb2-216">Il prototipo del servizio LevelX e del driver "blocca la verifica cancellata" è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="0adb2-217">Dove "*Block*" specifica quale blocco verificare che venga cancellato.</span><span class="sxs-lookup"><span data-stu-id="0adb2-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="0adb2-218">LevelX si basa sul driver per esaminare tutti i byte dell'oggetto specificato per assicurarsi che vengano cancellati (contenere tutti).</span><span class="sxs-lookup"><span data-stu-id="0adb2-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="0adb2-219">Errore di sistema del driver</span><span class="sxs-lookup"><span data-stu-id="0adb2-219">Driver System Error</span></span>

<span data-ttu-id="0adb2-220">Il servizio "gestore errori di sistema" di LevelX e driver è responsabile dell'impostazione degli errori di sistema di gestione rilevati da LevelX.</span><span class="sxs-lookup"><span data-stu-id="0adb2-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="0adb2-221">L'elaborazione in questa routine dipende dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0adb2-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="0adb2-222">Se l'operazione ha esito positivo, il LevelX o il driver restituisce **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="0adb2-223">Se l'operazione ha esito negativo, LevelX e il driver restituiscono **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="0adb2-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="0adb2-224">Il prototipo del servizio LevelX o del driver "errore di sistema" è:</span><span class="sxs-lookup"><span data-stu-id="0adb2-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="0adb2-225">Dove "*error_code*" rappresenta l'errore che si è verificato.</span><span class="sxs-lookup"><span data-stu-id="0adb2-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="0adb2-226">O driver simulato</span><span class="sxs-lookup"><span data-stu-id="0adb2-226">NOR Simulated Driver</span></span>

<span data-ttu-id="0adb2-227">LevelX fornisce un driver simulato o Flash che usa semplicemente la RAM per simulare il funzionamento di una parte o di una parte Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="0adb2-228">Per impostazione predefinita, il driver non simulato non fornisce 8 né blocchi flash con settori a 16 512 byte per blocco.</span><span class="sxs-lookup"><span data-stu-id="0adb2-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="0adb2-229">La funzione di inizializzazione del driver simulato e Flash è \***lx_nor_flash_simulator_initialize** _ ed è definita in _ *_lx_nor_flash_simulator. c_* \*.</span><span class="sxs-lookup"><span data-stu-id="0adb2-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="0adb2-230">Questo driver fornisce anche un modello valido per la scrittura di driver specifici o Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="0adb2-231">NÉ integrazione con FileX</span><span class="sxs-lookup"><span data-stu-id="0adb2-231">NOR FileX Integration</span></span>

<span data-ttu-id="0adb2-232">Come indicato in precedenza, LevelX non si basa su FileX per Operation.</span><span class="sxs-lookup"><span data-stu-id="0adb2-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="0adb2-233">Tutte le API di LevelX possono essere chiamate direttamente dal software dell'applicazione per archiviare o recuperare dati non elaborati nei settori logici forniti da LevelX.</span><span class="sxs-lookup"><span data-stu-id="0adb2-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="0adb2-234">Tuttavia, LevelX supporta anche FileX.</span><span class="sxs-lookup"><span data-stu-id="0adb2-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="0adb2-235">Il file ***fx_nor_flash_simulated_driver. c*** contiene un driver FILEX di esempio da usare con la simulazione di o Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="0adb2-236">Il driver FileX o Flash per LevelX fornisce un valido punto di partenza per la scrittura di driver FileX personalizzati.</span><span class="sxs-lookup"><span data-stu-id="0adb2-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="0adb2-237">Il formato FileX o Flash deve essere una dimensione di blocco completo dei settori minori di e non fornisce Flash.</span><span class="sxs-lookup"><span data-stu-id="0adb2-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="0adb2-238">Ciò consente di garantire prestazioni ottimali durante l'elaborazione del livello di usura.</span><span class="sxs-lookup"><span data-stu-id="0adb2-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="0adb2-239">Altre tecniche per migliorare le prestazioni di scrittura nell'algoritmo di livellamento dell'uso di LevelX includono:</span><span class="sxs-lookup"><span data-stu-id="0adb2-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="0adb2-240">Verificare che tutte le Scritture siano esattamente di uno o più cluster e che inizino con i limiti esatti del cluster.</span><span class="sxs-lookup"><span data-stu-id="0adb2-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="0adb2-241">Pre-allocare i cluster prima di eseguire operazioni di scrittura di file di grandi dimensioni tramite la classe FileX ***fx_file_allocate*** di API.</span><span class="sxs-lookup"><span data-stu-id="0adb2-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="0adb2-242">Uso periodico di ***lx_nor_flash_defragment*** per liberare il maggior numero possibile di blocchi e, di conseguenza, migliorare le prestazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="0adb2-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="0adb2-243">Verificare che il driver FileX sia abilitato per ricevere le informazioni sul settore di rilascio e le richieste effettuate al driver per rilasciare i settori vengono gestite nel driver chiamando ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="0adb2-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
